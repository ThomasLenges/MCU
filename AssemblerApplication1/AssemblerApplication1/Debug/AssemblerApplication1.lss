
AVRASM ver. 2.2.6  C:\Users\renuka\Desktop\mcu\projet\MCU\AssemblerApplication1\AssemblerApplication1\main.asm Fri May 17 20:40:13 2024

[builtin](2): Including file 'C:/Program Files (x86)\Atmel\Studio\7.0\Packs\atmel\ATmega_DFP\1.1.130\avrasm\inc\m128def.inc'
C:\Users\renuka\Desktop\mcu\projet\MCU\AssemblerApplication1\AssemblerApplication1\main.asm(8): Including file 'C:/Program Files (x86)\Atmel\Studio\7.0\Packs\atmel\ATmega_DFP\1.1.130\avrasm\inc\m128def.inc'
C:\Users\renuka\Desktop\mcu\projet\MCU\AssemblerApplication1\AssemblerApplication1\main.asm(9): Including file 'C:\Users\renuka\Desktop\mcu\projet\MCU\AssemblerApplication1\AssemblerApplication1\definitions.asm'
C:\Users\renuka\Desktop\mcu\projet\MCU\AssemblerApplication1\AssemblerApplication1\main.asm(10): Including file 'C:\Users\renuka\Desktop\mcu\projet\MCU\AssemblerApplication1\AssemblerApplication1\macros.asm'
C:\Users\renuka\Desktop\mcu\projet\MCU\AssemblerApplication1\AssemblerApplication1\main.asm(23): Including file 'C:\Users\renuka\Desktop\mcu\projet\MCU\AssemblerApplication1\AssemblerApplication1\printf.asm'
C:\Users\renuka\Desktop\mcu\projet\MCU\AssemblerApplication1\AssemblerApplication1\main.asm(24): Including file 'C:\Users\renuka\Desktop\mcu\projet\MCU\AssemblerApplication1\AssemblerApplication1\string.asm'
C:\Users\renuka\Desktop\mcu\projet\MCU\AssemblerApplication1\AssemblerApplication1\main.asm(25): Including file 'C:\Users\renuka\Desktop\mcu\projet\MCU\AssemblerApplication1\AssemblerApplication1\lcd.asm'
C:\Users\renuka\Desktop\mcu\projet\MCU\AssemblerApplication1\AssemblerApplication1\main.asm(26): Including file 'C:\Users\renuka\Desktop\mcu\projet\MCU\AssemblerApplication1\AssemblerApplication1\display.asm'
C:\Users\renuka\Desktop\mcu\projet\MCU\AssemblerApplication1\AssemblerApplication1\main.asm(27): Including file 'C:\Users\renuka\Desktop\mcu\projet\MCU\AssemblerApplication1\AssemblerApplication1\subroutines.asm'
[builtin](2): Including file 'C:/Program Files (x86)\Atmel\Studio\7.0\Packs\atmel\ATmega_DFP\1.1.130\avrasm\inc\m128def.inc'
C:\Users\renuka\Desktop\mcu\projet\MCU\AssemblerApplication1\AssemblerApplication1\main.asm(8): Including file 'C:/Program Files (x86)\Atmel\Studio\7.0\Packs\atmel\ATmega_DFP\1.1.130\avrasm\inc\m128def.inc'
C:\Users\renuka\Desktop\mcu\projet\MCU\AssemblerApplication1\AssemblerApplication1\main.asm(9): Including file 'C:\Users\renuka\Desktop\mcu\projet\MCU\AssemblerApplication1\AssemblerApplication1\definitions.asm'
C:\Users\renuka\Desktop\mcu\projet\MCU\AssemblerApplication1\AssemblerApplication1\main.asm(10): Including file 'C:\Users\renuka\Desktop\mcu\projet\MCU\AssemblerApplication1\AssemblerApplication1\macros.asm'
C:\Users\renuka\Desktop\mcu\projet\MCU\AssemblerApplication1\AssemblerApplication1\main.asm(23): Including file 'C:\Users\renuka\Desktop\mcu\projet\MCU\AssemblerApplication1\AssemblerApplication1\printf.asm'
C:\Users\renuka\Desktop\mcu\projet\MCU\AssemblerApplication1\AssemblerApplication1\main.asm(24): Including file 'C:\Users\renuka\Desktop\mcu\projet\MCU\AssemblerApplication1\AssemblerApplication1\string.asm'
C:\Users\renuka\Desktop\mcu\projet\MCU\AssemblerApplication1\AssemblerApplication1\main.asm(25): Including file 'C:\Users\renuka\Desktop\mcu\projet\MCU\AssemblerApplication1\AssemblerApplication1\lcd.asm'
C:\Users\renuka\Desktop\mcu\projet\MCU\AssemblerApplication1\AssemblerApplication1\main.asm(26): Including file 'C:\Users\renuka\Desktop\mcu\projet\MCU\AssemblerApplication1\AssemblerApplication1\display.asm'
C:\Users\renuka\Desktop\mcu\projet\MCU\AssemblerApplication1\AssemblerApplication1\main.asm(27): Including file 'C:\Users\renuka\Desktop\mcu\projet\MCU\AssemblerApplication1\AssemblerApplication1\subroutines.asm'
                                 
                                 /*
                                 
                                 ;***** Created: 2011-02-09 12:03 ******* Source: ATmega128.xml ***********
                                 ;*************************************************************************
                                 ;* A P P L I C A T I O N   N O T E   F O R   T H E   A V R   F A M I L Y
                                 ;* 
                                 ;* Number            : AVR000
                                 ;* File Name         : "m128def.inc"
                                 ;* Title             : Register/Bit Definitions for the ATmega128
                                 ;* Date              : 2011-02-09
                                 ;* Version           : 2.35
                                 ;* Support E-mail    : avr@atmel.com
                                 ;* Target MCU        : ATmega128
                                 ;* 
                                 ;* DESCRIPTION
                                 ;* When including this file in the assembly program file, all I/O register 
                                 ;* names and I/O register bit names appearing in the data book can be used.
                                 ;* In addition, the six registers forming the three data pointers X, Y and 
                                 ;* Z have been assigned names XL - ZH. Highest RAM address for Internal 
                                 ;* SRAM is also defined 
                                 ;* 
                                 ;* The Register names are represented by their hexadecimal address.
                                 ;* 
                                 ;* The Register Bit names are represented by their bit number (0-7).
                                 ;* 
                                 ;* Please observe the difference in using the bit names with instructions
                                 ;* such as "sbr"/"cbr" (set/clear bit in register) and "sbrs"/"sbrc"
                                 ;* (skip if bit in register set/cleared). The following example illustrates
                                 ;* this:
                                 ;* 
                                 ;* in    r16,PORTB             ;read PORTB latch
                                 ;* sbr   r16,(1<<PB6)+(1<<PB5) ;set PB6 and PB5 (use masks, not bit#)
                                 ;* out   PORTB,r16             ;output to PORTB
                                 ;* 
                                 ;* in    r16,TIFR              ;read the Timer Interrupt Flag Register
                                 ;* sbrc  r16,TOV0              ;test the overflow flag (use bit#)
                                 ;* rjmp  TOV0_is_set           ;jump if set
                                 ;* ...                         ;otherwise do something else
                                 ;*************************************************************************
                                 
                                 #ifndef _M128DEF_INC_
                                 #define _M128DEF_INC_
                                 
                                 
                                 #pragma partinc 0
                                 
                                 ; ***** SPECIFY DEVICE ***************************************************
                                 .device ATmega128
                                 #pragma AVRPART ADMIN PART_NAME ATmega128
                                 .equ	SIGNATURE_000	= 0x1e
                                 .equ	SIGNATURE_001	= 0x97
                                 .equ	SIGNATURE_002	= 0x02
                                 
                                 #pragma AVRPART CORE CORE_VERSION V2E
                                 
                                 
                                 ; ***** I/O REGISTER DEFINITIONS *****************************************
                                 ; NOTE:
                                 ; Definitions marked "MEMORY MAPPED"are extended I/O ports
                                 ; and cannot be used with IN/OUT instructions
                                 .equ	UCSR1C	= 0x9d	; MEMORY MAPPED
                                 .equ	UDR1	= 0x9c	; MEMORY MAPPED
                                 .equ	UCSR1A	= 0x9b	; MEMORY MAPPED
                                 .equ	UCSR1B	= 0x9a	; MEMORY MAPPED
                                 .equ	UBRR1H	= 0x98	; MEMORY MAPPED
                                 .equ	UBRR1L	= 0x99	; MEMORY MAPPED
                                 .equ	UCSR0C	= 0x95	; MEMORY MAPPED
                                 .equ	UBRR0H	= 0x90	; MEMORY MAPPED
                                 .equ	TCCR3C	= 0x8c	; MEMORY MAPPED
                                 .equ	TCCR3A	= 0x8b	; MEMORY MAPPED
                                 .equ	TCCR3B	= 0x8a	; MEMORY MAPPED
                                 .equ	TCNT3L	= 0x88	; MEMORY MAPPED
                                 .equ	TCNT3H	= 0x89	; MEMORY MAPPED
                                 .equ	OCR3AL	= 0x86	; MEMORY MAPPED
                                 .equ	OCR3AH	= 0x87	; MEMORY MAPPED
                                 .equ	OCR3BL	= 0x84	; MEMORY MAPPED
                                 .equ	OCR3BH	= 0x85	; MEMORY MAPPED
                                 .equ	OCR3CL	= 0x82	; MEMORY MAPPED
                                 .equ	OCR3CH	= 0x83	; MEMORY MAPPED
                                 .equ	ICR3L	= 0x80	; MEMORY MAPPED
                                 .equ	ICR3H	= 0x81	; MEMORY MAPPED
                                 .equ	ETIMSK	= 0x7d	; MEMORY MAPPED
                                 .equ	ETIFR	= 0x7c	; MEMORY MAPPED
                                 .equ	TCCR1C	= 0x7a	; MEMORY MAPPED
                                 .equ	OCR1CL	= 0x78	; MEMORY MAPPED
                                 .equ	OCR1CH	= 0x79	; MEMORY MAPPED
                                 .equ	TWCR	= 0x74	; MEMORY MAPPED
                                 .equ	TWDR	= 0x73	; MEMORY MAPPED
                                 .equ	TWAR	= 0x72	; MEMORY MAPPED
                                 .equ	TWSR	= 0x71	; MEMORY MAPPED
                                 .equ	TWBR	= 0x70	; MEMORY MAPPED
                                 .equ	OSCCAL	= 0x6f	; MEMORY MAPPED
                                 .equ	XMCRA	= 0x6d	; MEMORY MAPPED
                                 .equ	XMCRB	= 0x6c	; MEMORY MAPPED
                                 .equ	EICRA	= 0x6a	; MEMORY MAPPED
                                 .equ	SPMCSR	= 0x68	; MEMORY MAPPED
                                 .equ	PORTG	= 0x65	; MEMORY MAPPED
                                 .equ	DDRG	= 0x64	; MEMORY MAPPED
                                 .equ	PING	= 0x63	; MEMORY MAPPED
                                 .equ	PORTF	= 0x62	; MEMORY MAPPED
                                 .equ	DDRF	= 0x61	; MEMORY MAPPED
                                 .equ	SREG	= 0x3f
                                 .equ	SPL	= 0x3d
                                 .equ	SPH	= 0x3e
                                 .equ	XDIV	= 0x3c
                                 .equ	RAMPZ	= 0x3b
                                 .equ	EICRB	= 0x3a
                                 .equ	EIMSK	= 0x39
                                 .equ	EIFR	= 0x38
                                 .equ	TIMSK	= 0x37
                                 .equ	TIFR	= 0x36
                                 .equ	MCUCR	= 0x35
                                 .equ	MCUCSR	= 0x34
                                 .equ	TCCR0	= 0x33
                                 .equ	TCNT0	= 0x32
                                 .equ	OCR0	= 0x31
                                 .equ	ASSR	= 0x30
                                 .equ	TCCR1A	= 0x2f
                                 .equ	TCCR1B	= 0x2e
                                 .equ	TCNT1L	= 0x2c
                                 .equ	TCNT1H	= 0x2d
                                 .equ	OCR1AL	= 0x2a
                                 .equ	OCR1AH	= 0x2b
                                 .equ	OCR1BL	= 0x28
                                 .equ	OCR1BH	= 0x29
                                 .equ	ICR1L	= 0x26
                                 .equ	ICR1H	= 0x27
                                 .equ	TCCR2	= 0x25
                                 .equ	TCNT2	= 0x24
                                 .equ	OCR2	= 0x23
                                 .equ	OCDR	= 0x22
                                 .equ	WDTCR	= 0x21
                                 .equ	SFIOR	= 0x20
                                 .equ	EEARL	= 0x1e
                                 .equ	EEARH	= 0x1f
                                 .equ	EEDR	= 0x1d
                                 .equ	EECR	= 0x1c
                                 .equ	PORTA	= 0x1b
                                 .equ	DDRA	= 0x1a
                                 .equ	PINA	= 0x19
                                 .equ	PORTB	= 0x18
                                 .equ	DDRB	= 0x17
                                 .equ	PINB	= 0x16
                                 .equ	PORTC	= 0x15
                                 .equ	DDRC	= 0x14
                                 .equ	PINC	= 0x13
                                 .equ	PORTD	= 0x12
                                 .equ	DDRD	= 0x11
                                 .equ	PIND	= 0x10
                                 .equ	SPDR	= 0x0f
                                 .equ	SPSR	= 0x0e
                                 .equ	SPCR	= 0x0d
                                 .equ	UDR0	= 0x0c
                                 .equ	UCSR0A	= 0x0b
                                 .equ	UCSR0B	= 0x0a
                                 .equ	UBRR0L	= 0x09
                                 .equ	ACSR	= 0x08
                                 .equ	ADMUX	= 0x07
                                 .equ	ADCSRA	= 0x06
                                 .equ	ADCH	= 0x05
                                 .equ	ADCL	= 0x04
                                 .equ	PORTE	= 0x03
                                 .equ	DDRE	= 0x02
                                 .equ	PINE	= 0x01
                                 .equ	PINF	= 0x00
                                 
                                 
                                 ; ***** BIT DEFINITIONS **************************************************
                                 
                                 ; ***** ANALOG_COMPARATOR ************
                                 ; SFIOR - Special Function IO Register
                                 .equ	ACME	= 3	; Analog Comparator Multiplexer Enable
                                 
                                 ; ACSR - Analog Comparator Control And Status Register
                                 .equ	ACIS0	= 0	; Analog Comparator Interrupt Mode Select bit 0
                                 .equ	ACIS1	= 1	; Analog Comparator Interrupt Mode Select bit 1
                                 .equ	ACIC	= 2	; Analog Comparator Input Capture Enable
                                 .equ	ACIE	= 3	; Analog Comparator Interrupt Enable
                                 .equ	ACI	= 4	; Analog Comparator Interrupt Flag
                                 .equ	ACO	= 5	; Analog Compare Output
                                 .equ	ACBG	= 6	; Analog Comparator Bandgap Select
                                 .equ	ACD	= 7	; Analog Comparator Disable
                                 
                                 
                                 ; ***** SPI **************************
                                 ; SPDR - SPI Data Register
                                 .equ	SPDR0	= 0	; SPI Data Register bit 0
                                 .equ	SPDR1	= 1	; SPI Data Register bit 1
                                 .equ	SPDR2	= 2	; SPI Data Register bit 2
                                 .equ	SPDR3	= 3	; SPI Data Register bit 3
                                 .equ	SPDR4	= 4	; SPI Data Register bit 4
                                 .equ	SPDR5	= 5	; SPI Data Register bit 5
                                 .equ	SPDR6	= 6	; SPI Data Register bit 6
                                 .equ	SPDR7	= 7	; SPI Data Register bit 7
                                 
                                 ; SPSR - SPI Status Register
                                 .equ	SPI2X	= 0	; Double SPI Speed Bit
                                 .equ	WCOL	= 6	; Write Collision Flag
                                 .equ	SPIF	= 7	; SPI Interrupt Flag
                                 
                                 ; SPCR - SPI Control Register
                                 .equ	SPR0	= 0	; SPI Clock Rate Select 0
                                 .equ	SPR1	= 1	; SPI Clock Rate Select 1
                                 .equ	CPHA	= 2	; Clock Phase
                                 .equ	CPOL	= 3	; Clock polarity
                                 .equ	MSTR	= 4	; Master/Slave Select
                                 .equ	DORD	= 5	; Data Order
                                 .equ	SPE	= 6	; SPI Enable
                                 .equ	SPIE	= 7	; SPI Interrupt Enable
                                 
                                 
                                 ; ***** TWI **************************
                                 ; TWBR - TWI Bit Rate register
                                 .equ	I2BR	= TWBR	; For compatibility
                                 .equ	TWBR0	= 0	; 
                                 .equ	TWBR1	= 1	; 
                                 .equ	TWBR2	= 2	; 
                                 .equ	TWBR3	= 3	; 
                                 .equ	TWBR4	= 4	; 
                                 .equ	TWBR5	= 5	; 
                                 .equ	TWBR6	= 6	; 
                                 .equ	TWBR7	= 7	; 
                                 
                                 ; TWCR - TWI Control Register
                                 .equ	I2CR	= TWCR	; For compatibility
                                 .equ	TWIE	= 0	; TWI Interrupt Enable
                                 .equ	I2IE	= TWIE	; For compatibility
                                 .equ	TWEN	= 2	; TWI Enable Bit
                                 .equ	I2EN	= TWEN	; For compatibility
                                 .equ	ENI2C	= TWEN	; For compatibility
                                 .equ	TWWC	= 3	; TWI Write Collition Flag
                                 .equ	I2WC	= TWWC	; For compatibility
                                 .equ	TWSTO	= 4	; TWI Stop Condition Bit
                                 .equ	I2STO	= TWSTO	; For compatibility
                                 .equ	TWSTA	= 5	; TWI Start Condition Bit
                                 .equ	I2STA	= TWSTA	; For compatibility
                                 .equ	TWEA	= 6	; TWI Enable Acknowledge Bit
                                 .equ	I2EA	= TWEA	; For compatibility
                                 .equ	TWINT	= 7	; TWI Interrupt Flag
                                 .equ	I2INT	= TWINT	; For compatibility
                                 
                                 ; TWSR - TWI Status Register
                                 .equ	I2SR	= TWSR	; For compatibility
                                 .equ	TWPS0	= 0	; TWI Prescaler
                                 .equ	TWS0	= TWPS0	; For compatibility
                                 .equ	I2GCE	= TWPS0	; For compatibility
                                 .equ	TWPS1	= 1	; TWI Prescaler
                                 .equ	TWS1	= TWPS1	; For compatibility
                                 .equ	TWS3	= 3	; TWI Status
                                 .equ	I2S3	= TWS3	; For compatibility
                                 .equ	TWS4	= 4	; TWI Status
                                 .equ	I2S4	= TWS4	; For compatibility
                                 .equ	TWS5	= 5	; TWI Status
                                 .equ	I2S5	= TWS5	; For compatibility
                                 .equ	TWS6	= 6	; TWI Status
                                 .equ	I2S6	= TWS6	; For compatibility
                                 .equ	TWS7	= 7	; TWI Status
                                 .equ	I2S7	= TWS7	; For compatibility
                                 
                                 ; TWDR - TWI Data register
                                 .equ	I2DR	= TWDR	; For compatibility
                                 .equ	TWD0	= 0	; TWI Data Register Bit 0
                                 .equ	TWD1	= 1	; TWI Data Register Bit 1
                                 .equ	TWD2	= 2	; TWI Data Register Bit 2
                                 .equ	TWD3	= 3	; TWI Data Register Bit 3
                                 .equ	TWD4	= 4	; TWI Data Register Bit 4
                                 .equ	TWD5	= 5	; TWI Data Register Bit 5
                                 .equ	TWD6	= 6	; TWI Data Register Bit 6
                                 .equ	TWD7	= 7	; TWI Data Register Bit 7
                                 
                                 ; TWAR - TWI (Slave) Address register
                                 .equ	I2AR	= TWAR	; For compatibility
                                 .equ	TWGCE	= 0	; TWI General Call Recognition Enable Bit
                                 .equ	TWA0	= 1	; TWI (Slave) Address register Bit 0
                                 .equ	TWA1	= 2	; TWI (Slave) Address register Bit 1
                                 .equ	TWA2	= 3	; TWI (Slave) Address register Bit 2
                                 .equ	TWA3	= 4	; TWI (Slave) Address register Bit 3
                                 .equ	TWA4	= 5	; TWI (Slave) Address register Bit 4
                                 .equ	TWA5	= 6	; TWI (Slave) Address register Bit 5
                                 .equ	TWA6	= 7	; TWI (Slave) Address register Bit 6
                                 
                                 
                                 ; ***** USART0 ***********************
                                 ; UDR0 - USART I/O Data Register
                                 .equ	UDR00	= 0	; USART I/O Data Register bit 0
                                 .equ	UDR01	= 1	; USART I/O Data Register bit 1
                                 .equ	UDR02	= 2	; USART I/O Data Register bit 2
                                 .equ	UDR03	= 3	; USART I/O Data Register bit 3
                                 .equ	UDR04	= 4	; USART I/O Data Register bit 4
                                 .equ	UDR05	= 5	; USART I/O Data Register bit 5
                                 .equ	UDR06	= 6	; USART I/O Data Register bit 6
                                 .equ	UDR07	= 7	; USART I/O Data Register bit 7
                                 
                                 ; UCSR0A - USART Control and Status Register A
                                 .equ	MPCM0	= 0	; Multi-processor Communication Mode
                                 .equ	U2X0	= 1	; Double the USART transmission speed
                                 .equ	UPE0	= 2	; Parity Error
                                 .equ	DOR0	= 3	; Data overRun
                                 .equ	FE0	= 4	; Framing Error
                                 .equ	UDRE0	= 5	; USART Data Register Empty
                                 .equ	TXC0	= 6	; USART Transmitt Complete
                                 .equ	RXC0	= 7	; USART Receive Complete
                                 
                                 ; UCSR0B - USART Control and Status Register B
                                 .equ	TXB80	= 0	; Transmit Data Bit 8
                                 .equ	RXB80	= 1	; Receive Data Bit 8
                                 .equ	UCSZ02	= 2	; Character Size
                                 .equ	UCSZ2	= UCSZ02	; For compatibility
                                 .equ	TXEN0	= 3	; Transmitter Enable
                                 .equ	RXEN0	= 4	; Receiver Enable
                                 .equ	UDRIE0	= 5	; USART Data register Empty Interrupt Enable
                                 .equ	TXCIE0	= 6	; TX Complete Interrupt Enable
                                 .equ	RXCIE0	= 7	; RX Complete Interrupt Enable
                                 
                                 ; UCSR0C - USART Control and Status Register C
                                 .equ	UCPOL0	= 0	; Clock Polarity
                                 .equ	UCSZ00	= 1	; Character Size
                                 .equ	UCSZ01	= 2	; Character Size
                                 .equ	USBS0	= 3	; Stop Bit Select
                                 .equ	UPM00	= 4	; Parity Mode Bit 0
                                 .equ	UPM01	= 5	; Parity Mode Bit 1
                                 .equ	UMSEL0	= 6	; USART Mode Select
                                 
                                 ; UBRR0H - USART Baud Rate Register Hight Byte
                                 .equ	UBRR8	= 0	; USART Baud Rate Register bit 8
                                 .equ	UBRR9	= 1	; USART Baud Rate Register bit 9
                                 .equ	UBRR10	= 2	; USART Baud Rate Register bit 10
                                 .equ	UBRR11	= 3	; USART Baud Rate Register bit 11
                                 
                                 ; UBRR0L - USART Baud Rate Register Low Byte
                                 .equ	UBRR0	= 0	; USART Baud Rate Register bit 0
                                 .equ	UBRR1	= 1	; USART Baud Rate Register bit 1
                                 .equ	UBRR2	= 2	; USART Baud Rate Register bit 2
                                 .equ	UBRR3	= 3	; USART Baud Rate Register bit 3
                                 .equ	UBRR4	= 4	; USART Baud Rate Register bit 4
                                 .equ	UBRR5	= 5	; USART Baud Rate Register bit 5
                                 .equ	UBRR6	= 6	; USART Baud Rate Register bit 6
                                 .equ	UBRR7	= 7	; USART Baud Rate Register bit 7
                                 
                                 
                                 ; ***** USART1 ***********************
                                 ; UDR1 - USART I/O Data Register
                                 .equ	UDR10	= 0	; USART I/O Data Register bit 0
                                 .equ	UDR11	= 1	; USART I/O Data Register bit 1
                                 .equ	UDR12	= 2	; USART I/O Data Register bit 2
                                 .equ	UDR13	= 3	; USART I/O Data Register bit 3
                                 .equ	UDR14	= 4	; USART I/O Data Register bit 4
                                 .equ	UDR15	= 5	; USART I/O Data Register bit 5
                                 .equ	UDR16	= 6	; USART I/O Data Register bit 6
                                 .equ	UDR17	= 7	; USART I/O Data Register bit 7
                                 
                                 ; UCSR1A - USART Control and Status Register A
                                 .equ	MPCM1	= 0	; Multi-processor Communication Mode
                                 .equ	U2X1	= 1	; Double the USART transmission speed
                                 .equ	UPE1	= 2	; Parity Error
                                 .equ	DOR1	= 3	; Data overRun
                                 .equ	FE1	= 4	; Framing Error
                                 .equ	UDRE1	= 5	; USART Data Register Empty
                                 .equ	TXC1	= 6	; USART Transmitt Complete
                                 .equ	RXC1	= 7	; USART Receive Complete
                                 
                                 ; UCSR1B - USART Control and Status Register B
                                 .equ	TXB81	= 0	; Transmit Data Bit 8
                                 .equ	RXB81	= 1	; Receive Data Bit 8
                                 .equ	UCSZ12	= 2	; Character Size
                                 .equ	TXEN1	= 3	; Transmitter Enable
                                 .equ	RXEN1	= 4	; Receiver Enable
                                 .equ	UDRIE1	= 5	; USART Data register Empty Interrupt Enable
                                 .equ	TXCIE1	= 6	; TX Complete Interrupt Enable
                                 .equ	RXCIE1	= 7	; RX Complete Interrupt Enable
                                 
                                 ; UCSR1C - USART Control and Status Register C
                                 .equ	UCPOL1	= 0	; Clock Polarity
                                 .equ	UCSZ10	= 1	; Character Size
                                 .equ	UCSZ11	= 2	; Character Size
                                 .equ	USBS1	= 3	; Stop Bit Select
                                 .equ	UPM10	= 4	; Parity Mode Bit 0
                                 .equ	UPM11	= 5	; Parity Mode Bit 1
                                 .equ	UMSEL1	= 6	; USART Mode Select
                                 
                                 ; UBRR1H - USART Baud Rate Register Hight Byte
                                 ;.equ	UBRR8	= 0	; USART Baud Rate Register bit 8
                                 ;.equ	UBRR9	= 1	; USART Baud Rate Register bit 9
                                 ;.equ	UBRR10	= 2	; USART Baud Rate Register bit 10
                                 ;.equ	UBRR11	= 3	; USART Baud Rate Register bit 11
                                 
                                 ; UBRR1L - USART Baud Rate Register Low Byte
                                 ;.equ	UBRR0	= 0	; USART Baud Rate Register bit 0
                                 ;.equ	UBRR1	= 1	; USART Baud Rate Register bit 1
                                 ;.equ	UBRR2	= 2	; USART Baud Rate Register bit 2
                                 ;.equ	UBRR3	= 3	; USART Baud Rate Register bit 3
                                 ;.equ	UBRR4	= 4	; USART Baud Rate Register bit 4
                                 ;.equ	UBRR5	= 5	; USART Baud Rate Register bit 5
                                 ;.equ	UBRR6	= 6	; USART Baud Rate Register bit 6
                                 ;.equ	UBRR7	= 7	; USART Baud Rate Register bit 7
                                 
                                 
                                 ; ***** CPU **************************
                                 ; SREG - Status Register
                                 .equ	SREG_C	= 0	; Carry Flag
                                 .equ	SREG_Z	= 1	; Zero Flag
                                 .equ	SREG_N	= 2	; Negative Flag
                                 .equ	SREG_V	= 3	; Two's Complement Overflow Flag
                                 .equ	SREG_S	= 4	; Sign Bit
                                 .equ	SREG_H	= 5	; Half Carry Flag
                                 .equ	SREG_T	= 6	; Bit Copy Storage
                                 .equ	SREG_I	= 7	; Global Interrupt Enable
                                 
                                 ; MCUCR - MCU Control Register
                                 .equ	IVCE	= 0	; Interrupt Vector Change Enable
                                 .equ	IVSEL	= 1	; Interrupt Vector Select
                                 .equ	SM2	= 2	; Sleep Mode Select
                                 .equ	SM0	= 3	; Sleep Mode Select
                                 .equ	SM1	= 4	; Sleep Mode Select
                                 .equ	SE	= 5	; Sleep Enable
                                 .equ	SRW10	= 6	; External SRAM Wait State Select
                                 .equ	SRE	= 7	; External SRAM Enable
                                 
                                 ; XMCRA - External Memory Control Register A
                                 .equ	SRW11	= 1	; Wait state select bit upper page
                                 .equ	SRW00	= 2	; Wait state select bit lower page
                                 .equ	SRW01	= 3	; Wait state select bit lower page
                                 .equ	SRL0	= 4	; Wait state page limit
                                 .equ	SRL1	= 5	; Wait state page limit
                                 .equ	SRL2	= 6	; Wait state page limit
                                 
                                 ; XMCRB - External Memory Control Register B
                                 .equ	XMM0	= 0	; External Memory High Mask
                                 .equ	XMM1	= 1	; External Memory High Mask
                                 .equ	XMM2	= 2	; External Memory High Mask
                                 .equ	XMBK	= 7	; External Memory Bus Keeper Enable
                                 
                                 ; OSCCAL - Oscillator Calibration Value
                                 .equ	CAL0	= 0	; Oscillator Calibration Value
                                 .equ	CAL1	= 1	; Oscillator Calibration Value
                                 .equ	CAL2	= 2	; Oscillator Calibration Value
                                 .equ	CAL3	= 3	; Oscillator Calibration Value
                                 .equ	CAL4	= 4	; Oscillator Calibration Value
                                 .equ	CAL5	= 5	; Oscillator Calibration Value
                                 .equ	CAL6	= 6	; Oscillator Calibration Value
                                 .equ	CAL7	= 7	; Oscillator Calibration Value
                                 
                                 ; XDIV - XTAL Divide Control Register
                                 .equ	XDIV0	= 0	; XTAl Divide Select Bit 0
                                 .equ	XDIV1	= 1	; XTAl Divide Select Bit 1
                                 .equ	XDIV2	= 2	; XTAl Divide Select Bit 2
                                 .equ	XDIV3	= 3	; XTAl Divide Select Bit 3
                                 .equ	XDIV4	= 4	; XTAl Divide Select Bit 4
                                 .equ	XDIV5	= 5	; XTAl Divide Select Bit 5
                                 .equ	XDIV6	= 6	; XTAl Divide Select Bit 6
                                 .equ	XDIVEN	= 7	; XTAL Divide Enable
                                 
                                 ; MCUCSR - MCU Control And Status Register
                                 .equ	PORF	= 0	; Power-on reset flag
                                 .equ	EXTRF	= 1	; External Reset Flag
                                 .equ	BORF	= 2	; Brown-out Reset Flag
                                 .equ	WDRF	= 3	; Watchdog Reset Flag
                                 .equ	JTRF	= 4	; JTAG Reset Flag
                                 .equ	JTD	= 7	; JTAG Interface Disable
                                 
                                 ; RAMPZ - RAM Page Z Select Register
                                 .equ	RAMPZ0	= 0	; RAM Page Z Select Register Bit 0
                                 
                                 
                                 ; ***** BOOT_LOAD ********************
                                 ; SPMCSR - Store Program Memory Control Register
                                 .equ	SPMCR	= SPMCSR	; For compatibility
                                 .equ	SPMEN	= 0	; Store Program Memory Enable
                                 .equ	PGERS	= 1	; Page Erase
                                 .equ	PGWRT	= 2	; Page Write
                                 .equ	BLBSET	= 3	; Boot Lock Bit Set
                                 .equ	RWWSRE	= 4	; Read While Write section read enable
                                 .equ	ASRE	= RWWSRE	; For compatibility
                                 .equ	RWWSB	= 6	; Read While Write Section Busy
                                 .equ	ASB	= RWWSB	; For compatibility
                                 .equ	SPMIE	= 7	; SPM Interrupt Enable
                                 
                                 
                                 ; ***** JTAG *************************
                                 ; OCDR - On-Chip Debug Related Register in I/O Memory
                                 .equ	OCDR0	= 0	; On-Chip Debug Register Bit 0
                                 .equ	OCDR1	= 1	; On-Chip Debug Register Bit 1
                                 .equ	OCDR2	= 2	; On-Chip Debug Register Bit 2
                                 .equ	OCDR3	= 3	; On-Chip Debug Register Bit 3
                                 .equ	OCDR4	= 4	; On-Chip Debug Register Bit 4
                                 .equ	OCDR5	= 5	; On-Chip Debug Register Bit 5
                                 .equ	OCDR6	= 6	; On-Chip Debug Register Bit 6
                                 .equ	OCDR7	= 7	; On-Chip Debug Register Bit 7
                                 .equ	IDRD	= OCDR7	; For compatibility
                                 
                                 ; MCUCSR - MCU Control And Status Register
                                 ;.equ	JTRF	= 4	; JTAG Reset Flag
                                 ;.equ	JTD	= 7	; JTAG Interface Disable
                                 
                                 
                                 ; ***** MISC *************************
                                 ; SFIOR - Special Function IO Register
                                 .equ	PSR321	= 0	; Prescaler Reset Timer/Counter3, Timer/Counter2, and Timer/Counter1
                                 .equ	PSR1	= PSR321	; For compatibility
                                 .equ	PSR2	= PSR321	; For compatibility
                                 .equ	PSR3	= PSR321	; For compatibility
                                 .equ	PSR0	= 1	; Prescaler Reset Timer/Counter0
                                 .equ	PUD	= 2	; Pull Up Disable
                                 ;.equ	ACME	= 3	; Analog Comparator Multiplexer Enable
                                 .equ	TSM	= 7	; Timer/Counter Synchronization Mode
                                 
                                 
                                 ; ***** EXTERNAL_INTERRUPT ***********
                                 ; EICRA - External Interrupt Control Register A
                                 .equ	ISC00	= 0	; External Interrupt Sense Control Bit
                                 .equ	ISC01	= 1	; External Interrupt Sense Control Bit
                                 .equ	ISC10	= 2	; External Interrupt Sense Control Bit
                                 .equ	ISC11	= 3	; External Interrupt Sense Control Bit
                                 .equ	ISC20	= 4	; External Interrupt Sense Control Bit
                                 .equ	ISC21	= 5	; External Interrupt Sense Control Bit
                                 .equ	ISC30	= 6	; External Interrupt Sense Control Bit
                                 .equ	ISC31	= 7	; External Interrupt Sense Control Bit
                                 
                                 ; EICRB - External Interrupt Control Register B
                                 .equ	ISC40	= 0	; External Interrupt 7-4 Sense Control Bit
                                 .equ	ISC41	= 1	; External Interrupt 7-4 Sense Control Bit
                                 .equ	ISC50	= 2	; External Interrupt 7-4 Sense Control Bit
                                 .equ	ISC51	= 3	; External Interrupt 7-4 Sense Control Bit
                                 .equ	ISC60	= 4	; External Interrupt 7-4 Sense Control Bit
                                 .equ	ISC61	= 5	; External Interrupt 7-4 Sense Control Bit
                                 .equ	ISC70	= 6	; External Interrupt 7-4 Sense Control Bit
                                 .equ	ISC71	= 7	; External Interrupt 7-4 Sense Control Bit
                                 
                                 ; EIMSK - External Interrupt Mask Register
                                 .equ	GICR	= EIMSK	; For compatibility
                                 .equ	GIMSK	= EIMSK	; For compatibility
                                 .equ	INT0	= 0	; External Interrupt Request 0 Enable
                                 .equ	INT1	= 1	; External Interrupt Request 1 Enable
                                 .equ	INT2	= 2	; External Interrupt Request 2 Enable
                                 .equ	INT3	= 3	; External Interrupt Request 3 Enable
                                 .equ	INT4	= 4	; External Interrupt Request 4 Enable
                                 .equ	INT5	= 5	; External Interrupt Request 5 Enable
                                 .equ	INT6	= 6	; External Interrupt Request 6 Enable
                                 .equ	INT7	= 7	; External Interrupt Request 7 Enable
                                 
                                 ; EIFR - External Interrupt Flag Register
                                 .equ	GIFR	= EIFR	; For compatibility
                                 .equ	INTF0	= 0	; External Interrupt Flag 0
                                 .equ	INTF1	= 1	; External Interrupt Flag 1
                                 .equ	INTF2	= 2	; External Interrupt Flag 2
                                 .equ	INTF3	= 3	; External Interrupt Flag 3
                                 .equ	INTF4	= 4	; External Interrupt Flag 4
                                 .equ	INTF5	= 5	; External Interrupt Flag 5
                                 .equ	INTF6	= 6	; External Interrupt Flag 6
                                 .equ	INTF7	= 7	; External Interrupt Flag 7
                                 
                                 
                                 ; ***** EEPROM ***********************
                                 ; EEDR - EEPROM Data Register
                                 .equ	EEDR0	= 0	; EEPROM Data Register bit 0
                                 .equ	EEDR1	= 1	; EEPROM Data Register bit 1
                                 .equ	EEDR2	= 2	; EEPROM Data Register bit 2
                                 .equ	EEDR3	= 3	; EEPROM Data Register bit 3
                                 .equ	EEDR4	= 4	; EEPROM Data Register bit 4
                                 .equ	EEDR5	= 5	; EEPROM Data Register bit 5
                                 .equ	EEDR6	= 6	; EEPROM Data Register bit 6
                                 .equ	EEDR7	= 7	; EEPROM Data Register bit 7
                                 
                                 ; EECR - EEPROM Control Register
                                 .equ	EERE	= 0	; EEPROM Read Enable
                                 .equ	EEWE	= 1	; EEPROM Write Enable
                                 .equ	EEMWE	= 2	; EEPROM Master Write Enable
                                 .equ	EERIE	= 3	; EEPROM Ready Interrupt Enable
                                 
                                 
                                 ; ***** PORTA ************************
                                 ; PORTA - Port A Data Register
                                 .equ	PORTA0	= 0	; Port A Data Register bit 0
                                 .equ	PA0	= 0	; For compatibility
                                 .equ	PORTA1	= 1	; Port A Data Register bit 1
                                 .equ	PA1	= 1	; For compatibility
                                 .equ	PORTA2	= 2	; Port A Data Register bit 2
                                 .equ	PA2	= 2	; For compatibility
                                 .equ	PORTA3	= 3	; Port A Data Register bit 3
                                 .equ	PA3	= 3	; For compatibility
                                 .equ	PORTA4	= 4	; Port A Data Register bit 4
                                 .equ	PA4	= 4	; For compatibility
                                 .equ	PORTA5	= 5	; Port A Data Register bit 5
                                 .equ	PA5	= 5	; For compatibility
                                 .equ	PORTA6	= 6	; Port A Data Register bit 6
                                 .equ	PA6	= 6	; For compatibility
                                 .equ	PORTA7	= 7	; Port A Data Register bit 7
                                 .equ	PA7	= 7	; For compatibility
                                 
                                 ; DDRA - Port A Data Direction Register
                                 .equ	DDA0	= 0	; Data Direction Register, Port A, bit 0
                                 .equ	DDA1	= 1	; Data Direction Register, Port A, bit 1
                                 .equ	DDA2	= 2	; Data Direction Register, Port A, bit 2
                                 .equ	DDA3	= 3	; Data Direction Register, Port A, bit 3
                                 .equ	DDA4	= 4	; Data Direction Register, Port A, bit 4
                                 .equ	DDA5	= 5	; Data Direction Register, Port A, bit 5
                                 .equ	DDA6	= 6	; Data Direction Register, Port A, bit 6
                                 .equ	DDA7	= 7	; Data Direction Register, Port A, bit 7
                                 
                                 ; PINA - Port A Input Pins
                                 .equ	PINA0	= 0	; Input Pins, Port A bit 0
                                 .equ	PINA1	= 1	; Input Pins, Port A bit 1
                                 .equ	PINA2	= 2	; Input Pins, Port A bit 2
                                 .equ	PINA3	= 3	; Input Pins, Port A bit 3
                                 .equ	PINA4	= 4	; Input Pins, Port A bit 4
                                 .equ	PINA5	= 5	; Input Pins, Port A bit 5
                                 .equ	PINA6	= 6	; Input Pins, Port A bit 6
                                 .equ	PINA7	= 7	; Input Pins, Port A bit 7
                                 
                                 
                                 ; ***** PORTB ************************
                                 ; PORTB - Port B Data Register
                                 .equ	PORTB0	= 0	; Port B Data Register bit 0
                                 .equ	PB0	= 0	; For compatibility
                                 .equ	PORTB1	= 1	; Port B Data Register bit 1
                                 .equ	PB1	= 1	; For compatibility
                                 .equ	PORTB2	= 2	; Port B Data Register bit 2
                                 .equ	PB2	= 2	; For compatibility
                                 .equ	PORTB3	= 3	; Port B Data Register bit 3
                                 .equ	PB3	= 3	; For compatibility
                                 .equ	PORTB4	= 4	; Port B Data Register bit 4
                                 .equ	PB4	= 4	; For compatibility
                                 .equ	PORTB5	= 5	; Port B Data Register bit 5
                                 .equ	PB5	= 5	; For compatibility
                                 .equ	PORTB6	= 6	; Port B Data Register bit 6
                                 .equ	PB6	= 6	; For compatibility
                                 .equ	PORTB7	= 7	; Port B Data Register bit 7
                                 .equ	PB7	= 7	; For compatibility
                                 
                                 ; DDRB - Port B Data Direction Register
                                 .equ	DDB0	= 0	; Port B Data Direction Register bit 0
                                 .equ	DDB1	= 1	; Port B Data Direction Register bit 1
                                 .equ	DDB2	= 2	; Port B Data Direction Register bit 2
                                 .equ	DDB3	= 3	; Port B Data Direction Register bit 3
                                 .equ	DDB4	= 4	; Port B Data Direction Register bit 4
                                 .equ	DDB5	= 5	; Port B Data Direction Register bit 5
                                 .equ	DDB6	= 6	; Port B Data Direction Register bit 6
                                 .equ	DDB7	= 7	; Port B Data Direction Register bit 7
                                 
                                 ; PINB - Port B Input Pins
                                 .equ	PINB0	= 0	; Port B Input Pins bit 0
                                 .equ	PINB1	= 1	; Port B Input Pins bit 1
                                 .equ	PINB2	= 2	; Port B Input Pins bit 2
                                 .equ	PINB3	= 3	; Port B Input Pins bit 3
                                 .equ	PINB4	= 4	; Port B Input Pins bit 4
                                 .equ	PINB5	= 5	; Port B Input Pins bit 5
                                 .equ	PINB6	= 6	; Port B Input Pins bit 6
                                 .equ	PINB7	= 7	; Port B Input Pins bit 7
                                 
                                 
                                 ; ***** PORTC ************************
                                 ; PORTC - Port C Data Register
                                 .equ	PORTC0	= 0	; Port C Data Register bit 0
                                 .equ	PC0	= 0	; For compatibility
                                 .equ	PORTC1	= 1	; Port C Data Register bit 1
                                 .equ	PC1	= 1	; For compatibility
                                 .equ	PORTC2	= 2	; Port C Data Register bit 2
                                 .equ	PC2	= 2	; For compatibility
                                 .equ	PORTC3	= 3	; Port C Data Register bit 3
                                 .equ	PC3	= 3	; For compatibility
                                 .equ	PORTC4	= 4	; Port C Data Register bit 4
                                 .equ	PC4	= 4	; For compatibility
                                 .equ	PORTC5	= 5	; Port C Data Register bit 5
                                 .equ	PC5	= 5	; For compatibility
                                 .equ	PORTC6	= 6	; Port C Data Register bit 6
                                 .equ	PC6	= 6	; For compatibility
                                 .equ	PORTC7	= 7	; Port C Data Register bit 7
                                 .equ	PC7	= 7	; For compatibility
                                 
                                 ; DDRC - Port C Data Direction Register
                                 .equ	DDC0	= 0	; Port C Data Direction Register bit 0
                                 .equ	DDC1	= 1	; Port C Data Direction Register bit 1
                                 .equ	DDC2	= 2	; Port C Data Direction Register bit 2
                                 .equ	DDC3	= 3	; Port C Data Direction Register bit 3
                                 .equ	DDC4	= 4	; Port C Data Direction Register bit 4
                                 .equ	DDC5	= 5	; Port C Data Direction Register bit 5
                                 .equ	DDC6	= 6	; Port C Data Direction Register bit 6
                                 .equ	DDC7	= 7	; Port C Data Direction Register bit 7
                                 
                                 ; PINC - Port C Input Pins
                                 .equ	PINC0	= 0	; Port C Input Pins bit 0
                                 .equ	PINC1	= 1	; Port C Input Pins bit 1
                                 .equ	PINC2	= 2	; Port C Input Pins bit 2
                                 .equ	PINC3	= 3	; Port C Input Pins bit 3
                                 .equ	PINC4	= 4	; Port C Input Pins bit 4
                                 .equ	PINC5	= 5	; Port C Input Pins bit 5
                                 .equ	PINC6	= 6	; Port C Input Pins bit 6
                                 .equ	PINC7	= 7	; Port C Input Pins bit 7
                                 
                                 
                                 ; ***** PORTD ************************
                                 ; PORTD - Port D Data Register
                                 .equ	PORTD0	= 0	; Port D Data Register bit 0
                                 .equ	PD0	= 0	; For compatibility
                                 .equ	PORTD1	= 1	; Port D Data Register bit 1
                                 .equ	PD1	= 1	; For compatibility
                                 .equ	PORTD2	= 2	; Port D Data Register bit 2
                                 .equ	PD2	= 2	; For compatibility
                                 .equ	PORTD3	= 3	; Port D Data Register bit 3
                                 .equ	PD3	= 3	; For compatibility
                                 .equ	PORTD4	= 4	; Port D Data Register bit 4
                                 .equ	PD4	= 4	; For compatibility
                                 .equ	PORTD5	= 5	; Port D Data Register bit 5
                                 .equ	PD5	= 5	; For compatibility
                                 .equ	PORTD6	= 6	; Port D Data Register bit 6
                                 .equ	PD6	= 6	; For compatibility
                                 .equ	PORTD7	= 7	; Port D Data Register bit 7
                                 .equ	PD7	= 7	; For compatibility
                                 
                                 ; DDRD - Port D Data Direction Register
                                 .equ	DDD0	= 0	; Port D Data Direction Register bit 0
                                 .equ	DDD1	= 1	; Port D Data Direction Register bit 1
                                 .equ	DDD2	= 2	; Port D Data Direction Register bit 2
                                 .equ	DDD3	= 3	; Port D Data Direction Register bit 3
                                 .equ	DDD4	= 4	; Port D Data Direction Register bit 4
                                 .equ	DDD5	= 5	; Port D Data Direction Register bit 5
                                 .equ	DDD6	= 6	; Port D Data Direction Register bit 6
                                 .equ	DDD7	= 7	; Port D Data Direction Register bit 7
                                 
                                 ; PIND - Port D Input Pins
                                 .equ	PIND0	= 0	; Port D Input Pins bit 0
                                 .equ	PIND1	= 1	; Port D Input Pins bit 1
                                 .equ	PIND2	= 2	; Port D Input Pins bit 2
                                 .equ	PIND3	= 3	; Port D Input Pins bit 3
                                 .equ	PIND4	= 4	; Port D Input Pins bit 4
                                 .equ	PIND5	= 5	; Port D Input Pins bit 5
                                 .equ	PIND6	= 6	; Port D Input Pins bit 6
                                 .equ	PIND7	= 7	; Port D Input Pins bit 7
                                 
                                 
                                 ; ***** PORTE ************************
                                 ; PORTE - Data Register, Port E
                                 .equ	PORTE0	= 0	; 
                                 .equ	PE0	= 0	; For compatibility
                                 .equ	PORTE1	= 1	; 
                                 .equ	PE1	= 1	; For compatibility
                                 .equ	PORTE2	= 2	; 
                                 .equ	PE2	= 2	; For compatibility
                                 .equ	PORTE3	= 3	; 
                                 .equ	PE3	= 3	; For compatibility
                                 .equ	PORTE4	= 4	; 
                                 .equ	PE4	= 4	; For compatibility
                                 .equ	PORTE5	= 5	; 
                                 .equ	PE5	= 5	; For compatibility
                                 .equ	PORTE6	= 6	; 
                                 .equ	PE6	= 6	; For compatibility
                                 .equ	PORTE7	= 7	; 
                                 .equ	PE7	= 7	; For compatibility
                                 
                                 ; DDRE - Data Direction Register, Port E
                                 .equ	DDE0	= 0	; 
                                 .equ	DDE1	= 1	; 
                                 .equ	DDE2	= 2	; 
                                 .equ	DDE3	= 3	; 
                                 .equ	DDE4	= 4	; 
                                 .equ	DDE5	= 5	; 
                                 .equ	DDE6	= 6	; 
                                 .equ	DDE7	= 7	; 
                                 
                                 ; PINE - Input Pins, Port E
                                 .equ	PINE0	= 0	; 
                                 .equ	PINE1	= 1	; 
                                 .equ	PINE2	= 2	; 
                                 .equ	PINE3	= 3	; 
                                 .equ	PINE4	= 4	; 
                                 .equ	PINE5	= 5	; 
                                 .equ	PINE6	= 6	; 
                                 .equ	PINE7	= 7	; 
                                 
                                 
                                 ; ***** PORTF ************************
                                 ; PORTF - Data Register, Port F
                                 .equ	PORTF0	= 0	; 
                                 .equ	PF0	= 0	; For compatibility
                                 .equ	PORTF1	= 1	; 
                                 .equ	PF1	= 1	; For compatibility
                                 .equ	PORTF2	= 2	; 
                                 .equ	PF2	= 2	; For compatibility
                                 .equ	PORTF3	= 3	; 
                                 .equ	PF3	= 3	; For compatibility
                                 .equ	PORTF4	= 4	; 
                                 .equ	PF4	= 4	; For compatibility
                                 .equ	PORTF5	= 5	; 
                                 .equ	PF5	= 5	; For compatibility
                                 .equ	PORTF6	= 6	; 
                                 .equ	PF6	= 6	; For compatibility
                                 .equ	PORTF7	= 7	; 
                                 .equ	PF7	= 7	; For compatibility
                                 
                                 ; DDRF - Data Direction Register, Port F
                                 .equ	DDF0	= 0	; 
                                 .equ	DDF1	= 1	; 
                                 .equ	DDF2	= 2	; 
                                 .equ	DDF3	= 3	; 
                                 .equ	DDF4	= 4	; 
                                 .equ	DDF5	= 5	; 
                                 .equ	DDF6	= 6	; 
                                 .equ	DDF7	= 7	; 
                                 
                                 ; PINF - Input Pins, Port F
                                 .equ	PINF0	= 0	; 
                                 .equ	PINF1	= 1	; 
                                 .equ	PINF2	= 2	; 
                                 .equ	PINF3	= 3	; 
                                 .equ	PINF4	= 4	; 
                                 .equ	PINF5	= 5	; 
                                 .equ	PINF6	= 6	; 
                                 .equ	PINF7	= 7	; 
                                 
                                 
                                 ; ***** PORTG ************************
                                 ; PORTG - Data Register, Port G
                                 .equ	PORTG0	= 0	; 
                                 .equ	PG0	= 0	; For compatibility
                                 .equ	PORTG1	= 1	; 
                                 .equ	PG1	= 1	; For compatibility
                                 .equ	PORTG2	= 2	; 
                                 .equ	PG2	= 2	; For compatibility
                                 .equ	PORTG3	= 3	; 
                                 .equ	PG3	= 3	; For compatibility
                                 .equ	PORTG4	= 4	; 
                                 .equ	PG4	= 4	; For compatibility
                                 
                                 ; DDRG - Data Direction Register, Port G
                                 .equ	DDG0	= 0	; 
                                 .equ	DDG1	= 1	; 
                                 .equ	DDG2	= 2	; 
                                 .equ	DDG3	= 3	; 
                                 .equ	DDG4	= 4	; 
                                 
                                 ; PING - Input Pins, Port G
                                 .equ	PING0	= 0	; 
                                 .equ	PING1	= 1	; 
                                 .equ	PING2	= 2	; 
                                 .equ	PING3	= 3	; 
                                 .equ	PING4	= 4	; 
                                 
                                 
                                 ; ***** TIMER_COUNTER_0 **************
                                 ; TCCR0 - Timer/Counter Control Register
                                 .equ	CS00	= 0	; Clock Select 0
                                 .equ	CS01	= 1	; Clock Select 1
                                 .equ	CS02	= 2	; Clock Select 2
                                 .equ	WGM01	= 3	; Waveform Generation Mode 1
                                 .equ	CTC0	= WGM01	; For compatibility
                                 .equ	COM00	= 4	; Compare match Output Mode 0
                                 .equ	COM01	= 5	; Compare Match Output Mode 1
                                 .equ	WGM00	= 6	; Waveform Generation Mode 0
                                 .equ	PWM0	= WGM00	; For compatibility
                                 .equ	FOC0	= 7	; Force Output Compare
                                 
                                 ; TCNT0 - Timer/Counter Register
                                 .equ	TCNT0_0	= 0	; 
                                 .equ	TCNT0_1	= 1	; 
                                 .equ	TCNT0_2	= 2	; 
                                 .equ	TCNT0_3	= 3	; 
                                 .equ	TCNT0_4	= 4	; 
                                 .equ	TCNT0_5	= 5	; 
                                 .equ	TCNT0_6	= 6	; 
                                 .equ	TCNT0_7	= 7	; 
                                 
                                 ; OCR0 - Output Compare Register
                                 .equ	OCR0_0	= 0	; 
                                 .equ	OCR0_1	= 1	; 
                                 .equ	OCR0_2	= 2	; 
                                 .equ	OCR0_3	= 3	; 
                                 .equ	OCR0_4	= 4	; 
                                 .equ	OCR0_5	= 5	; 
                                 .equ	OCR0_6	= 6	; 
                                 .equ	OCR0_7	= 7	; 
                                 
                                 ; ASSR - Asynchronus Status Register
                                 .equ	TCR0UB	= 0	; Timer/Counter Control Register 0 Update Busy
                                 .equ	OCR0UB	= 1	; Output Compare register 0 Busy
                                 .equ	TCN0UB	= 2	; Timer/Counter0 Update Busy
                                 .equ	AS0	= 3	; Asynchronus Timer/Counter 0
                                 
                                 ; TIMSK - Timer/Counter Interrupt Mask Register
                                 .equ	TOIE0	= 0	; Timer/Counter0 Overflow Interrupt Enable
                                 .equ	OCIE0	= 1	; Timer/Counter0 Output Compare Match Interrupt register
                                 
                                 ; TIFR - Timer/Counter Interrupt Flag register
                                 .equ	TOV0	= 0	; Timer/Counter0 Overflow Flag
                                 .equ	OCF0	= 1	; Output Compare Flag 0
                                 
                                 ; SFIOR - Special Function IO Register
                                 ;.equ	PSR0	= 1	; Prescaler Reset Timer/Counter0
                                 ;.equ	TSM	= 7	; Timer/Counter Synchronization Mode
                                 
                                 
                                 ; ***** TIMER_COUNTER_1 **************
                                 ; TIMSK - Timer/Counter Interrupt Mask Register
                                 .equ	TOIE1	= 2	; Timer/Counter1 Overflow Interrupt Enable
                                 .equ	OCIE1B	= 3	; Timer/Counter1 Output CompareB Match Interrupt Enable
                                 .equ	OCIE1A	= 4	; Timer/Counter1 Output CompareA Match Interrupt Enable
                                 .equ	TICIE1	= 5	; Timer/Counter1 Input Capture Interrupt Enable
                                 
                                 ; ETIMSK - Extended Timer/Counter Interrupt Mask Register
                                 .equ	OCIE1C	= 0	; Timer/Counter 1, Output Compare Match C Interrupt Enable
                                 
                                 ; TIFR - Timer/Counter Interrupt Flag register
                                 .equ	TOV1	= 2	; Timer/Counter1 Overflow Flag
                                 .equ	OCF1B	= 3	; Output Compare Flag 1B
                                 .equ	OCF1A	= 4	; Output Compare Flag 1A
                                 .equ	ICF1	= 5	; Input Capture Flag 1
                                 
                                 ; ETIFR - Extended Timer/Counter Interrupt Flag register
                                 .equ	OCF1C	= 0	; Timer/Counter 1, Output Compare C Match Flag
                                 
                                 ; SFIOR - Special Function IO Register
                                 ;.equ	PSR321	= 0	; Prescaler Reset, T/C3, T/C2, T/C1
                                 ;.equ	TSM	= 7	; Timer/Counter Synchronization Mode
                                 
                                 ; TCCR1A - Timer/Counter1 Control Register A
                                 .equ	WGM10	= 0	; Waveform Generation Mode Bit 0
                                 .equ	PWM10	= WGM10	; For compatibility
                                 .equ	WGM11	= 1	; Waveform Generation Mode Bit 1
                                 .equ	PWM11	= WGM11	; For compatibility
                                 .equ	COM1C0	= 2	; Compare Output Mode 1C, bit 0
                                 .equ	COM1C1	= 3	; Compare Output Mode 1C, bit 1
                                 .equ	COM1B0	= 4	; Compare Output Mode 1B, bit 0
                                 .equ	COM1B1	= 5	; Compare Output Mode 1B, bit 1
                                 .equ	COM1A0	= 6	; Compare Ouput Mode 1A, bit 0
                                 .equ	COM1A1	= 7	; Compare Output Mode 1A, bit 1
                                 
                                 ; TCCR1B - Timer/Counter1 Control Register B
                                 .equ	CS10	= 0	; Clock Select bit 0
                                 .equ	CS11	= 1	; Clock Select 1 bit 1
                                 .equ	CS12	= 2	; Clock Select1 bit 2
                                 .equ	WGM12	= 3	; Waveform Generation Mode
                                 .equ	CTC10	= WGM12	; For compatibility
                                 .equ	WGM13	= 4	; Waveform Generation Mode
                                 .equ	CTC11	= WGM13	; For compatibility
                                 .equ	ICES1	= 6	; Input Capture 1 Edge Select
                                 .equ	ICNC1	= 7	; Input Capture 1 Noise Canceler
                                 
                                 ; TCCR1C - Timer/Counter1 Control Register C
                                 .equ	FOC1C	= 5	; Force Output Compare for channel C
                                 .equ	FOC1B	= 6	; Force Output Compare for channel B
                                 .equ	FOC1A	= 7	; Force Output Compare for channel A
                                 
                                 
                                 ; ***** TIMER_COUNTER_2 **************
                                 ; TCCR2 - Timer/Counter Control Register
                                 .equ	CS20	= 0	; Clock Select
                                 .equ	CS21	= 1	; Clock Select
                                 .equ	CS22	= 2	; Clock Select
                                 .equ	WGM21	= 3	; Waveform Generation Mode
                                 .equ	CTC2	= WGM21	; For compatibility
                                 .equ	COM20	= 4	; Compare Match Output Mode
                                 .equ	COM21	= 5	; Compare Match Output Mode
                                 .equ	WGM20	= 6	; Wafeform Generation Mode
                                 .equ	PWM2	= WGM20	; For compatibility
                                 .equ	FOC2	= 7	; Force Output Compare
                                 
                                 ; TCNT2 - Timer/Counter Register
                                 .equ	TCNT2_0	= 0	; Timer/Counter Register Bit 0
                                 .equ	TCNT2_1	= 1	; Timer/Counter Register Bit 1
                                 .equ	TCNT2_2	= 2	; Timer/Counter Register Bit 2
                                 .equ	TCNT2_3	= 3	; Timer/Counter Register Bit 3
                                 .equ	TCNT2_4	= 4	; Timer/Counter Register Bit 4
                                 .equ	TCNT2_5	= 5	; Timer/Counter Register Bit 5
                                 .equ	TCNT2_6	= 6	; Timer/Counter Register Bit 6
                                 .equ	TCNT2_7	= 7	; Timer/Counter Register Bit 7
                                 
                                 ; OCR2 - Output Compare Register
                                 .equ	OCR2_0	= 0	; Output Compare Register Bit 0
                                 .equ	OCR2_1	= 1	; Output Compare Register Bit 1
                                 .equ	OCR2_2	= 2	; Output Compare Register Bit 2
                                 .equ	OCR2_3	= 3	; Output Compare Register Bit 3
                                 .equ	OCR2_4	= 4	; Output Compare Register Bit 4
                                 .equ	OCR2_5	= 5	; Output Compare Register Bit 5
                                 .equ	OCR2_6	= 6	; Output Compare Register Bit 6
                                 .equ	OCR2_7	= 7	; Output Compare Register Bit 7
                                 
                                 ; TIMSK - 
                                 .equ	TOIE2	= 6	; 
                                 .equ	OCIE2	= 7	; 
                                 
                                 ; TIFR - Timer/Counter Interrupt Flag Register
                                 .equ	TOV2	= 6	; Timer/Counter2 Overflow Flag
                                 .equ	OCF2	= 7	; Output Compare Flag 2
                                 
                                 
                                 ; ***** TIMER_COUNTER_3 **************
                                 ; ETIMSK - Extended Timer/Counter Interrupt Mask Register
                                 .equ	OCIE3C	= 1	; Timer/Counter3, Output Compare Match Interrupt Enable
                                 .equ	TOIE3	= 2	; Timer/Counter3 Overflow Interrupt Enable
                                 .equ	OCIE3B	= 3	; Timer/Counter3 Output CompareB Match Interrupt Enable
                                 .equ	OCIE3A	= 4	; Timer/Counter3 Output CompareA Match Interrupt Enable
                                 .equ	TICIE3	= 5	; Timer/Counter3 Input Capture Interrupt Enable
                                 
                                 ; ETIFR - Extended Timer/Counter Interrupt Flag register
                                 .equ	OCF3C	= 1	; Timer/Counter3 Output Compare C Match Flag
                                 .equ	TOV3	= 2	; Timer/Counter3 Overflow Flag
                                 .equ	OCF3B	= 3	; Output Compare Flag 1B
                                 .equ	OCF3A	= 4	; Output Compare Flag 1A
                                 .equ	ICF3	= 5	; Input Capture Flag 1
                                 
                                 ; SFIOR - Special Function IO Register
                                 ;.equ	PSR321	= 0	; Prescaler Reset, T/C3, T/C2, T/C1
                                 ;.equ	PSR1	= PSR321	; For compatibility
                                 ;.equ	PSR2	= PSR321	; For compatibility
                                 ;.equ	TSM	= 7	; Timer/Counter Synchronization Mode
                                 
                                 ; TCCR3A - Timer/Counter3 Control Register A
                                 .equ	WGM30	= 0	; Waveform Generation Mode Bit 0
                                 .equ	PWM30	= WGM30	; For compatibility
                                 .equ	WGM31	= 1	; Waveform Generation Mode Bit 1
                                 .equ	PWM31	= WGM31	; For compatibility
                                 .equ	COM3C0	= 2	; Compare Output Mode 3C, bit 0
                                 .equ	COM3C1	= 3	; Compare Output Mode 3C, bit 1
                                 .equ	COM3B0	= 4	; Compare Output Mode 3B, bit 0
                                 .equ	COM3B1	= 5	; Compare Output Mode 3B, bit 1
                                 .equ	COM3A0	= 6	; Comparet Ouput Mode 3A, bit 0
                                 .equ	COM3A1	= 7	; Compare Output Mode 3A, bit 1
                                 
                                 ; TCCR3B - Timer/Counter3 Control Register B
                                 .equ	CS30	= 0	; Clock Select 3 bit 0
                                 .equ	CS31	= 1	; Clock Select 3 bit 1
                                 .equ	CS32	= 2	; Clock Select3 bit 2
                                 .equ	WGM32	= 3	; Waveform Generation Mode
                                 .equ	CTC30	= WGM32	; For compatibility
                                 .equ	WGM33	= 4	; Waveform Generation Mode
                                 .equ	CTC31	= WGM33	; For compatibility
                                 .equ	ICES3	= 6	; Input Capture 3 Edge Select
                                 .equ	ICNC3	= 7	; Input Capture 3  Noise Canceler
                                 
                                 ; TCCR3C - Timer/Counter3 Control Register C
                                 .equ	FOC3C	= 5	; Force Output Compare for channel C
                                 .equ	FOC3B	= 6	; Force Output Compare for channel B
                                 .equ	FOC3A	= 7	; Force Output Compare for channel A
                                 
                                 ; TCNT3L - Timer/Counter3 Low Byte
                                 .equ	TCN3L0	= 0	; Timer/Counter 3 bit 0
                                 .equ	TCN3L1	= 1	; Timer/Counter 3 bit 1
                                 .equ	TCN3L2	= 2	; Timer/Counter 3 bit 2
                                 .equ	TCN3L3	= 3	; Timer/Counter 3 bit 3
                                 .equ	TCN3L4	= 4	; Timer/Counter 3 bit 4
                                 .equ	TCN3L5	= 5	; Timer/Counter 3 bit 5
                                 .equ	TCN3L6	= 6	; Timer/Counter 3 bit 6
                                 .equ	TCN3L7	= 7	; Timer/Counter 3 bit 7
                                 
                                 
                                 ; ***** WATCHDOG *********************
                                 ; WDTCR - Watchdog Timer Control Register
                                 .equ	WDTCSR	= WDTCR	; For compatibility
                                 .equ	WDP0	= 0	; Watch Dog Timer Prescaler bit 0
                                 .equ	WDP1	= 1	; Watch Dog Timer Prescaler bit 1
                                 .equ	WDP2	= 2	; Watch Dog Timer Prescaler bit 2
                                 .equ	WDE	= 3	; Watch Dog Enable
                                 .equ	WDCE	= 4	; Watchdog Change Enable
                                 .equ	WDTOE	= WDCE	; For compatibility
                                 
                                 
                                 ; ***** AD_CONVERTER *****************
                                 ; ADMUX - The ADC multiplexer Selection Register
                                 .equ	MUX0	= 0	; Analog Channel and Gain Selection Bits
                                 .equ	MUX1	= 1	; Analog Channel and Gain Selection Bits
                                 .equ	MUX2	= 2	; Analog Channel and Gain Selection Bits
                                 .equ	MUX3	= 3	; Analog Channel and Gain Selection Bits
                                 .equ	MUX4	= 4	; Analog Channel and Gain Selection Bits
                                 .equ	ADLAR	= 5	; Left Adjust Result
                                 .equ	REFS0	= 6	; Reference Selection Bit 0
                                 .equ	REFS1	= 7	; Reference Selection Bit 1
                                 
                                 ; ADCSRA - The ADC Control and Status register
                                 .equ	ADCSR	= ADCSRA	; For compatibility
                                 .equ	ADPS0	= 0	; ADC  Prescaler Select Bits
                                 .equ	ADPS1	= 1	; ADC  Prescaler Select Bits
                                 .equ	ADPS2	= 2	; ADC  Prescaler Select Bits
                                 .equ	ADIE	= 3	; ADC Interrupt Enable
                                 .equ	ADIF	= 4	; ADC Interrupt Flag
                                 .equ	ADFR	= 5	; ADC  Free Running Select
                                 .equ	ADSC	= 6	; ADC Start Conversion
                                 .equ	ADEN	= 7	; ADC Enable
                                 
                                 ; ADCH - ADC Data Register High Byte
                                 .equ	ADCH0	= 0	; ADC Data Register High Byte Bit 0
                                 .equ	ADCH1	= 1	; ADC Data Register High Byte Bit 1
                                 .equ	ADCH2	= 2	; ADC Data Register High Byte Bit 2
                                 .equ	ADCH3	= 3	; ADC Data Register High Byte Bit 3
                                 .equ	ADCH4	= 4	; ADC Data Register High Byte Bit 4
                                 .equ	ADCH5	= 5	; ADC Data Register High Byte Bit 5
                                 .equ	ADCH6	= 6	; ADC Data Register High Byte Bit 6
                                 .equ	ADCH7	= 7	; ADC Data Register High Byte Bit 7
                                 
                                 ; ADCL - ADC Data Register Low Byte
                                 .equ	ADCL0	= 0	; ADC Data Register Low Byte Bit 0
                                 .equ	ADCL1	= 1	; ADC Data Register Low Byte Bit 1
                                 .equ	ADCL2	= 2	; ADC Data Register Low Byte Bit 2
                                 .equ	ADCL3	= 3	; ADC Data Register Low Byte Bit 3
                                 .equ	ADCL4	= 4	; ADC Data Register Low Byte Bit 4
                                 .equ	ADCL5	= 5	; ADC Data Register Low Byte Bit 5
                                 .equ	ADCL6	= 6	; ADC Data Register Low Byte Bit 6
                                 .equ	ADCL7	= 7	; ADC Data Register Low Byte Bit 7
                                 
                                 
                                 
                                 ; ***** LOCKSBITS ********************************************************
                                 .equ	LB1	= 0	; Lock bit
                                 .equ	LB2	= 1	; Lock bit
                                 .equ	BLB01	= 2	; Boot Lock bit
                                 .equ	BLB02	= 3	; Boot Lock bit
                                 .equ	BLB11	= 4	; Boot lock bit
                                 .equ	BLB12	= 5	; Boot lock bit
                                 
                                 
                                 ; ***** FUSES ************************************************************
                                 ; LOW fuse bits
                                 .equ	CKSEL0	= 0	; Select Clock Source
                                 .equ	CKSEL1	= 1	; Select Clock Source
                                 .equ	CKSEL2	= 2	; Select Clock Source
                                 .equ	CKSEL3	= 3	; Select Clock Source
                                 .equ	SUT0	= 4	; Select start-up time
                                 .equ	SUT1	= 5	; Select start-up time
                                 .equ	BODEN	= 6	; Brown out detector enable
                                 .equ	BODLEVEL	= 7	; Brown out detector trigger level
                                 
                                 ; HIGH fuse bits
                                 .equ	BOOTRST	= 0	; Select Reset Vector
                                 .equ	BOOTSZ0	= 1	; Select Boot Size
                                 .equ	BOOTSZ1	= 2	; Select Boot Size
                                 .equ	EESAVE	= 3	; EEPROM memory is preserved through chip erase
                                 .equ	CKOPT	= 4	; Oscillator Options
                                 .equ	SPIEN	= 5	; Enable Serial programming and Data Downloading
                                 .equ	JTAGEN	= 6	; Enable JTAG
                                 .equ	OCDEN	= 7	; Enable OCD
                                 
                                 ; EXTENDED fuse bits
                                 .equ	WDTON	= 0	; Watchdog timer always on
                                 .equ	M103C	= 1	; ATmega103 compatibility mode
                                 
                                 
                                 
                                 ; ***** CPU REGISTER DEFINITIONS *****************************************
                                 .def	XH	= r27
                                 .def	XL	= r26
                                 .def	YH	= r29
                                 .def	YL	= r28
                                 .def	ZH	= r31
                                 .def	ZL	= r30
                                 
                                 
                                 
                                 ; ***** DATA MEMORY DECLARATIONS *****************************************
                                 .equ	FLASHEND	= 0xffff	; Note: Word address
                                 .equ	IOEND	= 0x00ff
                                 .equ	SRAM_START	= 0x0100
                                 .equ	SRAM_SIZE	= 4096
                                 .equ	RAMEND	= 0x10ff
                                 .equ	XRAMEND	= 0xffff
                                 .equ	E2END	= 0x0fff
                                 .equ	EEPROMEND	= 0x0fff
                                 .equ	EEADRBITS	= 12
                                 #pragma AVRPART MEMORY PROG_FLASH 131072
                                 #pragma AVRPART MEMORY EEPROM 4096
                                 #pragma AVRPART MEMORY INT_SRAM SIZE 4096
                                 #pragma AVRPART MEMORY INT_SRAM START_ADDR 0x100
                                 
                                 
                                 
                                 ; ***** BOOTLOADER DECLARATIONS ******************************************
                                 .equ	NRWW_START_ADDR	= 0xf000
                                 .equ	NRWW_STOP_ADDR	= 0xffff
                                 .equ	RWW_START_ADDR	= 0x0
                                 .equ	RWW_STOP_ADDR	= 0xefff
                                 .equ	PAGESIZE	= 128
                                 .equ	FIRSTBOOTSTART	= 0xfe00
                                 .equ	SECONDBOOTSTART	= 0xfc00
                                 .equ	THIRDBOOTSTART	= 0xf800
                                 .equ	FOURTHBOOTSTART	= 0xf000
                                 .equ	SMALLBOOTSTART	= FIRSTBOOTSTART
                                 .equ	LARGEBOOTSTART	= FOURTHBOOTSTART
                                 
                                 
                                 
                                 ; ***** INTERRUPT VECTORS ************************************************
                                 .equ	INT0addr	= 0x0002	; External Interrupt Request 0
                                 .equ	INT1addr	= 0x0004	; External Interrupt Request 1
                                 .equ	INT2addr	= 0x0006	; External Interrupt Request 2
                                 .equ	INT3addr	= 0x0008	; External Interrupt Request 3
                                 .equ	INT4addr	= 0x000a	; External Interrupt Request 4
                                 .equ	INT5addr	= 0x000c	; External Interrupt Request 5
                                 .equ	INT6addr	= 0x000e	; External Interrupt Request 6
                                 .equ	INT7addr	= 0x0010	; External Interrupt Request 7
                                 .equ	OC2addr	= 0x0012	; Timer/Counter2 Compare Match
                                 .equ	OVF2addr	= 0x0014	; Timer/Counter2 Overflow
                                 .equ	ICP1addr	= 0x0016	; Timer/Counter1 Capture Event
                                 .equ	OC1Aaddr	= 0x0018	; Timer/Counter1 Compare Match A
                                 .equ	OC1Baddr	= 0x001a	; Timer/Counter Compare Match B
                                 .equ	OVF1addr	= 0x001c	; Timer/Counter1 Overflow
                                 .equ	OC0addr	= 0x001e	; Timer/Counter0 Compare Match
                                 .equ	OVF0addr	= 0x0020	; Timer/Counter0 Overflow
                                 .equ	SPIaddr	= 0x0022	; SPI Serial Transfer Complete
                                 .equ	URXC0addr	= 0x0024	; USART0, Rx Complete
                                 .equ	UDRE0addr	= 0x0026	; USART0 Data Register Empty
                                 .equ	UTXC0addr	= 0x0028	; USART0, Tx Complete
                                 .equ	ADCCaddr	= 0x002a	; ADC Conversion Complete
                                 .equ	ERDYaddr	= 0x002c	; EEPROM Ready
                                 .equ	ACIaddr	= 0x002e	; Analog Comparator
                                 .equ	OC1Caddr	= 0x0030	; Timer/Counter1 Compare Match C
                                 .equ	ICP3addr	= 0x0032	; Timer/Counter3 Capture Event
                                 .equ	OC3Aaddr	= 0x0034	; Timer/Counter3 Compare Match A
                                 .equ	OC3Baddr	= 0x0036	; Timer/Counter3 Compare Match B
                                 .equ	OC3Caddr	= 0x0038	; Timer/Counter3 Compare Match C
                                 .equ	OVF3addr	= 0x003a	; Timer/Counter3 Overflow
                                 .equ	URXC1addr	= 0x003c	; USART1, Rx Complete
                                 .equ	UDRE1addr	= 0x003e	; USART1, Data Register Empty
                                 .equ	UTXC1addr	= 0x0040	; USART1, Tx Complete
                                 .equ	TWIaddr	= 0x0042	; 2-wire Serial Interface
                                 .equ	SPMRaddr	= 0x0044	; Store Program Memory Read
                                 
                                 .equ	INT_VECTORS_SIZE	= 70	; size in words
                                 
                                 #endif  /* _M128DEF_INC_ */
                                 
                                 ; ***** END OF FILE ******************************************************
                                 
                                  * main.asm
                                  *
                                  *  Created: 30/04/2024 10:55:24
                                  *   Author: renuka
                                  */ 
                                 
                                 .include "m128def.inc"
                                 
                                 ;***** Created: 2011-02-09 12:03 ******* Source: ATmega128.xml ***********
                                 ;*************************************************************************
                                 ;* A P P L I C A T I O N   N O T E   F O R   T H E   A V R   F A M I L Y
                                 ;* 
                                 ;* Number            : AVR000
                                 ;* File Name         : "m128def.inc"
                                 ;* Title             : Register/Bit Definitions for the ATmega128
                                 ;* Date              : 2011-02-09
                                 ;* Version           : 2.35
                                 ;* Support E-mail    : avr@atmel.com
                                 ;* Target MCU        : ATmega128
                                 ;* 
                                 ;* DESCRIPTION
                                 ;* When including this file in the assembly program file, all I/O register 
                                 ;* names and I/O register bit names appearing in the data book can be used.
                                 ;* In addition, the six registers forming the three data pointers X, Y and 
                                 ;* Z have been assigned names XL - ZH. Highest RAM address for Internal 
                                 ;* SRAM is also defined 
                                 ;* 
                                 ;* The Register names are represented by their hexadecimal address.
                                 ;* 
                                 ;* The Register Bit names are represented by their bit number (0-7).
                                 ;* 
                                 ;* Please observe the difference in using the bit names with instructions
                                 ;* such as "sbr"/"cbr" (set/clear bit in register) and "sbrs"/"sbrc"
                                 ;* (skip if bit in register set/cleared). The following example illustrates
                                 ;* this:
                                 ;* 
                                 ;* in    r16,PORTB             ;read PORTB latch
                                 ;* sbr   r16,(1<<PB6)+(1<<PB5) ;set PB6 and PB5 (use masks, not bit#)
                                 ;* out   PORTB,r16             ;output to PORTB
                                 ;* 
                                 ;* in    r16,TIFR              ;read the Timer Interrupt Flag Register
                                 ;* sbrc  r16,TOV0              ;test the overflow flag (use bit#)
                                 ;* rjmp  TOV0_is_set           ;jump if set
                                 ;* ...                         ;otherwise do something else
                                 ;*************************************************************************
                                 
                                 #ifndef _M128DEF_INC_
                                 #endif  /* _M128DEF_INC_ */
                                 
                                 ; ***** END OF FILE ******************************************************
                                 .include "definitions.asm"	
                                 
                                 ; purpose library, definition of addresses and constants
                                 ; 20171114 A.S.
                                 
                                 ; === definitions  ===
                                 .list
                                 .include "macros.asm"
                                 
                                 ; purpose library, general-purpose macros
                                 ; author (c) R.Holzer (adapted MICRO210/EE208 A.Schmid)
                                 
                                 ; ==============
                                 ; 	pointers
                                 ; ==============
                                 
                                 ; --- loading an immediate into a pointer XYZ,SP ---
                                 .macro 	LDIX	; sram
                                 	ldi	xl, low(@0)
                                 	ldi	xh,high(@0)
                                 	.endmacro	
                                 .macro 	LDIY	; sram	
                                 	ldi	yl, low(@0)
                                 	ldi	yh,high(@0)
                                 	.endmacro	
                                 .macro 	LDIZ	; sram
                                 	ldi	zl, low(@0)
                                 	ldi	zh,high(@0)
                                 	
                                 	.endmacro
                                 .macro	LDZD	; sram, reg	; sram+reg -> Z
                                 	mov	zl,@1
                                 	clr	zh
                                 	subi	zl, low(-@0)
                                 	sbci	zh,high(-@0)
                                 	.endmacro
                                 .macro	LDSP	; sram
                                 	ldi	r16, low(@0)
                                 	out	spl,r16
                                 	ldi	r16,high(@0)
                                 	out	sph,r16
                                 	.endmacro
                                 
                                 ; --- load/store SRAM addr into pointer XYZ ---	
                                 .macro 	LDSX	; sram
                                 	lds	xl,@0
                                 	lds	xh,@0+1
                                 	.endmacro
                                 .macro 	LDSY	; sram
                                 	lds	yl,@0
                                 	lds	yh,@0+1
                                 	.endmacro
                                 .macro 	LDSZ	; sram
                                 	lds	zl,@0
                                 	lds	zh,@0+1
                                 	.endmacro
                                 .macro 	STSX	; sram
                                 	sts	@0,  xl
                                 	sts	@0+1,xh
                                 	.endmacro	
                                 .macro 	STSY	; sram
                                 	sts	@0,  yl
                                 	sts	@0+1,yh
                                 	.endmacro
                                 .macro 	STSZ	; sram
                                 	sts	@0,  zl
                                 	sts	@0+1,zh
                                 	.endmacro	
                                 
                                 ; --- push/pop pointer XYZ ---
                                 .macro	PUSHX			; push X
                                 	push	xl
                                 	push	xh
                                 	.endmacro
                                 .macro	POPX			; pop X
                                 	pop	xh
                                 	pop	xl
                                 	.endmacro
                                 	
                                 .macro	PUSHY			; push Y
                                 	push	yl
                                 	push	yh
                                 	.endmacro
                                 .macro	POPY			; pop Y
                                 	pop	yh
                                 	pop	yl
                                 	.endmacro
                                 
                                 .macro	PUSHZ			; push Z
                                 	push	zl
                                 	push	zh
                                 	.endmacro
                                 .macro	POPZ			; pop Z
                                 	pop	zh
                                 	pop	zl
                                 	.endmacro
                                 
                                 ; --- multiply/divide Z ---	
                                 .macro	MUL2Z			; multiply Z by 2
                                 	lsl	zl
                                 	rol	zh
                                 	.endmacro
                                 .macro	DIV2Z			; divide Z by 2
                                 	lsr	zh
                                 	ror	zl
                                 	.endmacro
                                 
                                 ; --- add register to pointer XYZ ---	
                                 .macro	ADDX	;reg		; x <- y+reg
                                 	add	xl,@0
                                 	brcc	PC+2
                                 	subi	xh,-1		; add carry
                                 	.endmacro
                                 .macro	ADDY	;reg		; y <- y+reg
                                 	add	yl,@0
                                 	brcc	PC+2
                                 	subi	yh,-1		; add carry
                                 	.endmacro
                                 .macro	ADDZ	;reg		; z <- z+reg
                                 	add	zl,@0
                                 	brcc	PC+2
                                 	subi	zh,-1		; add carry
                                 	.endmacro
                                 
                                 ; ===================
                                 ; 	miscellaneous
                                 ; ===================
                                 
                                 ; --- output/store (regular I/O space) immediate value ---
                                 .macro	OUTI	; port,k	output immediate value to port
                                 	ldi	w,@1
                                 	out	@0,w
                                 	.endmacro
                                 
                                 ; --- output/store (extended I/O space) immediate value ---
                                 .macro OUTEI	; port,k    output immediate value to port
                                 	ldi	w,@1
                                 	sts	@0,w
                                 	.endmacro
                                 
                                 ; --- add immediate value ---
                                 .macro	ADDI
                                 	subi	@0,-@1
                                 	.endmacro
                                 .macro	ADCI
                                 	sbci	@0,-@1
                                 	.endmacro
                                 
                                 ; --- inc/dec with range limitation ---
                                 .macro	INC_LIM	; reg,limit
                                 	cpi	@0,@1
                                 	brlo	PC+3
                                 	ldi	@0,@1	
                                 	rjmp	PC+2
                                 	inc	@0
                                 	.endmacro
                                 
                                 .macro	DEC_LIM	; reg,limit
                                 	cpi	@0,@1
                                 	breq	PC+5
                                 	brlo	PC+3
                                 	dec	@0
                                 	rjmp	PC+2
                                 	ldi	@0,@1
                                 	.endmacro
                                 
                                 ; --- inc/dec with cyclic range ---
                                 .macro	INC_CYC	; reg,low,high
                                 	cpi	@0,@2
                                 	brsh	_low	; reg>=high then reg=low
                                 	cpi	@0,@1
                                 	brlo	_low	; reg< low  then reg=low
                                 	inc	@0
                                 	rjmp	_done
                                 _low:	ldi	@0,@1
                                 _done:	
                                     .endmacro
                                 	
                                 .macro	DEC_CYC	; reg,low,high
                                 	cpi	@0,@1
                                 	breq	_high	; reg=low then reg=high
                                 	brlo	_high	; reg<low then reg=high
                                 	dec	@0	
                                 	cpi	@0,@2
                                 	brsh	_high	; reg>=high then high
                                 	rjmp	_done
                                 _high:	ldi	@0,@2
                                 _done:	
                                 	.endmacro
                                 
                                 .macro	INCDEC	;port,b1,b2,reg,low,high
                                 	sbic	@0,@1
                                 	rjmp	PC+6
                                 
                                 	cpi	@3,@5
                                 	brlo	PC+3
                                 	ldi	@3,@4	
                                 	rjmp	PC+2
                                 	inc	@3
                                 
                                 	sbic	@0,@2
                                 	rjmp	PC+7
                                 	
                                 	cpi	@3,@4
                                 	breq	PC+5
                                 	brlo	PC+3
                                 	dec	@3
                                 	rjmp	PC+2
                                 	ldi	@3,@5
                                 	.endmacro		
                                 
                                 ; --- wait loops ---
                                 ; wait 10...196608 cycles
                                 .macro	WAIT_C	; k
                                 	ldi	w,  low((@0-7)/3)
                                 	mov	u,w			; u=LSB
                                 	ldi	w,high((@0-7)/3)+1	; w=MSB
                                 	dec	u
                                 	brne	PC-1
                                 	dec	u
                                 	dec	w
                                 	brne	PC-4
                                 	.endmacro
                                 
                                 ; wait micro-seconds (us)
                                 ; us = x*3*1000'000/clock)	==> x=us*clock/3000'000
                                 .macro	WAIT_US ; k
                                 	ldi	w, low((clock/1000*@0/3000)-1)
                                 	mov	u,w
                                 	ldi	w,high((clock/1000*@0/3000)-1)+1 ; set up: 3 cyles
                                 	dec	u
                                 	brne	PC-1		; inner loop: 3 cycles
                                 	dec	u		; adjustment for outer loop
                                 	dec	w
                                 	brne	PC-4
                                 	.endmacro
                                 
                                 ; wait mili-seconds (ms)
                                 .macro	WAIT_MS ; k
                                 	ldi	w, low(@0)
                                 	mov	u,w		; u = LSB	
                                 	ldi	w,high(@0)+1	; w = MSB
                                 wait_ms:
                                 	push	w		; wait 1000 usec
                                 	push	u
                                 	ldi	w, low((clock/3000)-5)	
                                 	mov	u,w
                                 	ldi	w,high((clock/3000)-5)+1
                                 	dec	u
                                 	brne	PC-1		; inner loop: 3 cycles
                                 	dec	u		; adjustment for outer loop
                                 	dec	w
                                 	brne	PC-4
                                 	pop	u
                                 	pop	w
                                 	
                                 	dec	u
                                 	brne	wait_ms
                                 	dec	w
                                 	brne	wait_ms
                                 	.endmacro
                                 
                                 ; --- conditional jumps/calls ---
                                 .macro	JC0			; jump if carry=0
                                 	brcs	PC+2	
                                 	rjmp	@0
                                 	.endmacro
                                 .macro	JC1			; jump if carry=1
                                 	brcc	PC+2	
                                 	rjmp	@0
                                 	.endmacro
                                 
                                 .macro	JK	; reg,k,addr	; jump if reg=k
                                 	cpi	@0,@1
                                 	breq	@2
                                 	.endmacro
                                 .macro	_JK	; reg,k,addr	; jump if reg=k
                                 	cpi	@0,@1
                                 	brne	PC+2
                                 	rjmp	@2
                                 	.endmacro	
                                 .macro	JNK	; reg,k,addr	; jump if not(reg=k)
                                 	cpi	@0,@1
                                 	brne	@2
                                 	.endmacro 
                                 
                                 .macro	CK	; reg,k,addr	; call if reg=k
                                 	cpi	@0,@1
                                 	brne	PC+2
                                 	rcall	@2
                                 	.endmacro
                                 .macro	CNK	; reg,k,addr	; call if not(reg=k)
                                 	cpi	@0,@1
                                 	breq	PC+2
                                 	rcall	@2
                                 	.endmacro 
                                 
                                 .macro	JSK	; sram,k,addr	; jump if sram=k
                                 	lds	w,@0
                                 	cpi	w,@1
                                 	breq	@2
                                 	.endmacro 
                                 .macro	JSNK	; sram,k,addr	; jump if not(sram=k)
                                 	lds	w,@0
                                 	cpi	w,@1
                                 	brne	@2
                                 	.endmacro
                                 
                                 ; --- loops ---
                                 .macro	DJNZ	; reg,addr	; decr and jump if not zero
                                 	dec	@0
                                 	brne	@1
                                 	.endmacro
                                 .macro	DJNK	; reg,k,addr	; decr and jump if not k
                                 	dec	@0
                                 	cpi	@0,@1
                                 	brne	@2
                                 	.endmacro
                                 
                                 .macro	IJNZ	; reg,addr	; inc and jump if not zero
                                 	inc	@0
                                 	brne	@1
                                 	.endmacro
                                 .macro	IJNK	; reg,k,addr	; inc and jump if not k
                                 	inc	@0
                                 	cpi	@0,@1
                                 	brne	@2
                                 	.endmacro
                                 .macro	_IJNK	; reg,k,addr	; inc and jump if not k
                                 	inc	@0
                                 	ldi	w,@1
                                 	cp	@0,w
                                 	brne	@2
                                 	.endmacro
                                 
                                 .macro	ISJNK	; sram,k,addr	; inc sram and jump if not k
                                 	lds	w,@0
                                 	inc	w
                                 	sts	@0,w
                                 	cpi	w,@1
                                 	brne	@2
                                 	.endmacro
                                 .macro	_ISJNK	; sram,k,addr	; inc sram and jump if not k
                                 	lds	w,@0
                                 	inc	w
                                 	sts	@0,w
                                 	cpi	w,@1
                                 	breq	PC+2	
                                 	rjmp	@2
                                 	.endmacro
                                 
                                 .macro	DSJNK	; sram,k,addr	; dec sram and jump if not k
                                 	lds	w,@0
                                 	dec	w
                                 	sts	@0,w
                                 	cpi	w,@1
                                 	brne	@2
                                 	.endmacro
                                 
                                 ; --- table lookup ---
                                 .macro	LOOKUP	;reg, index,tbl
                                 	push	ZL
                                 	push	ZH
                                 	mov	zl,@1		; move index into z
                                 	clr	zh
                                 	subi	zl, low(-2*@2)	; add base address of table
                                 	sbci	zh,high(-2*@2)	
                                 	lpm			; load program memory (into r0)
                                 	mov	@0,r0
                                 	pop	ZH
                                 	pop	ZL
                                 	.endmacro
                                 
                                 .macro	LOOKUP2	;r1,r0, index,tbl
                                 	mov	zl,@2		; move index into z
                                 	clr	zh
                                 	lsl	zl		; multiply by 2
                                 	rol	zh
                                 	subi	zl, low(-2*@3)	; add base address of table
                                 	sbci	zh,high(-2*@3)
                                 	lpm			; get LSB byte
                                 	mov	w,r0		; temporary store LSB in w
                                 	adiw	zl,1		; increment Z
                                 	lpm			; get MSB byte
                                 	mov	@0,r0		; mov MSB to res1
                                 	mov	@1,w		; mov LSB to res0
                                 	.endmacro
                                 
                                 .macro	LOOKUP4	;r3,r2,r1,r0, index,tbl
                                 	mov	zl,@4		; move index into z
                                 	clr	zh
                                 	lsl	zl		; multiply by 2
                                 	rol	zh
                                 	lsl	zl		; multiply by 2
                                 	rol	zh	
                                 	subi	zl, low(-2*@5)	; add base address of table
                                 	sbci	zh,high(-2*@5)
                                 	lpm
                                 	mov	@1,r0		; load high word LSB
                                 	adiw	zl,1
                                 	lpm
                                 	mov	@0,r0		; load high word MSB
                                 	adiw	zl,1
                                 	lpm
                                 	mov	@3,r0		; load low word LSB		
                                 	adiw	zl,1
                                 	lpm
                                 	mov	@2,r0		; load low word MSB
                                 	.endmacro
                                 
                                 .macro	LOOKDOWN ;reg,index,tbl
                                 	ldi	ZL, low(2*@2)	; load table address
                                 	ldi	ZH,high(2*@2)
                                 	clr	@1
                                 loop:	lpm
                                 	cp	r0,@0
                                 	breq	found
                                 	inc	@1
                                 	adiw	ZL,1
                                 	tst	r0
                                 	breq	notfound
                                 	rjmp	loop
                                 notfound:
                                 	ldi	@1,-1
                                 found:	
                                 	.endmacro
                                 
                                 ; --- branch table ---
                                 .macro	C_TBL	; reg,tbl
                                 	ldi	ZL, low(2*@1)
                                 	ldi	ZH,high(2*@1)
                                 	lsl	@0
                                 	add	ZL,@0
                                 	brcc	PC+2
                                 	inc	ZH
                                 	lpm
                                 	push	r0
                                 	lpm
                                 	mov	zh,r0
                                 	pop	zl
                                 	icall
                                 	.endmacro
                                 .macro	J_TBL	; reg,tbl	
                                 	ldi	ZL, low(2*@1)
                                 	ldi	ZH,high(2*@1)
                                 	lsl	@0
                                 	add	ZL,@0
                                 	brcc	PC+2
                                 	inc	ZH
                                 	lpm
                                 	push	r0
                                 	lpm
                                 	mov	zh,r0
                                 	pop	zl	
                                 	ijmp
                                 	.endmacro
                                 
                                 .macro	BRANCH	; reg		; branching using the stack
                                 	ldi	w, low(tbl)
                                 	add	w,@0
                                 	push	w
                                 	ldi	w,high(tbl)
                                 	brcc	PC+2
                                 	inc	w
                                 	push	w
                                 	ret
                                 tbl:
                                 	.endmacro	
                                 
                                 ; --- multiply/division ---
                                 .macro	DIV2	; reg
                                 	lsr	@0
                                 	.endmacro
                                 .macro	DIV4	; reg
                                 	lsr	@0
                                 	lsr	@0
                                 	.endmacro	
                                 .macro	DIV8	; reg
                                 	lsr	@0
                                 	lsr	@0
                                 	lsr	@0
                                 	.endmacro
                                 	
                                 .macro	MUL2	; reg
                                 	lsl	@0
                                 	.endmacro
                                 .macro	MUL4	; reg
                                 	lsl	@0
                                 	lsl	@0
                                 	.endmacro
                                 .macro	MUL8	; reg
                                 	lsl	@0
                                 	lsl	@0
                                 	lsl	@0
                                 	.endmacro
                                 
                                 ; ====================================
                                 ; 	extending existing instructios
                                 ; ====================================
                                 
                                 ; --- immediate ops with r0..r15 ---
                                 .macro	_ADDI
                                 	ldi	w,@1
                                 	add	@0,w
                                 	.endmacro
                                 .macro	_ADCI
                                 	ldi	w,@1
                                 	adc	@0,w
                                 	.endmacro
                                 .macro	_SUBI
                                 	ldi	w,@1
                                 	sub	@0,w
                                 	.endmacro
                                 .macro	_SBCI
                                 	ldi	w,@1
                                 	sbc	@0,w
                                 	.endmacro
                                 .macro	_ANDI
                                 	ldi	w,@1
                                 	and	@0,w
                                 	.endmacro
                                 .macro	_ORI
                                 	ldi	w,@1
                                 	or	@0,w
                                 	.endmacro
                                 .macro	_EORI
                                 	ldi	w,@1
                                 	eor	@0,w
                                 	.endmacro
                                 .macro	_SBR
                                 	ldi	w,@1
                                 	or	@0,w
                                 	.endmacro
                                 .macro	_CBR
                                 	ldi	w,~@1
                                 	and	@0,w
                                 	.endmacro
                                 .macro	_CPI
                                 	ldi	w,@1
                                 	cp	@0,w
                                 	.endmacro
                                 .macro	_LDI
                                 	ldi	w,@1
                                 	mov	@0,w
                                 	.endmacro
                                 
                                 ; --- bit access for port p32..p63 ---
                                 .macro	_SBI
                                 	in	w,@0
                                 	ori	w,1<<@1
                                 	out	@0,w
                                 	.endmacro
                                 .macro	_CBI
                                 	in	w,@0
                                 	andi	w,~(1<<@1)
                                 	out	@0,w
                                 	.endmacro
                                 	
                                 ; --- extending branch distance to +/-2k ---
                                 .macro	_BREQ
                                 	brne	PC+2
                                 	rjmp	@0
                                 	.endmacro
                                 .macro	_BRNE
                                 	breq	PC+2
                                 	rjmp	@0
                                 	.endmacro
                                 .macro	_BRCS
                                 	brcc	PC+2
                                 	rjmp	@0
                                 	.endmacro
                                 .macro	_BRCC
                                 	brcs	PC+2
                                 	rjmp	@0
                                 	.endmacro
                                 .macro	_BRSH
                                 	brlo	PC+2
                                 	rjmp	@0
                                 	.endmacro
                                 .macro	_BRLO
                                 	brsh	PC+2
                                 	rjmp	@0
                                 	.endmacro
                                 .macro	_BRMI
                                 	brpl	PC+2
                                 	rjmp	@0
                                 	.endmacro
                                 .macro	_BRPL
                                 	brmi	PC+2
                                 	rjmp	@0
                                 	.endmacro
                                 .macro	_BRGE
                                 	brlt	PC+2
                                 	rjmp	@0
                                 	.endmacro
                                 .macro	_BRLT
                                 	brge	PC+2
                                 	rjmp	@0
                                 	.endmacro
                                 .macro	_BRHS
                                 	brhc	PC+2
                                 	rjmp	@0
                                 	.endmacro
                                 .macro	_BRHC
                                 	brhs	PC+2
                                 	rjmp	@0
                                 	.endmacro
                                 .macro	_BRTS
                                 	brtc	PC+2
                                 	rjmp	@0
                                 	.endmacro
                                 .macro	_BRTC
                                 	brts	PC+2
                                 	rjmp	@0
                                 	.endmacro
                                 .macro	_BRVS
                                 	brvc	PC+2
                                 	rjmp	@0
                                 	.endmacro
                                 .macro	_BRVC
                                 	brvs	PC+2
                                 	rjmp	@0
                                 	.endmacro
                                 .macro	_BRIE
                                 	brid	PC+2
                                 	rjmp	@0
                                 	.endmacro
                                 .macro	_BRID
                                 	brie	PC+2
                                 	rjmp	@0
                                 	.endmacro
                                 
                                 ; ====================
                                 ; 	bit operations
                                 ; ====================
                                 
                                 ; --- moving bits ---
                                 .macro	MOVB	; reg1,b1, reg2,b2	; reg1,bit1 <- reg2,bit2
                                 	bst	@2,@3
                                 	bld	@0,@1
                                 	.endmacro
                                 .macro	OUTB	; port1,b1, reg2,b2	; port1,bit1 <- reg2,bit2
                                 	sbrs	@2,@3
                                 	cbi	@0,@1
                                 	sbrc	@2,@3
                                 	sbi	@0,@1
                                 	.endmacro
                                 .macro	INB	; reg1,b1, port2,b2	; reg1,bit1 <- port2,bit2
                                 	sbis	@2,@3
                                 	cbr	@0,1<<@1
                                 	sbic	@2,@3
                                 	sbr	@0,1<<@1
                                 	.endmacro
                                 
                                 .macro	Z2C				; zero to carry
                                 	sec
                                 	breq	PC+2	; (Z=1)
                                 	clc
                                 	.endmacro
                                 .macro	Z2INVC				; zero to inverse carry
                                 	sec
                                 	brne	PC+2	; (Z=0)
                                 	clc
                                 	.endmacro
                                 
                                 .macro	C2Z				; carry to zero
                                 	sez
                                 	brcs	PC+2	; (C=1)
                                 	clz
                                 	.endmacro
                                 
                                 .macro	B2C	; reg,b			; bit to carry
                                 	sbrc	@0,@1
                                 	sec
                                 	sbrs	@0,@1
                                 	clc
                                 	.endmacro
                                 .macro	C2B	; reg,b			; carry to bit
                                 	brcc	PC+2
                                 	sbr	@0,(1<<@1)
                                 	brcs	PC+2
                                 	cbr	@0,(1<<@1)
                                 	.endmacro
                                 .macro	P2C	; port,b		; port to carry
                                 	sbic	@0,@1
                                 	sec
                                 	sbis	@0,@1
                                 	clc
                                 	.endmacro
                                 .macro	C2P	; port,b		; carry to port
                                 	brcc	PC+2
                                 	sbi	@0,@1
                                 	brcs	PC+2
                                 	cbi	@0,@1
                                 	.endmacro
                                 
                                 ; --- inverting bits ---
                                 .macro	INVB	; reg,bit		; inverse reg,bit
                                 	ldi	w,(1<<@1)
                                 	eor	@0,w
                                 	.endmacro
                                 .macro	INVP	; port,bit		; inverse port,bit	
                                 	sbis	@0,@1
                                 	rjmp	PC+3
                                 	cbi	@0,@1
                                 	rjmp	PC+2
                                 	sbi	@0,@1
                                 	.endmacro
                                 .macro	INVC				; inverse carry	
                                 	brcs	PC+3
                                 	sec
                                 	rjmp	PC+2
                                 	clc
                                 	.endmacro
                                 
                                 ; --- setting a single bit ---
                                 .macro	SETBIT	; reg(0..7)
                                 ; in	reg (0..7)
                                 ; out	reg with bit (0..7) set to 1.
                                 ; 0=00000001
                                 ; 1=00000010
                                 ; ...
                                 ; 7=10000000
                                 	mov	w,@0
                                 	clr	@0
                                 	inc	@0
                                 	andi	w,0b111	
                                 	breq	PC+4
                                 	lsl	@0
                                 	dec	w
                                 	brne	PC-2
                                 	.endmacro
                                 
                                 ; --- logical operations with masks ---
                                 .macro	MOVMSK	; reg1,reg2,mask	; reg1 <- reg2 (mask)
                                 	ldi	w,~@2	
                                 	and	@0,w
                                 	ldi	w,@2
                                 	and	@1,w	
                                 	or	@0,@1
                                 	.endmacro	
                                 .macro	ANDMSK	; reg1,reg2,mask	; reg1 <- ret 1 AND reg2 (mask)		
                                 	mov	w,@1
                                 	ori	w,~@2
                                 	and	@0,w
                                 	.endmacro	
                                 .macro	ORMSK	; reg1,reg2,mask	; reg1 <- ret 1 AND reg2 (mask)		
                                 	mov	w,@1
                                 	andi	w,@2
                                 	or	@0,w
                                 	.endmacro
                                 	
                                 ; --- logical operations on bits ---
                                 .macro	ANDB	; r1,b1, r2,b2, r3,b3	; reg1,b1 <- reg2,b2 AND reg3,b3
                                 	set
                                 	sbrs	@4,@5	
                                 	clt
                                 	sbrs	@2,@3	
                                 	clt
                                 	bld	@0,@1
                                 	.endmacro
                                 .macro	ORB	; r1,b1, r2,b2, r3,b3	; reg1.b1 <- reg2.b2 OR reg3.b3
                                 	clt
                                 	sbrc	@4,@5	
                                 	set
                                 	sbrc	@2,@3	
                                 	set
                                 	bld	@0,@1
                                 	.endmacro
                                 .macro	EORB	; r1,b1, r2,b2, r3,b3	; reg1.b1 <- reg2.b2 XOR reg3.b3
                                 	sbrc	@4,@5
                                 	rjmp	f1
                                 f0:	bst	@2,@3	
                                 	rjmp	PC+4
                                 f1:	set
                                 	sbrc	@0,@1
                                 	clt
                                 	bld	@0,@0	
                                 	.endmacro
                                 	
                                 ; --- operations based on register bits ---
                                 .macro	FB0	; reg,bit		; bit=0
                                 	cbr	@0,1<<@1
                                 	.endmacro
                                 .macro	FB1	; reg,bit		; bit=1
                                 	sbr	@0,1<<@1
                                 	.endmacro
                                 .macro	_FB0	; reg,bit		; bit=0
                                 	ldi	w,~(1<<@1)
                                 	and	@0,w
                                 	.endmacro
                                 .macro	_FB1	; reg,bit		; bit=1
                                 	ldi	w,1<<@1
                                 	or	@0,w
                                 	.endmacro
                                 .macro	SB0	; reg,bit,addr		; skip if bit=0
                                 	sbrc	@0,@1
                                 	.endmacro
                                 .macro	SB1	; reg,bit,addr		; skip if bit=1
                                 	sbrs	@0,@1
                                 	.endmacro
                                 .macro	JB0	; reg,bit,addr		; jump if bit=0
                                 	sbrs	@0,@1
                                 	rjmp	@2
                                 	.endmacro
                                 .macro	JB1	; reg,bit,addr		; jump if bit=1
                                 	sbrc	@0,@1
                                 	rjmp	@2
                                 	.endmacro
                                 .macro	CB0	; reg,bit,addr		; call if bit=0
                                 	sbrs	@0,@1
                                 	rcall	@2
                                 	.endmacro
                                 .macro	CB1	; reg,bit,addr		; call if bit=1
                                 	sbrc	@0,@1
                                 	rcall	@2
                                 	.endmacro
                                 .macro	WB0	; reg,bit		; wait if bit=0
                                 	sbrs	@0,@1
                                 	rjmp	PC-1
                                 	.endmacro
                                 .macro	WB1	; reg,bit		; wait if bit=1
                                 	sbrc	@0,@1
                                 	rjmp	PC-1
                                 	.endmacro
                                 .macro	RB0	; reg,bit		; return if bit=0
                                 	sbrs	@0,@1
                                 	ret
                                 	.endmacro
                                 .macro	RB1	; reg,bit		; return if bit=1
                                 	sbrc	@0,@1
                                 	ret
                                 	.endmacro
                                 
                                 ; wait if bit=0 with timeout
                                 ; if timeout (in units of 5 cyc) then jump to addr
                                 .macro	WB0T	; reg,bit,timeout,addr
                                 	ldi	w,@2+1
                                 	dec	w	; 1 cyc
                                 	breq	@3	; 1 cyc
                                 	sbrs	@0,@1	; 1 cyc
                                 	rjmp	PC-3	; 2 cyc = 5 cycles
                                 	.endmacro
                                 
                                 ; wait if bit=1 with timeout
                                 ; if timeout (in units of 5 cyc) then jump to addr	
                                 .macro	WB1T	; reg,bit,timeout,addr
                                 	ldi	w,@2+1
                                 	dec	w	; 1 cyc
                                 	breq	@3	; 1 cyc
                                 	sbrc	@0,@1	; 1 cyc
                                 	rjmp	PC-3	; 2 cyc = 5 cycles
                                 	.endmacro	
                                 	
                                 ; --- operations based on port bits ---
                                 .macro	P0	; port,bit		; port=0
                                 	cbi	@0,@1
                                 	.endmacro
                                 .macro	P1	; port,bit		; port=1
                                 	sbi	@0,@1
                                 	.endmacro
                                 .macro	SP0	; port,bit		; skip if port=0
                                 	sbic	@0,@1
                                 	.endmacro
                                 .macro	SP1	; port,bit		; skip if port=1
                                 	sbis	@0,@1
                                 	.endmacro
                                 .macro	JP0	; port,bit,addr		; jump if port=0
                                 	sbis	@0,@1
                                 	rjmp	@2
                                 	.endmacro
                                 .macro	JP1	; port,bit,addr		; jump if port=1
                                 	sbic	@0,@1
                                 	rjmp	@2
                                 	.endmacro
                                 .macro	CP0	; port,bit,addr		; call if port=0
                                 	sbis	@0,@1
                                 	rcall	@2
                                 	.endmacro
                                 .macro	CP1	; port,bit,addr		; call if port=1
                                 	sbic	@0,@1
                                 	rcall	@2
                                 	.endmacro
                                 .macro	WP0	; port,bit		; wait if port=0
                                 	sbis	@0,@1
                                 	rjmp	PC-1
                                 	.endmacro
                                 .macro	WP1	; port,bit		; wait if port=1
                                 	sbic	@0,@1
                                 	rjmp	PC-1
                                 	.endmacro
                                 .macro	RP0	; port,bit		; return if port=0
                                 	sbis	@0,@1
                                 	ret
                                 	.endmacro
                                 .macro	RP1	; port,bit		; return if port=1
                                 	sbic	@0,@1
                                 	ret
                                 	.endmacro
                                 
                                 ; wait if port=0 with timeout
                                 ; if timeout (in units of 5 cyc) then jump to addr
                                 .macro	WP0T	; port,bit,timeout,addr
                                 	ldi	w,@2+1
                                 	dec	w	; 1 cyc
                                 	breq	@3	; 1 cyc
                                 	sbis	@0,@1	; 1 cyc
                                 	rjmp	PC-3	; 2 cyc = 5 cycles
                                 	.endmacro
                                 
                                 ; wait if port=1 with timeout
                                 ; if timeout (in units of 5 cyc) then jump to addr	
                                 .macro	WP1T	; port,bit,timeout,addr
                                 	ldi	w,@2+1
                                 	dec	w	; 1 cyc
                                 	breq	@3	; 1 cyc
                                 	sbic	@0,@1	; 1 cyc
                                 	rjmp	PC-3	; 2 cyc = 5 cycles
                                 	.endmacro	
                                 
                                 ; ===========================
                                 ; 	multi-byte operations
                                 ; ===========================
                                 
                                 .macro	SWAP4			; swap 2 variables
                                 	mov	w ,@0
                                 	mov	@0,@4
                                 	mov	@4,w
                                 	mov	w ,@1
                                 	mov	@1,@5
                                 	mov	@5,w
                                 	mov	w ,@2
                                 	mov	@2,@6
                                 	mov	@6,w
                                 	mov	w ,@3
                                 	mov	@3,@7
                                 	mov	@7,w
                                 	.endmacro
                                 .macro	SWAP3
                                 	mov	w ,@0
                                 	mov	@0,@3
                                 	mov	@3,w
                                 	mov	w ,@1
                                 	mov	@1,@4
                                 	mov	@4,w
                                 	mov	w ,@2
                                 	mov	@2,@5
                                 	mov	@5,w
                                 	.endmacro
                                 .macro	SWAP2
                                 	mov	w ,@0
                                 	mov	@0,@2
                                 	mov	@2,w
                                 	mov	w ,@1
                                 	mov	@1,@3
                                 	mov	@3,w
                                 	.endmacro
                                 .macro	SWAP1
                                 	mov	w ,@0
                                 	mov	@0,@1
                                 	mov	@1,w
                                 	.endmacro
                                 
                                 .macro	LDX4	;r..r0		; load from (x+)
                                 	ld	@3,x+
                                 	ld	@2,x+	
                                 	ld	@1,x+
                                 	ld	@0,x+
                                 	.endmacro
                                 .macro	LDX3	;r..r0
                                 	ld	@2,x+	
                                 	ld	@1,x+
                                 	ld	@0,x+
                                 	.endmacro
                                 .macro	LDX2	;r..r0	
                                 	ld	@1,x+
                                 	ld	@0,x+
                                 	.endmacro
                                 	
                                 .macro	LDY4	;r..r0		; load from (y+)
                                 	ld	@3,y+
                                 	ld	@2,y+	
                                 	ld	@1,y+
                                 	ld	@0,y+
                                 	.endmacro
                                 .macro	LDY3	;r..r0
                                 	ld	@2,y+	
                                 	ld	@1,y+
                                 	ld	@0,y+
                                 	.endmacro
                                 .macro	LDY2	;r..r0	
                                 	ld	@1,y+
                                 	ld	@0,y+
                                 	.endmacro
                                 
                                 .macro	LDZ4	;r..r0		; load from (z+)
                                 	ld	@3,z+
                                 	ld	@2,z+	
                                 	ld	@1,z+
                                 	ld	@0,z+
                                 	.endmacro
                                 .macro	LDZ3	;r..r0
                                 	ld	@2,z+	
                                 	ld	@1,z+
                                 	ld	@0,z+
                                 	.endmacro
                                 .macro	LDZ2	;r..r0
                                 	ld	@1,z+
                                 	ld	@0,z+
                                 	.endmacro
                                 
                                 .macro	STX4	;r..r0		; store to (x+)
                                 	st	x+,@3
                                 	st	x+,@2	
                                 	st	x+,@1
                                 	st	x+,@0
                                 	.endmacro
                                 .macro	STX3	;r..r0
                                 	st	x+,@2	
                                 	st	x+,@1
                                 	st	x+,@0
                                 	.endmacro
                                 .macro	STX2	;r..r0
                                 	st	x+,@1
                                 	st	x+,@0
                                 	.endmacro
                                 	
                                 .macro	STY4	;r..r0		; store to (y+)
                                 	st	y+,@3
                                 	st	y+,@2	
                                 	st	y+,@1
                                 	st	y+,@0
                                 	.endmacro
                                 .macro	STY3	;r..r0
                                 	st	y+,@2	
                                 	st	y+,@1
                                 	st	y+,@0
                                 	.endmacro
                                 .macro	STY2	;r..r0	
                                 	st	y+,@1
                                 	st	y+,@0
                                 	.endmacro
                                 	
                                 .macro	STZ4	;r..r0		; store to (z+)
                                 	st	z+,@3
                                 	st	z+,@2	
                                 	st	z+,@1
                                 	st	z+,@0
                                 	.endmacro	
                                 .macro	STZ3	;r..r0
                                 	st	z+,@2	
                                 	st	z+,@1
                                 	st	z+,@0
                                 	.endmacro	
                                 .macro	STZ2	;r..r0	
                                 	st	z+,@1
                                 	st	z+,@0
                                 	.endmacro	
                                 	
                                 .macro	STI4	;addr,k		; store immediate
                                 	ldi	w,  low(@1)
                                 	sts	@0+0,w
                                 	ldi	w, high(@1)
                                 	sts	@0+1,w
                                 	ldi	w,byte3(@1)
                                 	sts	@0+2,w
                                 	ldi	w,byte4(@1)
                                 	sts	@0+3,w	
                                 	.endmacro	
                                 .macro	STI3	;addr,k
                                 	ldi	w,  low(@1)
                                 	sts	@0+0,w
                                 	ldi	w, high(@1)
                                 	sts	@0+1,w
                                 	ldi	w,byte3(@1)
                                 	sts	@0+2,w
                                 	.endmacro	
                                 .macro	STI2	;addr,k
                                 	ldi	w,  low(@1)
                                 	sts	@0+0,w
                                 	ldi	w, high(@1)
                                 	sts	@0+1,w
                                 	.endmacro
                                 .macro	STI	;addr,k
                                 	ldi	w,@1
                                 	sts	@0,w
                                 	.endmacro
                                 
                                 .macro	INC4			; increment
                                 	ldi	w,0xff
                                 	sub	@3,w
                                 	sbc	@2,w
                                 	sbc	@1,w
                                 	sbc	@0,w
                                 	.endmacro
                                 .macro	INC3
                                 	ldi	w,0xff
                                 	sub	@2,w
                                 	sbc	@1,w
                                 	sbc	@0,w
                                 	.endmacro
                                 .macro	INC2
                                 	ldi	w,0xff
                                 	sub	@1,w
                                 	sbc	@0,w
                                 	.endmacro
                                 
                                 .macro	DEC4			; decrement
                                 	ldi	w,0xff
                                 	add	@3,w
                                 	adc	@2,w
                                 	adc	@1,w
                                 	adc	@0,w
                                 	.endmacro
                                 .macro	DEC3
                                 	ldi	w,0xff
                                 	add	@2,w
                                 	adc	@1,w
                                 	adc	@0,w
                                 	.endmacro
                                 .macro	DEC2
                                 	ldi	w,0xff
                                 	add	@1,w
                                 	adc	@0,w
                                 	.endmacro
                                 
                                 .macro	CLR9			; clear (also clears the carry)
                                 	sub	@0,@0
                                 	clr	@1
                                 	clr	@2
                                 	clr	@3
                                 	clr	@4
                                 	clr	@5
                                 	clr	@6
                                 	clr	@7
                                 	clr	@8
                                 	.endmacro
                                 .macro	CLR8
                                 	sub	@0,@0
                                 	clr	@1
                                 	clr	@2
                                 	clr	@3
                                 	clr	@4
                                 	clr	@5
                                 	clr	@6
                                 	clr	@7
                                 	.endmacro
                                 .macro	CLR7
                                 	sub	@0,@0
                                 	clr	@1
                                 	clr	@2
                                 	clr	@3
                                 	clr	@4
                                 	clr	@5
                                 	clr	@6
                                 	.endmacro
                                 .macro	CLR6
                                 	sub	@0,@0
                                 	clr	@1
                                 	clr	@2
                                 	clr	@3
                                 	clr	@4
                                 	clr	@5
                                 	.endmacro
                                 .macro	CLR5
                                 	sub	@0,@0
                                 	clr	@1
                                 	clr	@2
                                 	clr	@3
                                 	clr	@4
                                 	.endmacro
                                 .macro	CLR4
                                 	sub	@0,@0
                                 	clr	@1
                                 	clr	@2
                                 	clr	@3
                                 	.endmacro
                                 .macro	CLR3
                                 	sub	@0,@0
                                 	clr	@1
                                 	clr	@2
                                 	.endmacro
                                 .macro	CLR2
                                 	sub	@0,@0
                                 	clr	@1
                                 	.endmacro
                                 
                                 .macro	COM4			; one's complement
                                 	com	@0
                                 	com	@1
                                 	com	@2
                                 	com	@3
                                 	.endmacro
                                 .macro	COM3
                                 	com	@0
                                 	com	@1
                                 	com	@2
                                 	.endmacro
                                 .macro	COM2
                                 	com	@0
                                 	com	@1
                                 	.endmacro
                                 
                                 .macro	NEG4			; negation (two's complement)
                                 	com	@0
                                 	com	@1
                                 	com	@2
                                 	com	@3
                                 	ldi	w,0xff
                                 	sub	@3,w
                                 	sbc	@2,w
                                 	sbc	@1,w
                                 	sbc	@0,w
                                 	.endmacro
                                 .macro	NEG3
                                 	com	@0
                                 	com	@1
                                 	com	@2
                                 	ldi	w,0xff
                                 	sub	@2,w
                                 	sbc	@1,w
                                 	sbc	@0,w
                                 	.endmacro
                                 .macro	NEG2
                                 	com	@0
                                 	com	@1
                                 	ldi	w,0xff
                                 	sub	@1,w
                                 	sbc	@0,w
                                 	.endmacro
                                 	
                                 .macro	LDI4 	; r..r0, k	; load immediate
                                 	ldi	@3,  low(@4)
                                 	ldi	@2, high(@4)
                                 	ldi	@1,byte3(@4)
                                 	ldi	@0,byte4(@4)
                                 	.endmacro
                                 .macro	LDI3
                                 	ldi	@2,  low(@3)
                                 	ldi	@1, high(@3)
                                 	ldi	@0,byte3(@3)
                                 	.endmacro
                                 .macro	LDI2
                                 	ldi	@1,  low(@2)
                                 	ldi	@0, high(@2)
                                 	.endmacro
                                 
                                 .macro	LDS4			; load direct from SRAM
                                 	lds	@3,@4
                                 	lds	@2,@4+1
                                 	lds	@1,@4+2
                                 	lds	@0,@4+3
                                 	.endmacro
                                 .macro	LDS3
                                 	lds	@2,@3
                                 	lds	@1,@3+1
                                 	lds	@0,@3+2
                                 	.endmacro
                                 .macro	LDS2
                                 	lds	@1,@2
                                 	lds	@0,@2+1
                                 	.endmacro
                                 
                                 .macro	STS4			; store direct to SRAM
                                 	sts	@0+0,@4
                                 	sts	@0+1,@3
                                 	sts	@0+2,@2
                                 	sts	@0+3,@1
                                 	.endmacro
                                 .macro	STS3
                                 	sts	@0+0,@3
                                 	sts	@0+1,@2
                                 	sts	@0+2,@1
                                 	.endmacro
                                 .macro	STS2
                                 	sts	@0+0,@2
                                 	sts	@0+1,@1
                                 	.endmacro
                                 
                                 .macro	STDZ4	; d, r3,r2,r1,r0
                                 	std	z+@0+0,@4
                                 	std	z+@0+1,@3
                                 	std	z+@0+2,@2
                                 	std	z+@0+3,@1
                                 	.endmacro
                                 .macro	STDZ3	; d, r2,r1,r0
                                 	std	z+@0+0,@3
                                 	std	z+@0+1,@2
                                 	std	z+@0+2,@1
                                 	.endmacro
                                 .macro	STDZ2	; d, r1,r0
                                 	std	z+@0+0,@2
                                 	std	z+@0+1,@1
                                 	.endmacro
                                 	
                                 .macro	LPM4			; load program memory
                                 	lpm
                                 	mov	@3,r0
                                 	adiw	zl,1
                                 	lpm
                                 	mov	@2,r0
                                 	adiw	zl,1
                                 	lpm
                                 	mov	@1,r0
                                 	adiw	zl,1
                                 	lpm
                                 	mov	@0,r0
                                 	adiw	zl,1
                                 	.endmacro
                                 .macro	LPM3
                                 	lpm
                                 	mov	@2,r0
                                 	adiw	zl,1
                                 	lpm
                                 	mov	@1,r0
                                 	adiw	zl,1
                                 	lpm
                                 	mov	@0,r0
                                 	adiw	zl,1
                                 	.endmacro
                                 .macro	LPM2
                                 	lpm
                                 	mov	@1,r0
                                 	adiw	zl,1
                                 	lpm
                                 	mov	@0,r0
                                 	adiw	zl,1
                                 	.endmacro
                                 .macro	LPM1
                                 	lpm
                                 	mov	@0,r0
                                 	adiw	zl,1
                                 	.endmacro
                                 
                                 .macro	MOV4			; move between registers
                                 	mov	@3,@7
                                 	mov	@2,@6
                                 	mov	@1,@5
                                 	mov	@0,@4
                                 	.endmacro
                                 .macro	MOV3
                                 	mov	@2,@5
                                 	mov	@1,@4
                                 	mov	@0,@3
                                 	.endmacro
                                 .macro	MOV2
                                 	mov	@1,@3
                                 	mov	@0,@2
                                 	.endmacro
                                 
                                 .macro	ADD4			; add
                                 	add	@3,@7
                                 	adc	@2,@6
                                 	adc	@1,@5
                                 	adc	@0,@4
                                 	.endmacro
                                 .macro	ADD3
                                 	add	@2,@5
                                 	adc	@1,@4
                                 	adc	@0,@3
                                 	.endmacro
                                 .macro	ADD2
                                 	add	@1,@3
                                 	adc	@0,@2
                                 	.endmacro
                                 
                                 .macro	SUB4			; subtract
                                 	sub	@3,@7
                                 	sbc	@2,@6
                                 	sbc	@1,@5
                                 	sbc	@0,@4
                                 	.endmacro
                                 .macro	SUB3
                                 	sub	@2,@5
                                 	sbc	@1,@4
                                 	sbc	@0,@3
                                 	.endmacro
                                 .macro	SUB2
                                 	sub	@1,@3
                                 	sbc	@0,@2
                                 	.endmacro
                                 	
                                 .macro	CP4			; compare
                                 	cp	@3,@7
                                 	cpc	@2,@6
                                 	cpc	@1,@5
                                 	cpc	@0,@4
                                 	.endmacro
                                 .macro	CP3
                                 	cp	@2,@5
                                 	cpc	@1,@4
                                 	cpc	@0,@3
                                 	.endmacro
                                 .macro	CP2
                                 	cp	@1,@3
                                 	cpc	@0,@2
                                 	.endmacro
                                 
                                 .macro	TST4			; test
                                 	clr	w
                                 	cp	@3,w
                                 	cpc	@2,w
                                 	cpc	@1,w
                                 	cpc	@0,w
                                 	.endmacro
                                 .macro	TST3
                                 	clr	w
                                 	cp	@2,w
                                 	cpc	@1,w
                                 	cpc	@0,w
                                 	.endmacro
                                 .macro	TST2
                                 	clr	w
                                 	cp	@1,w
                                 	cpc	@0,w
                                 	.endmacro
                                 
                                 .macro	ADDI4			; add immediate
                                 	subi	@3,  low(-@4)
                                 	sbci	@2, high(-@4)
                                 	sbci	@1,byte3(-@4)
                                 	sbci	@0,byte4(-@4)
                                 	.endmacro
                                 .macro	ADDI3
                                 	subi	@2,  low(-@3)
                                 	sbci	@1, high(-@3)
                                 	sbci	@0,byte3(-@3)
                                 	.endmacro
                                 .macro	ADDI2
                                 	subi	@1,  low(-@2)
                                 	sbci	@0, high(-@2)
                                 	.endmacro
                                 	
                                 .macro	SUBI4			; subtract immediate
                                 	subi	@3,  low(@4)
                                 	sbci	@2, high(@4)
                                 	sbci	@1,byte3(@4)
                                 	sbci	@0,byte4(@4)
                                 	.endmacro
                                 .macro	SUBI3
                                 	subi	@2,  low(@3)
                                 	sbci	@1, high(@3)
                                 	sbci	@0,byte3(@3)
                                 	.endmacro
                                 .macro	SUBI2
                                 	subi	@1,  low(@2)
                                 	sbci	@0, high(@2)
                                 	.endmacro
                                 
                                 .macro	LSL5			; logical shift left
                                 	lsl	@4
                                 	rol	@3
                                 	rol	@2
                                 	rol	@1
                                 	rol	@0
                                 	.endmacro
                                 .macro	LSL4
                                 	lsl	@3
                                 	rol	@2
                                 	rol	@1
                                 	rol	@0
                                 	.endmacro
                                 .macro	LSL3
                                 	lsl	@2
                                 	rol	@1
                                 	rol	@0
                                 	.endmacro
                                 .macro	LSL2
                                 	lsl	@1
                                 	rol	@0
                                 	.endmacro
                                 	
                                 .macro	LSR4			; logical shift right
                                 	lsr	@0
                                 	ror	@1
                                 	ror	@2
                                 	ror	@3
                                 	.endmacro
                                 .macro	LSR3
                                 	lsr	@0
                                 	ror	@1
                                 	ror	@2
                                 	.endmacro
                                 .macro	LSR2
                                 	lsr	@0
                                 	ror	@1
                                 	.endmacro
                                 
                                 .macro	ASR4			; arithmetic shift right
                                 	asr	@0
                                 	ror	@1
                                 	ror	@2
                                 	ror	@3
                                 	.endmacro
                                 .macro	ASR3
                                 	asr	@0
                                 	ror	@1
                                 	ror	@2
                                 	.endmacro
                                 .macro	ASR2
                                 	asr	@0
                                 	ror	@1
                                 	.endmacro
                                 
                                 .macro	ROL8			; rotate left through carry
                                 	rol	@7
                                 	rol	@6
                                 	rol	@5
                                 	rol	@4
                                 	rol	@3
                                 	rol	@2
                                 	rol	@1
                                 	rol	@0
                                 	.endmacro
                                 .macro	ROL7
                                 	rol	@6
                                 	rol	@5
                                 	rol	@4
                                 	rol	@3
                                 	rol	@2
                                 	rol	@1
                                 	rol	@0
                                 	.endmacro
                                 .macro	ROL6
                                 	rol	@5
                                 	rol	@4
                                 	rol	@3
                                 	rol	@2
                                 	rol	@1
                                 	rol	@0
                                 	.endmacro
                                 .macro	ROL5
                                 	rol	@4
                                 	rol	@3
                                 	rol	@2
                                 	rol	@1
                                 	rol	@0
                                 	.endmacro
                                 .macro	ROL4
                                 	rol	@3
                                 	rol	@2
                                 	rol	@1
                                 	rol	@0
                                 	.endmacro
                                 .macro	ROL3
                                 	rol	@2
                                 	rol	@1
                                 	rol	@0
                                 	.endmacro
                                 .macro	ROL2
                                 	rol	@1
                                 	rol	@0
                                 	.endmacro
                                 
                                 .macro	ROR8			; rotate right through carry
                                 	ror	@0
                                 	ror	@1
                                 	ror	@2
                                 	ror	@3
                                 	ror	@4
                                 	ror	@5
                                 	ror	@6
                                 	ror	@7
                                 	.endmacro
                                 .macro	ROR7
                                 	ror	@0
                                 	ror	@1
                                 	ror	@2
                                 	ror	@3
                                 	ror	@4
                                 	ror	@5
                                 	ror	@6
                                 	.endmacro
                                 .macro	ROR6
                                 	ror	@0
                                 	ror	@1
                                 	ror	@2
                                 	ror	@3
                                 	ror	@4
                                 	ror	@5
                                 	.endmacro
                                 .macro	ROR5
                                 	ror	@0
                                 	ror	@1
                                 	ror	@2
                                 	ror	@3
                                 	ror	@4
                                 	.endmacro	
                                 .macro	ROR4
                                 	ror	@0
                                 	ror	@1
                                 	ror	@2
                                 	ror	@3
                                 	.endmacro
                                 .macro	ROR3
                                 	ror	@0
                                 	ror	@1
                                 	ror	@2
                                 	.endmacro
                                 .macro	ROR2
                                 	ror	@0
                                 	ror	@1
                                 	.endmacro
                                 
                                 .macro	PUSH2
                                 	push	@0
                                 	push	@1
                                 	.endmacro	
                                 .macro	POP2
                                 	pop	@1
                                 	pop	@0
                                 	.endmacro
                                 
                                 .macro	PUSH3
                                 	push	@0
                                 	push	@1
                                 	push	@2
                                 	.endmacro	
                                 .macro	POP3
                                 	pop	@2
                                 	pop	@1
                                 	pop	@0
                                 	.endmacro
                                 	
                                 .macro	PUSH4
                                 	push	@0
                                 	push	@1
                                 	push	@2
                                 	push	@3
                                 	.endmacro	
                                 .macro	POP4
                                 	pop	@3
                                 	pop	@2
                                 	pop	@1
                                 	pop	@0
                                 	.endmacro	
                                 	
                                 .macro	PUSH5
                                 	pop	@0
                                 	pop	@1
                                 	pop	@2
                                 	pop	@3
                                 	pop	@4
                                 	.endmacro	
                                 .macro	POP5
                                 	pop	@4
                                 	pop	@3
                                 	pop	@2
                                 	pop	@1
                                 	pop	@0
                                 	.endmacro	
                                 
                                 ; --- SRAM operations ---
                                 .macro	INCS4	; sram		; increment SRAM 4-byte variable
                                 	lds	w,@0
                                 	inc	w
                                 	sts	@0,w
                                 	brne	end
                                 	lds	w,@0+1
                                 	inc	w
                                 	sts	@0+1,w
                                 	brne	end
                                 	lds	w,@0+2
                                 	inc	w
                                 	sts	@0+2,w
                                 	brne	end
                                 	lds	w,@0+3
                                 	inc	w
                                 	sts	@0+3,w
                                 end:	
                                 	.endmacro
                                 
                                 .macro	INCS3	; sram		; increment SRAM 3-byte variable
                                 	lds	w,@0
                                 	inc	w
                                 	sts	@0,w
                                 	brne	end
                                 	lds	w,@0+1
                                 	inc	w
                                 	sts	@0+1,w
                                 	brne	end
                                 	lds	w,@0+2
                                 	inc	w
                                 	sts	@0+2,w
                                 end:	
                                 	.endmacro
                                 
                                 .macro	INCS2	; sram		; increment SRAM 2-byte variable
                                 	lds	w,@0
                                 	inc	w
                                 	sts	@0,w
                                 	brne	end
                                 	lds	w,@0+1
                                 	inc	w
                                 	sts	@0+1,w
                                 end:	
                                 	.endmacro
                                 
                                 .macro	INCS	; sram		; increment SRAM 1-byte variable
                                 	lds	w,@0
                                 	inc	w
                                 	sts	@0,w
                                 	.endmacro
                                 
                                 .macro	DECS4	; sram		; decrement SRAM 4-byte variable
                                 	ldi	w,1
                                 	lds	u,@0
                                 	sub	u,w
                                 	sts	@0,u
                                 	clr	w
                                 	lds	u,@0+1
                                 	sbc	u,w
                                 	sts	@0+1,u
                                 	lds	u,@0+2
                                 	sbc	u,w
                                 	sts	@0+2,u
                                 	lds	u,@0+3
                                 	sbc	u,w
                                 	sts	@0+3,u
                                 	.endmacro
                                 .macro	DECS3	; sram		; decrement SRAM 3-byte variable
                                 	ldi	w,1
                                 	lds	u,@0
                                 	sub	u,w
                                 	sts	@0,u
                                 	clr	w
                                 	lds	u,@0+1
                                 	sbc	u,w
                                 	sts	@0+1,u
                                 	lds	u,@0+2
                                 	sbc	u,w
                                 	sts	@0+2,u
                                 	.endmacro
                                 .macro	DECS2	; sram		; decrement SRAM 2-byte variable
                                 	ldi	w,1
                                 	lds	u,@0
                                 	sub	u,w
                                 	sts	@0,u
                                 	clr	w
                                 	lds	u,@0+1
                                 	sbc	u,w
                                 	sts	@0+1,u
                                 	.endmacro
                                 .macro	DECS	; sram		; decrement
                                 	lds	w,@0
                                 	dec	w
                                 	sts	@0,w
                                 	.endmacro
                                 
                                 .macro	MOVS4	; addr0,addr1	; [addr0] <-- [addr1]
                                 	lds	w,@1
                                 	sts	@0,w
                                 	lds	w,@1+1
                                 	sts	@0+1,w
                                 	lds	w,@1+2
                                 	sts	@0+2,w
                                 	lds	w,@3+1
                                 	sts	@0+3,w	
                                 	.endmacro
                                 .macro	MOVS3	; addr0,addr1	; [addr0] <-- [addr1]
                                 	lds	w,@1
                                 	sts	@0,w
                                 	lds	w,@1+1
                                 	sts	@0+1,w
                                 	lds	w,@1+2
                                 	sts	@0+2,w
                                 	.endmacro
                                 .macro	MOVS2	; addr0,addr1	; [addr0] <-- [addr1]
                                 	lds	w,@1
                                 	sts	@0,w
                                 	lds	w,@1+1
                                 	sts	@0+1,w
                                 	.endmacro
                                 .macro	MOVS	; addr0,addr1	; [addr0] <-- [addr1]
                                 	lds	w,@1
                                 	sts	@0,w
                                 	.endmacro
                                 
                                 .macro	SEXT	; reg1,reg0	; sign extend
                                 	clr	@0
                                 	sbrc	@1,7
                                 	dec	@0
                                 	.endmacro
                                 
                                 ; =======================================
                                 ;	Jump/Call with constant arguments
                                 ; =======================================
                                 	
                                 ; --- calls with arguments a,b,XYZ ---
                                 .macro	CX	; subroutine,x
                                 	ldi	xl, low(@1)
                                 	ldi	xh,high(@1)
                                 	rcall	@0
                                 	.endmacro
                                 .macro	CXY	; subroutine,x,y
                                 	ldi	xl, low(@1)
                                 	ldi	xh,high(@1)
                                 	ldi	yl, low(@2)
                                 	ldi	yh,high(@2)	
                                 	rcall	@0
                                 	.endmacro		
                                 .macro	CXZ	; subroutine,x,z
                                 	ldi	xl, low(@1)
                                 	ldi	xh,high(@1)
                                 	ldi	zl, low(@2)
                                 	ldi	zh,high(@2)	
                                 	rcall	@0
                                 	.endmacro		
                                 .macro	CXYZ	; subroutine,x,y,z
                                 	ldi	xl, low(@1)
                                 	ldi	xh,high(@1)
                                 	ldi	yl, low(@2)
                                 	ldi	yh,high(@2)
                                 	ldi	zl, low(@3)
                                 	ldi	zh,high(@3)		
                                 	rcall	@0
                                 	.endmacro
                                 .macro	CW	; subroutine,w
                                 	ldi	w, @1
                                 	rcall	@0
                                 	.endmacro
                                 .macro	CA	; subroutine,a
                                 	ldi	a0, @1
                                 	rcall	@0
                                 	.endmacro
                                 .macro	CAB	; subroutine,a,b
                                 	ldi	a0, @1
                                 	ldi	b0, @2
                                 	rcall	@0
                                 	.endmacro
                                 
                                 ; --- jump with arguments w,a,b ---
                                 .macro	JW	; subroutine,w
                                 	ldi	w, @1
                                 	rjmp	@0
                                 	.endmacro
                                 .macro	JA	; subroutine,a
                                 	ldi	a0, @1
                                 	rjmp	@0
                                 	.endmacro
                                 .macro	JAB	; subroutine,a,b
                                 	ldi	a0, @1
                                 	ldi	b0, @2
                                 	rjmp	@0
                                 	.endmacro
                                 .list
                                 
                                 
                                 
                                  reset:
000000 ef0f
000001 bf0d
000002 e100
000003 bf0e                      	LDSP	RAMEND	
                                    ;rcall	all initializations
000004 d265                      	rcall LCD_init
000005 ef0f                      	ldi r16, 0xff
000006 bb07                      	out DDRB, r16
000007 e000                      	ldi r16, 0x00
000008 bb01                      	out DDRD, r16
                                 
000009 c286                      	rjmp	main
                                 
                                 .include "printf.asm"
                                 
                                 ; purpose library, formatted output generation
                                 ; author (c) R.Holzer (adapted MICRO210/EE208 A.Schmid)
                                 
                                 ; === description ===
                                 ; 
                                 ; The program "printf" interprets and prints formatted strings.
                                 ; The special formatting characters regognized are:
                                 ;
                                 ; FDEC	decimal number
                                 ; FHEX	hexadecimal number
                                 ; FBIN	binary number
                                 ; FFRAC	fixed fraction number
                                 ; FCHAR	single ASCII character
                                 ; FSTR	zero-terminated ASCII string
                                 	
                                 ; The special formatting characters are distinguished from normal 
                                 ; ASCII characters by having bit7 set to 1.
                                 
                                 ; Signification of bit fields:
                                 ;
                                 ; b 	bytes		1..4 b bytes		2
                                 ; s 	sign		0(unsigned), 1(signed)	1
                                 ; i		integer digits	
                                 ; e 	base		2,,36			5
                                 ; dp 	dec. point	0..32			5
                                 ; $if	i=integer digits,  0=all digits,  1..15 digits 
                                 ;		f=fraction digits, 0=no fraction, 1..15 digits
                                 ;
                                 ; Formatting characters must be followed by an SRAM address (0..ff)
                                 ; FBIN,	sram
                                 ; FHEX,	sram
                                 ; FDEC,	sram
                                 ; FCHAR,sram
                                 ; FSTR,	sram
                                 ;
                                 ; The address 'sram' is a 1-byte constant. It addresses
                                 ; 	 0..1f	registers r0..r31, 
                                 ; 	20..3f	i/o ports, (need to be addressed with an offset of $20)
                                 ;	60..ff	SRAM registers (warning: extended i/o in AVR128)
                                 
                                 ; The FFRAC formatting character must be followed by 
                                 ;	ONE sram address and 
                                 ;	TWO more formatting characters
                                 ; FFRAC,sram,dp,$if
                                 
                                 ; dp	decimal point position, 0=right, 32=left
                                 ; $if	format i.f, i=integer digits, f=fraction digits
                                 
                                 ; The special formatting characters use the following coding
                                 ;
                                 ; FDEC	11bb'iiis	i=0 all digits, i=1-7 digits
                                 ; FBIN	101i'iiis	i=0 8 digits,	i=1-7 digits
                                 ; FHEX	1001'iiis	i=0 8 digits,	i=1-7 digits
                                 ; FFRAC	1000'1bbs
                                 ; FCHAR	1000'0100
                                 ; FSTR	1000'0101
                                 ; FREP	1000'0110
                                 ; FFUNC	1000'0111
                                 ;	1000'0010
                                 ;	1000'0011
                                 ; FESC	1000'0000
                                 
                                 ; examples
                                 ; formatting string			printing
                                 ; "a=",FDEC,a,0				1-byte variable a, unsigned decimal
                                 ; "a=",FDEC2,a,0			2-byte variable a (a1,a0), unsigend
                                 ; "a=",FDEC|FSIGN,a,0		1-byte variable 1, signed decimal
                                 ; "n=",FBIN,PIND+$20,0		i/o port, binary, notice offset of $20
                                 ; "f=",FFRAC4|FSIGN,a,16,$88,0	4-byte signed fixed-point fraction
                                 ;				dec.point at 16, 8 int.digits, 8 frac.digits	
                                 ; "f=",FFRAC2,a,16,$18,0		2-byte unsigned fixed-point fraction
                                 ;				dec.point at 16, 1 int.digits, 8 frac.digits	
                                 ; "a=",FDEC|FDIG5|FSIGN,a,0	1-byte variable, 5-digit, decimal, signed
                                 ; "a=",FDEC|FDIG5,a,0		1-byte variable, 5-digit, decimal, unsigned
                                 
                                 ; === registers modified ===
                                 ; e0,e1	used to transmit address of putc routine
                                 ; zh,zl	used as pointer to prog-memory
                                 
                                 ; === constants ==============================================
                                 
                                 .equ	FDEC	= 0b11000000	; 1-byte variable
                                 .equ	FDEC2	= 0b11010000	; 2-byte variable
                                 .equ	FDEC3	= 0b11100000	; 3-byte variable
                                 .equ	FDEC4	= 0b11110000	; 4-byte variable
                                 
                                 .equ	FBIN	= 0b10100000
                                 .equ	FHEX	= 0b10010100	; 1-byte variable
                                 .equ	FHEX2	= 0b10011000	; 2-byte variable
                                 .equ	FHEX3	= 0b10011100	; 3-byte variable
                                 .equ	FHEX4	= 0b10010000	; 4-byte variable
                                 
                                 .equ	FFRAC	= 0b10001000	; 1-byte variable
                                 .equ	FFRAC2	= 0b10001010	; 2-byte variable
                                 .equ	FFRAC3	= 0b10001100	; 3-byte variable
                                 .equ	FFRAC4	= 0b10001110	; 4-byte variable
                                 
                                 .equ	FCHAR	= 0b10000100
                                 .equ	FSTR	= 0b10000101
                                 
                                 .equ	FSIGN	= 0b00000001
                                 
                                 .equ	FDIG1	= 1<<1
                                 .equ	FDIG2	= 2<<1
                                 .equ	FDIG3	= 3<<1	
                                 .equ	FDIG4	= 4<<1
                                 .equ	FDIG5	= 5<<1
                                 .equ	FDIG6	= 6<<1
                                 .equ	FDIG7	= 7<<1
                                 
                                 ; ===macro ====================================================
                                 
                                 .macro	PRINTF			; putc function (UART, LCD...)
                                 	ldi	w, low(@0)		; address of "putc" in e1:d0
                                 	mov	e0,w
                                 	ldi	w,high(@0)
                                 	mov	e1,w
                                 	rcall	_printf
                                 	.endmacro
                                 
                                 ; mod	y,z
                                 
                                 
                                 ; === routines ================================================
                                 
                                 _printf:
00000a 91ff
00000b 91ef                      	POPZ			; z points to begin of "string"
00000c 0fee
00000d 1fff                      	MUL2Z			; multiply Z by two, (word ptr -> byte ptr)
00000e 93af
00000f 93bf                      	PUSHX
                                 		
                                 _printf_read:
000010 95c8                      	lpm				; places prog_mem(Z) into r0 (=c)
000011 9631                      	adiw	zl,1	; increment pointer Z
000012 2000                      	tst	r0			; test for ZERO (=end of string)
000013 f021                      	breq	_printf_end	; char=0 indicates end of ascii string
000014 f04a                      	brmi	_printf_formatted ; bit7=1 indicates formatting character
000015 2d00                      	mov	w,r0
000016 d013                      	rcall	_putw	; display the character
000017 cff8                      	rjmp	_printf_read	; read next character in the string
                                 	
                                 _printf_end:
000018 9631                      	adiw	zl,1	; point to the next character
000019 95f6
00001a 95e7                      	DIV2Z			; divide by 2 (byte ptr -> word ptr)
00001b 91bf
00001c 91af                      	POPX
00001d 9409                      	ijmp			; return to instruction after "string"
                                 
                                 _printf_formatted:
                                 
                                 ; FDEC	11bb'iiis
                                 ; FBIN	101i'iiis
                                 ; FHEX	1001'iiis
                                 ; FFRAC	1000'1bbs
                                 ; FCHAR	1000'0100
                                 ; FSTR	1000'0101
                                 
00001e fa00                      	bst	r0,0		; store sign in T
00001f 2d00                      	mov	w,r0		; store formatting character in w
                                 
000020 95c8                      	lpm	
000021 2da0                      	mov	xl,r0		; load x-pointer with SRAM address
000022 27bb                      	clr	xh			; clear high-byte
000023 9631                       	adiw	zl,1	; increment pointer Z
                                 
                                 ;	JB1	w,6,_putdec
                                 ;	JB1	w,5,_putbin
                                 ;	JB1	w,4,_puthex
                                 ;	JB1	w,3,_putfrac
000024 3804
000025 f079                      	JK	w,FCHAR,_putchar
000026 3805
000027 f081                      	JK	w,FSTR ,_putstr
000028 c015                      	rjmp	_putnum
                                 	
000029 cfe6                      	rjmp	_printf_read	
                                 
                                 ; === putc (put character) ===============================
                                 ; in	w	character to put
                                 ;	e1,e0	address of output routine (UART, LCD putc)
                                 _putw:
00002a 932f
00002b 93ff
00002c 93ef                      	PUSH3	a0,zh,zl
00002d 2de4
00002e 2df5
00002f 2f20                      	MOV3	a0,zh,zl, w,e1,e0
000030 9509                      	icall			; indirect call to "putc"
000031 91ef
000032 91ff
000033 912f                      	POP3	a0,zh,zl
000034 9508                      	ret
                                 
                                 ; === putchar (put character) ============================
                                 ; in	x	pointer to character to put
                                 _putchar:
000035 910c                      	ld	w,x
000036 dff3                      	rcall	_putw
000037 cfd8                      	rjmp	_printf_read
                                 	
                                 ; === putstr (put string) ================================
                                 ; in	x	pointer to ascii string
                                 ;	b3,b2	address of output routine (UART, LCD putc)
                                 _putstr:
000038 910d                      	ld	w,x+
000039 2300                      	tst	w
00003a f409                      	brne	PC+2
00003b cfd4                      	rjmp	_printf_read
00003c dfed                      	rcall	_putw
00003d cffa                      	rjmp	_putstr
                                 
                                 ; === putnum (dec/bin/hex/frac) ===========================
                                 ; in	x	pointer to SRAM variable to print
                                 ; 	r0	formatting character
                                 	
                                 _putnum:
00003e 935f
00003f 934f
000040 933f
000041 932f                      	PUSH4	a3,a2,a1,a0	; safeguard a
000042 939f
000043 938f
000044 937f
000045 936f                      	PUSH4	b3,b2,b1,b0	; safeguard b	
000046 912d
000047 913d
000048 914d
000049 915d                      	LDX4	a3,a2,a1,a0	; load operand to print into a
                                 
                                 ; FDEC	11bb'iiis
                                 ; FBIN	101i'iiis
                                 ; FHEX	1001'iiis
                                 ; FRACT	1000'1bbs
                                 
00004a fd06
00004b c006                      	JB1	w,6,_putdec
00004c fd05
00004d c00f                      	JB1	w,5,_putbin
00004e fd04
00004f c010                      	JB1	w,4,_puthex
000050 fd03
000051 c019                      	JB1	w,3,_putfrac
                                 
                                 ; FDEC	11bb'iiis
                                 _putdec:
000052 e06a                      	ldi	b0,10		; b0 = base (10)
                                 
000053 2f70                      	mov	b1,w
000054 9576                      	lsr	b1
000055 7077                      	andi	b1,0b111	
000056 9572                      	swap	b1		; b1 = format 0iii'0000 (integer digits)
000057 e080                      	ldi	b2,0		; b2 = dec. point position = 0 (right)
                                 	
000058 2f90                      	mov	b3,w
000059 9592                      	swap	b3
00005a 7093                      	andi	b3,0b11
00005b 9593                      	inc	b3			; b3 = number of bytes (1..4)
00005c c01a                      	rjmp	_getnum	; get number of digits (iii)
                                 
                                 ; FBIN	101i'iiis	addr
                                 _putbin:	
00005d e062                      	ldi	b0,2		; b0 = base (2)
00005e e094                      	ldi	b3,4		; b3 = number of bytes (4)	
00005f c003                      	rjmp	_getdig	; get number of digits (iii)
                                 
                                 ; FHEX	1001'iiis	addr
                                 _puthex:	
000060 e160                      	ldi	b0,16		; b0 = base (16)
000061 e094                      	ldi	b3,4		; b3 = number of bytes (4)
000062 c000                      	rjmp	_getdig
                                 
                                 _getdig:
000063 2f70                      	mov	b1,w
000064 9576                      	lsr	b1
000065 7077                      	andi	b1,0b111
000066 f409                      	brne	PC+2
000067 e078                      	ldi	b1,8		; if b1=0 then 8-digits
000068 9572                      	swap	b1		; b1 = format 0iii'0000 (integer digits)
000069 e080                      	ldi	b2, 0		; b2 = dec. point position = 0 (right)
00006a c00c                      	rjmp	_getnum
                                 
                                 ; FFRAC	1000'1bbs	addr	 00dd'dddd, 	iiii'ffff
                                 	
                                 _putfrac:
00006b e06a                      	ldi	b0,10		; base=10	
00006c 95c8                      	lpm
00006d 2d80                      	mov	b2,r0		; load dec.point position
00006e 9631                      	adiw	zl,1	; increment char pointer
00006f 95c8                      	lpm
000070 2d70                      	mov	b1,r0		; load ii.ff format
000071 9631                      	adiw	zl,1	; increment char pointer
                                 	
000072 2f90                      	mov	b3,w
000073 9595                      	asr	b3
000074 7093                      	andi	b3,0b11
000075 9593                      	inc	b3			; b3 = number of bytes (1..4)
                                 
000076 c000                      	rjmp	_getnum
                                 
                                 _getnum:
                                 ; in 	a	4-byte variable
                                 ; 	b3	number of bytes (1..4)
                                 ;	T	sign, 0=unsigned, 1=signed
                                 
000077 3094
000078 f081                      	JK	b3,4,_printf_4b
000079 3093
00007a f051                      	JK	b3,3,_printf_3b
00007b 3092
00007c f021                      	JK	b3,2,_printf_2b	
                                 	
                                 _printf_1b:			; sign extension
00007d 2733                      	clr	a1
00007e f416                      	brtc	PC+3	; T=1 sign extension
00007f fd27                      	sbrc	a0,7
000080 ef3f                      	ldi	a1,0xff
                                 _printf_2b:
000081 2744                      	clr	a2
000082 f416                      	brtc	PC+3	; T=1 sign extension	
000083 fd37                      	sbrc	a1,7
000084 ef4f                      	ldi	a2,0xff
                                 _printf_3b:	
000085 2755                      	clr	a3
000086 f416                      	brtc	PC+3	; T=1 sign extension
000087 fd47                      	sbrc	a2,7
000088 ef5f                      	ldi	a3,0xff
                                 _printf_4b:
                                 
000089 d009                      	rcall	_ftoa		; float to ascii
00008a 916f
00008b 917f
00008c 918f
00008d 919f                      	POP4	b3,b2,b1,b0	; restore b
00008e 912f
00008f 913f
000090 914f
000091 915f                      	POP4	a3,a2,a1,a0	; restore a
                                 	
000092 cf7d                      	rjmp	_printf_read
                                 
                                 ; ===============================================
                                 ; func	ftoa
                                 ; converts a fixed-point fractional number to an ascii string
                                 ; author (c) Raphael Holzer
                                 ;
                                 ; in	a3-a0	variable to print
                                 ;	b0	base, 2 to 36, but usually decimal (10)
                                 ;	b1	number of digits to print ii.ff
                                 ; 	b2	position of the decimal point (0=right, 32=left)
                                 ;	T	sign (T=0 unsiged, T=1 signed)
                                 
                                 _ftoa:
000093 92cf                      	push	d0
000094 92bf
000095 92af
000096 929f
000097 928f                      	PUSH4	c3,c2,c1,c0	; c = fraction part, a = integer part
000098 18bb
000099 24aa
00009a 2499
00009b 2488                      	CLR4	c3,c2,c1,c0	; clear fraction part
                                 
00009c f486                      	brtc	_ftoa_plus	; if T=0 then unsigned
00009d 94e8                      	clt
00009e 2355                      	tst	a3				; if MSb(a)=1 then a=-a
00009f f46a                      	brpl	_ftoa_plus
0000a0 9468                      	set					; T=1 (minus)
0000a1 2377                      	tst	b1
0000a2 f009                      	breq	PC+2		; if b1=0 the print ALL digits
0000a3 5170                      	subi	b1,0x10		; decrease int digits
0000a4 9550
0000a5 9540
0000a6 9530
0000a7 9520
0000a8 ef0f
0000a9 1b20
0000aa 0b30
0000ab 0b40
0000ac 0b50                      	NEG4	a3,a2,a1,a0	; negate a
                                 _ftoa_plus:	
0000ad 2388                      	tst	b2				; b0=0 (only integer part)
0000ae f051                      	breq	_ftoa_int	
                                 _ftoa_shift:	
0000af 9555
0000b0 9547
0000b1 9537
0000b2 9527                      	ASR4	a3,a2,a1,a0	; a = integer part	
0000b3 94b7
0000b4 94a7
0000b5 9497
0000b6 9487                      	ROR4	c3,c2,c1,c0	; c = fraction part
0000b7 958a
0000b8 f7b1                      	DJNZ	b2,_ftoa_shift
                                 _ftoa_int:
0000b9 937f                      	push	b1			; ii.ff (ii=int digits)
0000ba 9572                      	swap	b1
0000bb 707f                      	andi	b1,0x0f
                                 	
0000bc e20e                      	ldi	w,'.'			; push decimal point
0000bd 930f                      	push	w
                                 _ftoa_int1:
0000be d045                      	rcall	_div41		; int=int/10
0000bf 2d0c                      	mov	w,d0			; d=reminder
0000c0 d030                      	rcall	_hex2asc
0000c1 930f                      	push	w			; push rem(int/10)
0000c2 2700
0000c3 1720
0000c4 0730
0000c5 0740
0000c6 0750                      	TST4	a3,a2,a1,a0	; (int/10)=?
0000c7 f029                      	breq	_ftoa_space	; (int/10)=0 then finished
0000c8 2377                      	tst	b1
0000c9 f3a1                      	breq	_ftoa_int1	; if b1=0 then print ALL int-digits
0000ca 957a
0000cb f791                      	DJNZ	b1,_ftoa_int1
0000cc c007                      	rjmp	_ftoa_sign
                                 _ftoa_space:
0000cd 2377                      	tst	b1				; if b1=0 then print ALL int-digits
0000ce f029                      	breq	_ftoa_sign
0000cf 957a                      	dec	b1
0000d0 f019                      	breq	_ftoa_sign
0000d1 e200                      	ldi	w,' '			; write spaces
0000d2 df57                      	rcall	_putw	
0000d3 cff9                      	rjmp	_ftoa_space
                                 _ftoa_sign:
0000d4 f416                      	brtc	PC+3		; if T=1 then write 'minus'
0000d5 e20d                      	ldi	w,'-'
0000d6 df53                      	rcall	_putw
                                 _ftoa_int3:
0000d7 910f                      	pop	w
0000d8 320e                      	cpi	w,'.'
0000d9 f011                      	breq	PC+3
0000da df4f                      	rcall	_putw
0000db cffb                      	rjmp	_ftoa_int3
                                 
0000dc 917f                      	pop	b1				; ii.ff (ff=frac digits)
0000dd 707f                      	andi	b1,0x0f
0000de 2377                      	tst	b1
0000df f059                      	breq	_ftoa_end
                                 _ftoa_point:	
0000e0 df49                      	rcall	_putw		; write decimal point
0000e1 2d28
0000e2 2d39
0000e3 2d4a
0000e4 2d5b                      	MOV4	a3,a2,a1,a0, c3,c2,c1,c0		
                                 _ftoa_frac:
0000e5 d011                      	rcall	_mul41		; d.frac=10*frac
0000e6 2d0c                      	mov	w,d0
0000e7 d009                      	rcall	_hex2asc
0000e8 df41                      	rcall	_putw
0000e9 957a
0000ea f7d1                      	DJNZ	b1,_ftoa_frac
                                 _ftoa_end:
0000eb 908f
0000ec 909f
0000ed 90af
0000ee 90bf                      	POP4	c3,c2,c1,c0
0000ef 90cf                      	pop	d0
0000f0 9508                      	ret
                                 
                                 ; === hexadecimal to ascii ===
                                 ; in	w
                                 _hex2asc:
0000f1 300a                      	cpi	w,10
0000f2 f410                      	brsh	PC+3
0000f3 5d00                      	addi	w,'0'
0000f4 9508                      	ret
0000f5 5a09                      	addi	w,('a'-10)
0000f6 9508                      	ret
                                 
                                 ; === multiply 4byte*1byte ===
                                 ; funct mul41
                                 ; multiplies a3-a0 (4-byte) by b0 (1-byte)
                                 ; author (c) Raphael Holzer, EPFL
                                 ; 
                                 ; in	a3..a0	multiplicand (argument to multiply)
                                 ;	b0	multiplier
                                 ; out	a3..a0	result
                                 ; 	d0	result MSB (byte 4)
                                 ;
0000f7 24cc                      _mul41:	clr	d0			; clear byte4 of result
0000f8 e200                      	ldi	w,32			; load bit counter
0000f9 9488                      __m41:	clc				; clear carry
0000fa fd20                      	sbrc	a0,0		; skip addition if LSB=0
0000fb 0ec6                      	add	d0,b0			; add b to MSB of a
0000fc 94c7
0000fd 9557
0000fe 9547
0000ff 9537
000100 9527                      	ROR5	d0,a3,a2,a1,a0	; shift-right c, LSB (of b) into carry
000101 950a
000102 f7b1                      	DJNZ	w,__m41		; Decrement and Jump if bit-count Not Zero
000103 9508                      	ret
                                 
                                 ; === divide 4byte/1byte ===
                                 ; func div41
                                 ; in	a0..a3 	divident (argument to divide)
                                 ;	b0 	divider
                                 ; out	a0..a3 	result 
                                 ;	d0	reminder
                                 ;
000104 24cc                      _div41:	clr	d0			; d will contain the remainder
000105 e200                      	ldi	w,32			; load bit counter
000106 1f22
000107 1f33
000108 1f44
000109 1f55
00010a 1ccc                      __d41:	ROL5	d0,a3,a2,a1,a0	; shift carry into result c
00010b 1ac6                      	sub	d0, b0			; subtract b from remainder
00010c f408                      	brcc	PC+2	
00010d 0ec6                      	add	d0, b0			; restore if remainder became negative
00010e 950a
00010f f7b1                      	DJNZ	w,__d41		; Decrement and Jump if bit-count Not Zero
000110 1f22
000111 1f33
000112 1f44
000113 1f55                      	ROL4	a3,a2,a1,a0	; last shift (carry into result c)
000114 9550
000115 9540
000116 9530
000117 9520                      	COM4	a3,a2,a1,a0	; complement result
000118 9508                      	ret
                                 .include "string.asm"
                                 
                                 ; AssemblerApplication1.asm
                                 ;
                                 ; Created: 30/04/2024 10:34:37
                                 ; Author : renuka
                                 ; File containing all strings to 
                                 ; print on LCD screen
                                 
                                 
                                 .cseg
                                 
                                 ; Menu of game
                                 str0:
000119 4557
00011a 434c
00011b 4d4f
00011c 2045
00011d 4f54
00011e 0020                      .db "WELCOME TO ", 0
                                 str1:
00011f 434d
000120 2055
000121 4150
000122 5452
000123 0059                      .db "MCU PARTY", 0
                                 str2:
000124 2e31
000125 5020
000126 414c
000127 2059
000128 4147
000129 454d
C:\Users\renuka\Desktop\mcu\projet\MCU\AssemblerApplication1\AssemblerApplication1\string.asm(18): warning: .cseg .db misalignment - padding zero byte
C:\Users\renuka\Desktop\mcu\projet\MCU\AssemblerApplication1\AssemblerApplication1\main.asm(24): 'C:\Users\renuka\Desktop\mcu\projet\MCU\AssemblerApplication1\AssemblerApplication1\string.asm' included form here
00012a 0000                      .db "1. PLAY GAME", 0
                                 str3:
00012b 2e32
00012c 4f20
00012d 4550
00012e 204e
00012f 4153
000130 4546
C:\Users\renuka\Desktop\mcu\projet\MCU\AssemblerApplication1\AssemblerApplication1\string.asm(20): warning: .cseg .db misalignment - padding zero byte
C:\Users\renuka\Desktop\mcu\projet\MCU\AssemblerApplication1\AssemblerApplication1\main.asm(24): 'C:\Users\renuka\Desktop\mcu\projet\MCU\AssemblerApplication1\AssemblerApplication1\string.asm' included form here
000131 0000                      .db "2. OPEN SAFE", 0
                                 
                                 ; general
                                 strwelcome:
000132 6557
000133 636c
000134 6d6f
000135 2065
000136 6f74
C:\Users\renuka\Desktop\mcu\projet\MCU\AssemblerApplication1\AssemblerApplication1\string.asm(24): warning: .cseg .db misalignment - padding zero byte
C:\Users\renuka\Desktop\mcu\projet\MCU\AssemblerApplication1\AssemblerApplication1\main.asm(24): 'C:\Users\renuka\Desktop\mcu\projet\MCU\AssemblerApplication1\AssemblerApplication1\string.asm' included form here
000137 0000                      .db "Welcome to",0
                                 
                                 strivia:
000138 7274
000139 7669
00013a 6169
00013b 3a20
00013c 0029                      .db "trivia :)",0
                                 
                                 strbutton:
00013d 6874
00013e 2065
00013f 7562
000140 7474
000141 6e6f
000142 3a20
000143 0029                      .db "the button :)",0
                                 
                                 strcorrect:
000144 6f43
000145 7272
000146 6365
000147 2174
C:\Users\renuka\Desktop\mcu\projet\MCU\AssemblerApplication1\AssemblerApplication1\string.asm(33): warning: .cseg .db misalignment - padding zero byte
C:\Users\renuka\Desktop\mcu\projet\MCU\AssemblerApplication1\AssemblerApplication1\main.asm(24): 'C:\Users\renuka\Desktop\mcu\projet\MCU\AssemblerApplication1\AssemblerApplication1\string.asm' included form here
000148 0000                      .db "Correct!",0
                                 
                                 strfalse:
000149 6146
00014a 736c
00014b 2165
C:\Users\renuka\Desktop\mcu\projet\MCU\AssemblerApplication1\AssemblerApplication1\string.asm(36): warning: .cseg .db misalignment - padding zero byte
C:\Users\renuka\Desktop\mcu\projet\MCU\AssemblerApplication1\AssemblerApplication1\main.asm(24): 'C:\Users\renuka\Desktop\mcu\projet\MCU\AssemblerApplication1\AssemblerApplication1\string.asm' included form here
00014c 0000                      .db "False!",0
                                 
                                 ; Choose games
                                 str4:
00014d 2e31
00014e 5420
00014f 4952
000150 4956
000151 2041
000152 5551
000153 5a49
C:\Users\renuka\Desktop\mcu\projet\MCU\AssemblerApplication1\AssemblerApplication1\string.asm(40): warning: .cseg .db misalignment - padding zero byte
C:\Users\renuka\Desktop\mcu\projet\MCU\AssemblerApplication1\AssemblerApplication1\main.asm(24): 'C:\Users\renuka\Desktop\mcu\projet\MCU\AssemblerApplication1\AssemblerApplication1\string.asm' included form here
000154 0000                      .db "1. TRIVIA QUIZ", 0
                                 str5:
000155 2e32
000156 4220
000157 5455
000158 4f54
000159 204e
00015a 4144
00015b 434e
00015c 0045                      .db "2. BUTTON DANCE", 0
                                 
                                 ; Open safe
                                 str6:
00015d 4e45
00015e 4554
00015f 2052
000160 4150
000161 5353
000162 4f43
000163 4544
C:\Users\renuka\Desktop\mcu\projet\MCU\AssemblerApplication1\AssemblerApplication1\string.asm(46): warning: .cseg .db misalignment - padding zero byte
C:\Users\renuka\Desktop\mcu\projet\MCU\AssemblerApplication1\AssemblerApplication1\main.asm(24): 'C:\Users\renuka\Desktop\mcu\projet\MCU\AssemblerApplication1\AssemblerApplication1\string.asm' included form here
000164 0000                      .db "ENTER PASSCODE", 0
                                 str7:
000165 4e49
000166 4f43
000167 5252
000168 4345
000169 2054
00016a 4150
00016b 5353
00016c 4f43
00016d 4544
C:\Users\renuka\Desktop\mcu\projet\MCU\AssemblerApplication1\AssemblerApplication1\string.asm(48): warning: .cseg .db misalignment - padding zero byte
C:\Users\renuka\Desktop\mcu\projet\MCU\AssemblerApplication1\AssemblerApplication1\main.asm(24): 'C:\Users\renuka\Desktop\mcu\projet\MCU\AssemblerApplication1\AssemblerApplication1\string.asm' included form here
00016e 0000                      .db "INCORRECT PASSCODE", 0
                                 str8:
00016f 4f43
000170 474e
000171 4152
000172 5554
000173 414c
000174 4954
000175 4e4f
000176 2c53
000177 0020                      .db "CONGRATULATIONS, ", 0
                                 str9:
000178 4f59
000179 2055
00017a 4957
00017b 204e
00017c 4854
00017d 5349
00017e 4720
00017f 4d41
000180 2045
000181 0021                      .db "YOU WIN THIS GAME !", 0
                                 str10:
000182 4854
000183 4e41
000184 534b
000185 4620
000186 524f
C:\Users\renuka\Desktop\mcu\projet\MCU\AssemblerApplication1\AssemblerApplication1\string.asm(54): warning: .cseg .db misalignment - padding zero byte
C:\Users\renuka\Desktop\mcu\projet\MCU\AssemblerApplication1\AssemblerApplication1\main.asm(24): 'C:\Users\renuka\Desktop\mcu\projet\MCU\AssemblerApplication1\AssemblerApplication1\string.asm' included form here
000187 0000                      .db "THANKS FOR", 0
                                 str11:
000188 4c50
000189 5941
00018a 4e49
00018b 2147
00018c 3a20
00018d 0044                      .db "PLAYING! :D", 0
                                 
                                 ; Quiz trivia
                                 ; Question 1
                                 striviaQ1:
00018e 6857
00018f 206f
000190 7277
000191 746f
000192 2065
000193 6874
000194 0065                      .db "Who wrote the", 0
                                 striviaQ12:
000195 6f73
000196 676e
000197 2720
000198 6874
000199 6972
00019a 6c6c
00019b 7265
00019c 3f27
C:\Users\renuka\Desktop\mcu\projet\MCU\AssemblerApplication1\AssemblerApplication1\string.asm(63): warning: .cseg .db misalignment - padding zero byte
C:\Users\renuka\Desktop\mcu\projet\MCU\AssemblerApplication1\AssemblerApplication1\main.asm(24): 'C:\Users\renuka\Desktop\mcu\projet\MCU\AssemblerApplication1\AssemblerApplication1\string.asm' included form here
00019d 0000                      .db "song 'thriller'?", 0
                                 strivia1A:
00019e 2e41
00019f 4d20
0001a0 202e
0001a1 414a
0001a2 4b43
0001a3 4f53
0001a4 004e                      .db "A. M. JACKSON", 0
                                 strivia1B:
0001a5 2e42
0001a6 5420
0001a7 4152
0001a8 5943
0001a9 4320
0001aa 4148
0001ab 4d50
0001ac 4e41
C:\Users\renuka\Desktop\mcu\projet\MCU\AssemblerApplication1\AssemblerApplication1\string.asm(67): warning: .cseg .db misalignment - padding zero byte
C:\Users\renuka\Desktop\mcu\projet\MCU\AssemblerApplication1\AssemblerApplication1\main.asm(24): 'C:\Users\renuka\Desktop\mcu\projet\MCU\AssemblerApplication1\AssemblerApplication1\string.asm' included form here
0001ad 0000                      .db "B. TRACY CHAPMAN", 0
                                 strivia1C:
0001ae 2e43
0001af 4120
0001b0 202e
0001b1 4353
0001b2 4d48
0001b3 4449
C:\Users\renuka\Desktop\mcu\projet\MCU\AssemblerApplication1\AssemblerApplication1\string.asm(69): warning: .cseg .db misalignment - padding zero byte
C:\Users\renuka\Desktop\mcu\projet\MCU\AssemblerApplication1\AssemblerApplication1\main.asm(24): 'C:\Users\renuka\Desktop\mcu\projet\MCU\AssemblerApplication1\AssemblerApplication1\string.asm' included form here
0001b4 0000                      .db "C. A. SCHMID", 0
                                 strivia1D:
0001b5 2e44
0001b6 4320
0001b7 4548
0001b8 0052                      .db "D. CHER", 0
                                 answer1:
C:\Users\renuka\Desktop\mcu\projet\MCU\AssemblerApplication1\AssemblerApplication1\string.asm(73): warning: .cseg .db misalignment - padding zero byte
C:\Users\renuka\Desktop\mcu\projet\MCU\AssemblerApplication1\AssemblerApplication1\main.asm(24): 'C:\Users\renuka\Desktop\mcu\projet\MCU\AssemblerApplication1\AssemblerApplication1\string.asm' included form here
0001b9 00fd                      .db 0xfd
                                 
                                 ; Question 2
                                 striviaQ2:
0001ba 6857
0001bb 206f
0001bc 6c70
0001bd 7961
0001be 0073                      .db "Who plays", 0
                                 striviaQ22:
0001bf 6548
0001c0 6d72
0001c1 6f69
0001c2 656e
0001c3 003f                      .db "Hermione?", 0
                                 strivia2A:
0001c4 2e41
0001c5 4520
0001c6 4d4d
0001c7 2041
0001c8 4157
0001c9 5354
0001ca 4e4f
C:\Users\renuka\Desktop\mcu\projet\MCU\AssemblerApplication1\AssemblerApplication1\string.asm(81): warning: .cseg .db misalignment - padding zero byte
C:\Users\renuka\Desktop\mcu\projet\MCU\AssemblerApplication1\AssemblerApplication1\main.asm(24): 'C:\Users\renuka\Desktop\mcu\projet\MCU\AssemblerApplication1\AssemblerApplication1\string.asm' included form here
0001cb 0000                      .db "A. EMMA WATSON", 0
                                 strivia2B:
0001cc 2e42
0001cd 4520
0001ce 4d4d
0001cf 2041
0001d0 5453
0001d1 4e4f
0001d2 0045                      .db "B. EMMA STONE", 0
                                 strivia2C:
0001d3 2e43
0001d4 4120
0001d5 594d
0001d6 4120
0001d7 4144
0001d8 534d
C:\Users\renuka\Desktop\mcu\projet\MCU\AssemblerApplication1\AssemblerApplication1\string.asm(85): warning: .cseg .db misalignment - padding zero byte
C:\Users\renuka\Desktop\mcu\projet\MCU\AssemblerApplication1\AssemblerApplication1\main.asm(24): 'C:\Users\renuka\Desktop\mcu\projet\MCU\AssemblerApplication1\AssemblerApplication1\string.asm' included form here
0001d9 0000                      .db "C. AMY ADAMS", 0
                                 strivia2D:
0001da 2e44
0001db 5a20
0001dc 454f
0001dd 5320
0001de 4c41
0001df 4144
0001e0 414e
C:\Users\renuka\Desktop\mcu\projet\MCU\AssemblerApplication1\AssemblerApplication1\string.asm(87): warning: .cseg .db misalignment - padding zero byte
C:\Users\renuka\Desktop\mcu\projet\MCU\AssemblerApplication1\AssemblerApplication1\main.asm(24): 'C:\Users\renuka\Desktop\mcu\projet\MCU\AssemblerApplication1\AssemblerApplication1\string.asm' included form here
0001e1 0000                      .db "D. ZOE SALDANA", 0
                                 answer2:
C:\Users\renuka\Desktop\mcu\projet\MCU\AssemblerApplication1\AssemblerApplication1\string.asm(89): warning: .cseg .db misalignment - padding zero byte
C:\Users\renuka\Desktop\mcu\projet\MCU\AssemblerApplication1\AssemblerApplication1\main.asm(24): 'C:\Users\renuka\Desktop\mcu\projet\MCU\AssemblerApplication1\AssemblerApplication1\string.asm' included form here
0001e2 00fd                      .db 0xfd
                                 
                                 ; Question 3
                                 striviaQ3:
0001e3 6857
0001e4 6369
0001e5 2068
0001e6 6162
0001e7 646e
0001e8 7720
0001e9 6f72
0001ea 6574
C:\Users\renuka\Desktop\mcu\projet\MCU\AssemblerApplication1\AssemblerApplication1\string.asm(93): warning: .cseg .db misalignment - padding zero byte
C:\Users\renuka\Desktop\mcu\projet\MCU\AssemblerApplication1\AssemblerApplication1\main.asm(24): 'C:\Users\renuka\Desktop\mcu\projet\MCU\AssemblerApplication1\AssemblerApplication1\string.asm' included form here
0001eb 0000                      .db "Which band wrote", 0
                                 striviaQ32:
0001ec 6827
0001ed 7965
0001ee 7920
0001ef 756f
0001f0 2027
0001f1 003f                      .db "'hey you' ?", 0
                                 strivia3A:
0001f2 2e41
0001f3 5320
0001f4 4950
0001f5 4543
0001f6 4720
0001f7 5249
0001f8 534c
C:\Users\renuka\Desktop\mcu\projet\MCU\AssemblerApplication1\AssemblerApplication1\string.asm(97): warning: .cseg .db misalignment - padding zero byte
C:\Users\renuka\Desktop\mcu\projet\MCU\AssemblerApplication1\AssemblerApplication1\main.asm(24): 'C:\Users\renuka\Desktop\mcu\projet\MCU\AssemblerApplication1\AssemblerApplication1\string.asm' included form here
0001f9 0000                      .db "A. SPICE GIRLS", 0
                                 strivia3B:
0001fa 2e42
0001fb 4c20
0001fc 4445
0001fd 5a20
0001fe 5045
0001ff 4c50
000200 4e49
C:\Users\renuka\Desktop\mcu\projet\MCU\AssemblerApplication1\AssemblerApplication1\string.asm(99): warning: .cseg .db misalignment - padding zero byte
C:\Users\renuka\Desktop\mcu\projet\MCU\AssemblerApplication1\AssemblerApplication1\main.asm(24): 'C:\Users\renuka\Desktop\mcu\projet\MCU\AssemblerApplication1\AssemblerApplication1\string.asm' included form here
000201 0000                      .db "B. LED ZEPPLIN", 0
                                 strivia3C:
000202 2e43
000203 4a20
000204 554f
000205 4e52
000206 5945
C:\Users\renuka\Desktop\mcu\projet\MCU\AssemblerApplication1\AssemblerApplication1\string.asm(101): warning: .cseg .db misalignment - padding zero byte
C:\Users\renuka\Desktop\mcu\projet\MCU\AssemblerApplication1\AssemblerApplication1\main.asm(24): 'C:\Users\renuka\Desktop\mcu\projet\MCU\AssemblerApplication1\AssemblerApplication1\string.asm' included form here
000207 0000                      .db "C. JOURNEY", 0
                                 strivia3D:
000208 2e44
000209 5020
00020a 4e49
00020b 204b
00020c 4c46
00020d 594f
00020e 0044                      .db "D. PINK FLOYD", 0
                                 answer3:
C:\Users\renuka\Desktop\mcu\projet\MCU\AssemblerApplication1\AssemblerApplication1\string.asm(105): warning: .cseg .db misalignment - padding zero byte
C:\Users\renuka\Desktop\mcu\projet\MCU\AssemblerApplication1\AssemblerApplication1\main.asm(24): 'C:\Users\renuka\Desktop\mcu\projet\MCU\AssemblerApplication1\AssemblerApplication1\string.asm' included form here
00020f 00ef                      .db 0xef
                                 
                                 ; Question 4
                                 striviaQ4:
000210 6857
000211 206f
000212 7277
000213 746f
000214 2065
000215 4127
000216 7269
C:\Users\renuka\Desktop\mcu\projet\MCU\AssemblerApplication1\AssemblerApplication1\string.asm(109): warning: .cseg .db misalignment - padding zero byte
C:\Users\renuka\Desktop\mcu\projet\MCU\AssemblerApplication1\AssemblerApplication1\main.asm(24): 'C:\Users\renuka\Desktop\mcu\projet\MCU\AssemblerApplication1\AssemblerApplication1\string.asm' included form here
000217 0000                      .db "Who wrote 'Air", 0
                                 striviaQ42:
000218 6e6f
000219 4720
00021a 7320
00021b 7274
00021c 6e69
00021d 2767
00021e 003f                      .db "on G string'?", 0
                                 strivia4A:
00021f 2e41
000220 5020
000221 414c
000222 4259
000223 494f
000224 4320
000225 5241
000226 4954
C:\Users\renuka\Desktop\mcu\projet\MCU\AssemblerApplication1\AssemblerApplication1\string.asm(113): warning: .cseg .db misalignment - padding zero byte
C:\Users\renuka\Desktop\mcu\projet\MCU\AssemblerApplication1\AssemblerApplication1\main.asm(24): 'C:\Users\renuka\Desktop\mcu\projet\MCU\AssemblerApplication1\AssemblerApplication1\string.asm' included form here
000227 0000                      .db "A. PLAYBOI CARTI", 0
                                 strivia4B:
000228 2e42
000229 4220
00022a 4545
00022b 4854
00022c 564f
00022d 4e45
C:\Users\renuka\Desktop\mcu\projet\MCU\AssemblerApplication1\AssemblerApplication1\string.asm(115): warning: .cseg .db misalignment - padding zero byte
C:\Users\renuka\Desktop\mcu\projet\MCU\AssemblerApplication1\AssemblerApplication1\main.asm(24): 'C:\Users\renuka\Desktop\mcu\projet\MCU\AssemblerApplication1\AssemblerApplication1\string.asm' included form here
00022e 0000                      .db "B. BEETHOVEN", 0
                                 strivia4C:
00022f 2e43
000230 5320
000231 4843
000232 4255
000233 5245
000234 0054                      .db "C. SCHUBERT", 0
                                 strivia4D:
000235 2e44
000236 4a20
000237 532e
000238 202e
000239 4142
00023a 4843
C:\Users\renuka\Desktop\mcu\projet\MCU\AssemblerApplication1\AssemblerApplication1\string.asm(119): warning: .cseg .db misalignment - padding zero byte
C:\Users\renuka\Desktop\mcu\projet\MCU\AssemblerApplication1\AssemblerApplication1\main.asm(24): 'C:\Users\renuka\Desktop\mcu\projet\MCU\AssemblerApplication1\AssemblerApplication1\string.asm' included form here
00023b 0000                      .db "D. J.S. BACH", 0
                                 answer4:
C:\Users\renuka\Desktop\mcu\projet\MCU\AssemblerApplication1\AssemblerApplication1\string.asm(121): warning: .cseg .db misalignment - padding zero byte
C:\Users\renuka\Desktop\mcu\projet\MCU\AssemblerApplication1\AssemblerApplication1\main.asm(24): 'C:\Users\renuka\Desktop\mcu\projet\MCU\AssemblerApplication1\AssemblerApplication1\string.asm' included form here
00023c 00ef                      .db 0xef
                                 
                                 
                                 .include "lcd.asm"
                                 
                                 ; purpose  LCD HD44780U library
                                 ; ATmega 128 and Atmel Studio 7.0 compliant
                                 
                                 ; === definitions ===
                                 .equ	LCD_IR	= 0x8000	; address LCD instruction reg
                                 .equ	LCD_DR	= 0xc000	; address LCD data register
                                 
                                 ; === subroutines ===
                                 LCD_wr_ir:
                                 ; in	w (byte to write to LCD IR)
00023d 9030 8000                 	lds	u, LCD_IR		; read IR to check busy flag  (bit7)
00023f fc37
000240 cffc                      	JB1	u,7,LCD_wr_ir	; Jump if Bit=1 (still busy)
000241 d003                      	rcall	lcd_4us		; delay to increment DRAM addr counter
000242 9300 8000                 	sts	LCD_IR, w		; store w in IR
000244 9508                      	ret
                                 	
                                 lcd_4us:
000245 d000                      	rcall	lcd_2us		; recursive call		
                                 lcd_2us:
000246 0000                      	nop					; rcall(3) + nop(1) + ret(4) = 8 cycles (2us)
000247 9508                      	ret
                                 
                                 LCD:
                                 LCD_putc:
000248 302d
000249 f179                      	JK	a0,CR,LCD_cr	; Jump if a0=CR
00024a 302a
00024b f1b9                      	JK	a0,LF,LCD_lf	; Jump if a0=LF
                                 LCD_wr_dr:
                                 ; in	a0 (byte to write to LCD DR)
00024c 9100 8000                 	lds	w, LCD_IR		; read IR to check busy flag  (bit7)
00024e fd07
00024f cffc                      	JB1	w,7,LCD_wr_dr	; Jump if Bit=1 (still busy)
000250 dff4                      	rcall	lcd_4us		; delay to increment DRAM addr counter
000251 9320 c000                 	sts	LCD_DR, a0		; store a0 in DR
000253 9508                      	ret	
                                 	
000254 e001
000255 cfe7                      LCD_clear:		JW	LCD_wr_ir, 0b00000001		; clear display
000256 e002
000257 cfe5                      LCD_home:		JW	LCD_wr_ir, 0b00000010		; return home
000258 e100
000259 cfe3                      LCD_cursor_left:	JW	LCD_wr_ir, 0b00010000	; move cursor to left
00025a e104
00025b cfe1                      LCD_cursor_right:	JW	LCD_wr_ir, 0b00010100	; move cursor to right
00025c e108
00025d cfdf                      LCD_display_left:	JW	LCD_wr_ir, 0b00011000	; shifts display to left
00025e e10c
00025f cfdd                      LCD_display_right:	JW	LCD_wr_ir, 0b00011100	; shifts display to right
000260 e00d
000261 cfdb                      LCD_blink_on:		JW	LCD_wr_ir, 0b00001101	; Display=1,Cursor=0,Blink=1
000262 e00c
000263 cfd9                      LCD_blink_off:		JW	LCD_wr_ir, 0b00001100	; Display=1,Cursor=0,Blink=0
000264 e00e
000265 cfd7                      LCD_cursor_on:		JW	LCD_wr_ir, 0b00001110	; Display=1,Cursor=1,Blink=0
000266 e00c
000267 cfd5                      LCD_cursor_off:		JW	LCD_wr_ir, 0b00001100	; Display=1,Cursor=0,Blink=0
000268 e00f
000269 cfd3                      LCD_cursorblink: 	JW	LCD_wr_ir, 0b00001111	; Display=1,Cursor=1,Blink=1	
                                 LCD_init:
00026a b705                      	in	w,MCUCR					; enable access to ext. SRAM
00026b 6c00                      	sbr	w,(1<<SRE)+(1<<SRW10)
00026c bf05                      	out	MCUCR,w
00026d e001
00026e dfce                      	CW	LCD_wr_ir, 0b00000001	; clear display
00026f e006
000270 dfcc                      	CW	LCD_wr_ir, 0b00000110	; entry mode set (Inc=1, Shift=0)
000271 e00c
000272 dfca                      	CW	LCD_wr_ir, 0b00001100	; Display=1,Cursor=0,Blink=0	
000273 e308
000274 dfc8                      	CW	LCD_wr_ir, 0b00111000	; 8bits=1, 2lines=1, 5x8dots=0
000275 9508                      	ret
                                 
                                 LCD_pos:
                                 ; in	a0 = position (0x00..0x0f first line, 0x40..0x4f second line)
000276 2f02                      	mov	w,a0
000277 6800                      	ori	w,0b10000000
000278 cfc4                      	rjmp	LCD_wr_ir
                                 
                                 LCD_cr:
                                 ; moving the cursor to the beginning of the line (carriage return)
000279 9100 8000                 	lds	w, LCD_IR			; read IR to check busy flag  (bit7)
00027b fd07
00027c cffc                      	JB1	w,7,LCD_cr			; Jump if Bit=1 (still busy)
00027d 7400                      	andi	w,0b01000000	; keep bit6 (begin of line 1/2)
00027e 6800                      	ori	w,0b10000000		; write address command
00027f dfc5                      	rcall	lcd_4us			; delay to increment DRAM addr counter
000280 9300 8000                 	sts	LCD_IR,w			; store in IR
000282 9508                      	ret
                                 
                                 LCD_lf:
                                 ; moving the cursor to the beginning of the line 2 (line feed)
000283 932f                      	push	a0				; safeguard a0
000284 e420                      	ldi	a0,$40				; load position $40 (begin of line 2)
000285 dff0                      	rcall	LCD_pos			; set cursor position
000286 912f                      	pop	a0					; restore a0
                                 .include "display.asm"
000287 9508                      
                                  * display.asm
                                  *
                                  *  Created: 30/04/2024 11:39:40
                                  *   Author: renuka
                                  */ 
                                 
                                 .macro DISPLAY1 
                                 
                                 	call	LCD_init
                                 	ldi	zl, low(2*@0)
                                 	ldi	zh, high(2*@0)
                                 	call	LCD_putstring
                                 
                                 .endmacro
                                 
                                 .macro DISPLAY2
                                 
                                 	call	LCD_init
                                 	ldi	zl, low(2*@0)
                                 	ldi	zh, high(2*@0)
                                 	call	LCD_putstring
                                 	ldi	zl, low(2*@1)
                                 	ldi	zh, high(2*@1)
                                 	ldi	a0, 0x40
                                 	call	LCD_pos
                                 	call	LCD_putstring
                                 
                                 .endmacro
                                 .include "subroutines.asm"
                                 
                                  * subroutines.asm
                                  *
                                  *  Created: 30/04/2024 11:21:07
                                  *   Author: renuka
                                  */ 
                                 
                                 ; code from: tp05 puts02.asm
                                  LCD_putstring:
000288 95c8                      	lpm
000289 2000                      	tst		r0
00028a f021                      	breq	done
00028b 2d20                      	mov		a0, r0
00028c dfbb                      	rcall	LCD_putc
00028d 9631                      	adiw	zl, 1
00028e cff9                      	rjmp	LCD_putstring
00028f 9508                      done:ret
                                 
                                 
                                 /*
                                 putdec:
                                 	mov u, a0
                                 	ldi a0, '0'-1
                                 	ldi w, 100
                                 _putdec2:
                                 	inc a0
                                 	sub u, w
                                 	brsh _putdec2
                                 	add u,w
                                 	rcall LCD_putc
                                 
                                 	ldi a0, '0'-1
                                 	ldi w, 10
                                 _putdec1:
                                 	inc a0
                                 	sub u, w
                                 	brsh _putdec1
                                 	add u, w
                                 	rcall LCD_putc
                                 	ldi a0, '0'
                                 	add a0, u
                                 	rcall LCD_putc
                                 	ldi a0, '0'
                                 	add a0, u
                                 	rcall LCD_putc
                                 	ret
                                 */
                                 
                                 .macro QUESTION ; question: str0, str1 answer: str2, str3, str4, str5
                                 question_start:
                                 	DISPLAY2 @0, @1 ; display question
                                 	WAIT_MS 2000
                                 	;rjmp check_button
                                 	in b0, PIND
                                 	out PORTB, b0 
                                 	sbrs b0, 4
                                 	rjmp question_end
                                 	sbrs b0, 3
                                 	rjmp question_end
                                 	sbrs b0, 2
                                 	rjmp question_end
                                 	sbrs b0, 1
                                 	rjmp question_end
                                 	DISPLAY2 @2, @3
                                 	;rjmp check_button
                                 	in b0, PIND
                                 	out PORTB, b0 
                                 	sbrs b0, 4
                                 	rjmp question_end
                                 	sbrs b0, 3
                                 	rjmp question_end
                                 	sbrs b0, 2
                                 	rjmp question_end
                                 	sbrs b0, 1
                                 	rjmp question_end
                                 	WAIT_MS 2000
                                 	;rjmp check_button
                                 	in b0, PIND
                                 	out PORTB, b0 
                                 	sbrs b0, 4
                                 	rjmp question_end
                                 	sbrs b0, 3
                                 	rjmp question_end
                                 	sbrs b0, 2
                                 	rjmp question_end
                                 	sbrs b0, 1
                                 	rjmp question_end
                                 	DISPLAY2 @4, @5
                                 	WAIT_MS 2000
                                 	;rjmp check_button
                                 	in b0, PIND
                                 	out PORTB, b0 
                                 	sbrs b0, 4
                                 	rjmp question_end
                                 	sbrs b0, 3
                                 	rjmp question_end
                                 	sbrs b0, 2
                                 	rjmp question_end
                                 	sbrs b0, 1
                                 	rjmp question_end
                                 	rjmp question_start
                                 question_end:
                                 .endmacro
                                 
                                 .macro COMPARE
                                 	ldi zl, low(2*@0)
                                 	ldi zh, high(2*@0)
                                 	lpm
                                 	cp b0, r0
                                 	brne PC+2
                                 	set
                                 .endmacro
                                 
                                 .macro PRINT_SCORE
                                 	rcall LCD_clear
                                 	brts PC+2
                                 	rjmp incorrect
                                 correct:
                                 	DISPLAY1 strcorrect
                                 	rjmp score
                                 incorrect:
                                 	DISPLAY1 strfalse
                                 score:
                                 	CLR4 a3, a2, a1, a0
                                 	mov a0, @0
                                 	PRINTF LCD
                                 .db "Score: ",FDEC,a,0
                                 .endmacro
                                 
                                 main:
000290 dfc3                      	rcall	LCD_clear
000291 940e 026a
000293 e3e2
000294 e0f2
000295 940e 0288
000297 e3ee
000298 e0f2
000299 e420
00029a 940e 0276
00029c 940e 0288                 	DISPLAY2 str0, str1
00029e ed00
00029f 2e30
0002a0 e008
0002a1 930f
0002a2 923f
0002a3 e300
0002a4 2e30
0002a5 e006
0002a6 943a
0002a7 f7f1
0002a8 943a
0002a9 950a
0002aa f7d9
0002ab 903f
0002ac 910f
0002ad 943a
0002ae f791
0002af 950a
0002b0 f781                      	WAIT_MS 2000
                                 
                                 main_loop:
0002b1 d009                      	rcall start
0002b2 ff62
0002b3 d397                      	CB0 b0,2, safe ; call subroutine safe if PD1 pressed
0002b4 ff61
0002b5 d01b                      	CB0 b0,1, games ; call subroutine games if PD0 pressed
0002b6 ff61
0002b7 d042                      	CB0 b0,1, trivia
0002b8 ff62
0002b9 d36f                      	CB0 b0,2, dance
0002ba cff6                      	rjmp main_loop
                                 
                                 start:
0002bb 940e 026a
0002bd e4e8
0002be e0f2
0002bf 940e 0288
0002c1 e5e6
0002c2 e0f2
0002c3 e420
0002c4 940e 0276
0002c6 940e 0288                 	DISPLAY2 str2, str3
0002c8 d398                      	rcall check_button
0002c9 b360                      	in b0, PIND ; b0=r22
0002ca bb68                      	out PORTB, b0
0002cb 3f6d                      	cpi b0, 0xfd
0002cc f011                      	breq PC+3
0002cd 3f6b                      	cpi b0, 0xfb
0002ce f409                      	brne PC+2
0002cf 9508                      	ret
0002d0 cfea                      	rjmp start
                                 
                                 games:
0002d1 940e 026a
0002d3 e9ea
0002d4 e0f2
0002d5 940e 0288
0002d7 eaea
0002d8 e0f2
0002d9 e420
0002da 940e 0276
0002dc 940e 0288                 	DISPLAY2 str4, str5
0002de d382                      	rcall check_button
0002df ee08
0002e0 2e30
0002e1 e004
0002e2 930f
0002e3 923f
0002e4 e300
0002e5 2e30
0002e6 e006
0002e7 943a
0002e8 f7f1
0002e9 943a
0002ea 950a
0002eb f7d9
0002ec 903f
0002ed 910f
0002ee 943a
0002ef f791
0002f0 950a
0002f1 f781                      	WAIT_MS 1000
0002f2 b360                      	in b0, PIND
0002f3 bb68                      	out PORTB, b0
0002f4 3f6d                      	cpi b0, 0xfd
0002f5 f011                      	breq PC+3
0002f6 3f6b                      	cpi b0, 0xfb
0002f7 f409                      	brne PC+2
0002f8 9508                      	ret
0002f9 cfd7                      	rjmp games
                                 
                                 trivia:
0002fa 940e 026a
0002fc e6e4
0002fd e0f2
0002fe 940e 0288
000300 e7e0
000301 e0f2
000302 e420
000303 940e 0276
000305 940e 0288                 	DISPLAY2 strwelcome, strivia
000307 d359                      	rcall check_button
000308 ed00
000309 2e30
00030a e008
00030b 930f
00030c 923f
00030d e300
00030e 2e30
00030f e006
000310 943a
000311 f7f1
000312 943a
000313 950a
000314 f7d9
000315 903f
000316 910f
000317 943a
000318 f791
000319 950a
00031a f781                      	WAIT_MS 2000
00031b e070                      	ldi b1, 0x00
00031c 940e 026a
00031e e1ec
00031f e0f3
000320 940e 0288
000322 e2ea
000323 e0f3
000324 e420
000325 940e 0276
000327 940e 0288
000329 ed00
00032a 2e30
00032b e008
00032c 930f
00032d 923f
00032e e300
00032f 2e30
000330 e006
000331 943a
000332 f7f1
000333 943a
000334 950a
000335 f7d9
000336 903f
000337 910f
000338 943a
000339 f791
00033a 950a
00033b f781
00033c b360
00033d bb68
00033e ff64
00033f c065
000340 ff63
000341 c063
000342 ff62
000343 c061
000344 ff61
000345 c05f
000346 940e 026a
000348 e3ec
000349 e0f3
00034a 940e 0288
00034c e4ea
00034d e0f3
00034e e420
00034f 940e 0276
000351 940e 0288
000353 b360
000354 bb68
000355 ff64
000356 c04e
000357 ff63
000358 c04c
000359 ff62
00035a c04a
00035b ff61
00035c c048
00035d ed00
00035e 2e30
00035f e008
000360 930f
000361 923f
000362 e300
000363 2e30
000364 e006
000365 943a
000366 f7f1
000367 943a
000368 950a
000369 f7d9
00036a 903f
00036b 910f
00036c 943a
00036d f791
00036e 950a
00036f f781
000370 b360
000371 bb68
000372 ff64
000373 c031
000374 ff63
000375 c02f
000376 ff62
000377 c02d
000378 ff61
000379 c02b
00037a 940e 026a
00037c e5ec
00037d e0f3
00037e 940e 0288
000380 e6ea
000381 e0f3
000382 e420
000383 940e 0276
000385 940e 0288
000387 ed00
000388 2e30
000389 e008
00038a 930f
00038b 923f
00038c e300
00038d 2e30
00038e e006
00038f 943a
000390 f7f1
000391 943a
000392 950a
000393 f7d9
000394 903f
000395 910f
000396 943a
000397 f791
000398 950a
000399 f781
00039a b360
00039b bb68
00039c ff64
00039d c007
00039e ff63
00039f c005
0003a0 ff62
0003a1 c003
0003a2 ff61
0003a3 c001
0003a4 cf77                      	QUESTION striviaQ1, striviaQ12, strivia1A, strivia1B, strivia1C, strivia1D
0003a5 e7e2
0003a6 e0f3
0003a7 95c8
0003a8 1560
0003a9 f409
0003aa 9468                      	COMPARE answer1
0003ab f40e                      	brtc PC+2
0003ac 9573                      	inc b1
0003ad dea6
0003ae f00e
0003af c007
0003b0 940e 026a
0003b2 e8e8
0003b3 e0f2
0003b4 940e 0288
0003b6 c006
0003b7 940e 026a
0003b9 e9e2
0003ba e0f2
0003bb 940e 0288
0003bd 1b55
0003be 2744
0003bf 2733
0003c0 2722
0003c1 2f27
0003c2 e408
0003c3 2e40
0003c4 e002
0003c5 2e50
0003c6 dc43
0003c7 6353
0003c8 726f
0003c9 3a65
0003ca c020
0003cb 0012                      	PRINT_SCORE b1
0003cc ed00
0003cd 2e30
0003ce e008
0003cf 930f
0003d0 923f
0003d1 e300
0003d2 2e30
0003d3 e006
0003d4 943a
0003d5 f7f1
0003d6 943a
0003d7 950a
0003d8 f7d9
0003d9 903f
0003da 910f
0003db 943a
0003dc f791
0003dd 950a
0003de f781                      	WAIT_MS 2000
0003df 940e 026a
0003e1 e7e4
0003e2 e0f3
0003e3 940e 0288
0003e5 e7ee
0003e6 e0f3
0003e7 e420
0003e8 940e 0276
0003ea 940e 0288
0003ec ed00
0003ed 2e30
0003ee e008
0003ef 930f
0003f0 923f
0003f1 e300
0003f2 2e30
0003f3 e006
0003f4 943a
0003f5 f7f1
0003f6 943a
0003f7 950a
0003f8 f7d9
0003f9 903f
0003fa 910f
0003fb 943a
0003fc f791
0003fd 950a
0003fe f781
0003ff b360
000400 bb68
000401 ff64
000402 c065
000403 ff63
000404 c063
000405 ff62
000406 c061
000407 ff61
000408 c05f
000409 940e 026a
00040b e8e8
00040c e0f3
00040d 940e 0288
00040f e9e8
000410 e0f3
000411 e420
000412 940e 0276
000414 940e 0288
000416 b360
000417 bb68
000418 ff64
000419 c04e
00041a ff63
00041b c04c
00041c ff62
00041d c04a
00041e ff61
00041f c048
000420 ed00
000421 2e30
000422 e008
000423 930f
000424 923f
000425 e300
000426 2e30
000427 e006
000428 943a
000429 f7f1
00042a 943a
00042b 950a
00042c f7d9
00042d 903f
00042e 910f
00042f 943a
000430 f791
000431 950a
000432 f781
000433 b360
000434 bb68
000435 ff64
000436 c031
000437 ff63
000438 c02f
000439 ff62
00043a c02d
00043b ff61
00043c c02b
00043d 940e 026a
00043f eae6
000440 e0f3
000441 940e 0288
000443 ebe4
000444 e0f3
000445 e420
000446 940e 0276
000448 940e 0288
00044a ed00
00044b 2e30
00044c e008
00044d 930f
00044e 923f
00044f e300
000450 2e30
000451 e006
000452 943a
000453 f7f1
000454 943a
000455 950a
000456 f7d9
000457 903f
000458 910f
000459 943a
00045a f791
00045b 950a
00045c f781
00045d b360
00045e bb68
00045f ff64
000460 c007
000461 ff63
000462 c005
000463 ff62
000464 c003
000465 ff61
000466 c001
000467 cf77                      	QUESTION striviaQ2, striviaQ22, strivia2A, strivia2B, strivia2C, strivia2D
000468 ece4
000469 e0f3
00046a 95c8
00046b 1560
00046c f409
00046d 9468                      	COMPARE answer2
00046e f40e                      	brtc PC+2
00046f 9573                      	inc b1
000470 dde3
000471 f00e
000472 c007
000473 940e 026a
000475 e8e8
000476 e0f2
000477 940e 0288
000479 c006
00047a 940e 026a
00047c e9e2
00047d e0f2
00047e 940e 0288
000480 1b55
000481 2744
000482 2733
000483 2722
000484 2f27
000485 e408
000486 2e40
000487 e002
000488 2e50
000489 db80
00048a 6353
00048b 726f
00048c 3a65
00048d c020
00048e 0012                      	PRINT_SCORE b1
00048f ed00
000490 2e30
000491 e008
000492 930f
000493 923f
000494 e300
000495 2e30
000496 e006
000497 943a
000498 f7f1
000499 943a
00049a 950a
00049b f7d9
00049c 903f
00049d 910f
00049e 943a
00049f f791
0004a0 950a
0004a1 f781                      	WAIT_MS 2000
0004a2 940e 026a
0004a4 ece6
0004a5 e0f3
0004a6 940e 0288
0004a8 ede8
0004a9 e0f3
0004aa e420
0004ab 940e 0276
0004ad 940e 0288
0004af ed00
0004b0 2e30
0004b1 e008
0004b2 930f
0004b3 923f
0004b4 e300
0004b5 2e30
0004b6 e006
0004b7 943a
0004b8 f7f1
0004b9 943a
0004ba 950a
0004bb f7d9
0004bc 903f
0004bd 910f
0004be 943a
0004bf f791
0004c0 950a
0004c1 f781
0004c2 b360
0004c3 bb68
0004c4 ff64
0004c5 c065
0004c6 ff63
0004c7 c063
0004c8 ff62
0004c9 c061
0004ca ff61
0004cb c05f
0004cc 940e 026a
0004ce eee4
0004cf e0f3
0004d0 940e 0288
0004d2 efe4
0004d3 e0f3
0004d4 e420
0004d5 940e 0276
0004d7 940e 0288
0004d9 b360
0004da bb68
0004db ff64
0004dc c04e
0004dd ff63
0004de c04c
0004df ff62
0004e0 c04a
0004e1 ff61
0004e2 c048
0004e3 ed00
0004e4 2e30
0004e5 e008
0004e6 930f
0004e7 923f
0004e8 e300
0004e9 2e30
0004ea e006
0004eb 943a
0004ec f7f1
0004ed 943a
0004ee 950a
0004ef f7d9
0004f0 903f
0004f1 910f
0004f2 943a
0004f3 f791
0004f4 950a
0004f5 f781
0004f6 b360
0004f7 bb68
0004f8 ff64
0004f9 c031
0004fa ff63
0004fb c02f
0004fc ff62
0004fd c02d
0004fe ff61
0004ff c02b
000500 940e 026a
000502 e0e4
000503 e0f4
000504 940e 0288
000506 e1e0
000507 e0f4
000508 e420
000509 940e 0276
00050b 940e 0288
00050d ed00
00050e 2e30
00050f e008
000510 930f
000511 923f
000512 e300
000513 2e30
000514 e006
000515 943a
000516 f7f1
000517 943a
000518 950a
000519 f7d9
00051a 903f
00051b 910f
00051c 943a
00051d f791
00051e 950a
00051f f781
000520 b360
000521 bb68
000522 ff64
000523 c007
000524 ff63
000525 c005
000526 ff62
000527 c003
000528 ff61
000529 c001
00052a cf77                      	QUESTION striviaQ3, striviaQ32, strivia3A, strivia3B, strivia3C, strivia3D
00052b e1ee
00052c e0f4
00052d 95c8
00052e 1560
00052f f409
000530 9468                      	COMPARE answer3
000531 f40e                      	brtc PC+2
000532 9573                      	inc b1
000533 dd20
000534 f00e
000535 c007
000536 940e 026a
000538 e8e8
000539 e0f2
00053a 940e 0288
00053c c006
00053d 940e 026a
00053f e9e2
000540 e0f2
000541 940e 0288
000543 1b55
000544 2744
000545 2733
000546 2722
000547 2f27
000548 e408
000549 2e40
00054a e002
00054b 2e50
00054c dabd
00054d 6353
00054e 726f
00054f 3a65
000550 c020
000551 0012                      	PRINT_SCORE b1
000552 ed00
000553 2e30
000554 e008
000555 930f
000556 923f
000557 e300
000558 2e30
000559 e006
00055a 943a
00055b f7f1
00055c 943a
00055d 950a
00055e f7d9
00055f 903f
000560 910f
000561 943a
000562 f791
000563 950a
000564 f781                      	WAIT_MS 2000
000565 940e 026a
000567 e2e0
000568 e0f4
000569 940e 0288
00056b e3e0
00056c e0f4
00056d e420
00056e 940e 0276
000570 940e 0288
000572 ed00
000573 2e30
000574 e008
000575 930f
000576 923f
000577 e300
000578 2e30
000579 e006
00057a 943a
00057b f7f1
00057c 943a
00057d 950a
00057e f7d9
00057f 903f
000580 910f
000581 943a
000582 f791
000583 950a
000584 f781
000585 b360
000586 bb68
000587 ff64
000588 c065
000589 ff63
00058a c063
00058b ff62
00058c c061
00058d ff61
00058e c05f
00058f 940e 026a
000591 e3ee
000592 e0f4
000593 940e 0288
000595 e5e0
000596 e0f4
000597 e420
000598 940e 0276
00059a 940e 0288
00059c b360
00059d bb68
00059e ff64
00059f c04e
0005a0 ff63
0005a1 c04c
0005a2 ff62
0005a3 c04a
0005a4 ff61
0005a5 c048
0005a6 ed00
0005a7 2e30
0005a8 e008
0005a9 930f
0005aa 923f
0005ab e300
0005ac 2e30
0005ad e006
0005ae 943a
0005af f7f1
0005b0 943a
0005b1 950a
0005b2 f7d9
0005b3 903f
0005b4 910f
0005b5 943a
0005b6 f791
0005b7 950a
0005b8 f781
0005b9 b360
0005ba bb68
0005bb ff64
0005bc c031
0005bd ff63
0005be c02f
0005bf ff62
0005c0 c02d
0005c1 ff61
0005c2 c02b
0005c3 940e 026a
0005c5 e5ee
0005c6 e0f4
0005c7 940e 0288
0005c9 e6ea
0005ca e0f4
0005cb e420
0005cc 940e 0276
0005ce 940e 0288
0005d0 ed00
0005d1 2e30
0005d2 e008
0005d3 930f
0005d4 923f
0005d5 e300
0005d6 2e30
0005d7 e006
0005d8 943a
0005d9 f7f1
0005da 943a
0005db 950a
0005dc f7d9
0005dd 903f
0005de 910f
0005df 943a
0005e0 f791
0005e1 950a
0005e2 f781
0005e3 b360
0005e4 bb68
0005e5 ff64
0005e6 c007
0005e7 ff63
0005e8 c005
0005e9 ff62
0005ea c003
0005eb ff61
0005ec c001
0005ed cf77                      	QUESTION striviaQ4, striviaQ42, strivia4A, strivia4B, strivia4C, strivia4D
0005ee e7e8
0005ef e0f4
0005f0 95c8
0005f1 1560
0005f2 f409
0005f3 9468                      	COMPARE answer4
0005f4 f40e                      	brtc PC+2
0005f5 9573                      	inc b1
0005f6 dc5d
0005f7 f00e
0005f8 c007
0005f9 940e 026a
0005fb e8e8
0005fc e0f2
0005fd 940e 0288
0005ff c006
000600 940e 026a
000602 e9e2
000603 e0f2
000604 940e 0288
000606 1b55
000607 2744
000608 2733
000609 2722
00060a 2f27
00060b e408
00060c 2e40
00060d e002
00060e 2e50
00060f d9fa
000610 6353
000611 726f
000612 3a65
000613 c020
000614 0012                      	PRINT_SCORE b1
000615 ed00
000616 2e30
000617 e008
000618 930f
000619 923f
00061a e300
00061b 2e30
00061c e006
00061d 943a
00061e f7f1
00061f 943a
000620 950a
000621 f7d9
000622 903f
000623 910f
000624 943a
000625 f791
000626 950a
000627 f781                      	WAIT_MS 2000
                                 	;rjmp main_loop
000628 ccd1                      	rjmp trivia
                                 
                                 dance:
000629 940e 026a
00062b e6e4
00062c e0f2
00062d 940e 0288
00062f e7ea
000630 e0f2
000631 e420
000632 940e 0276
000634 940e 0288                 	DISPLAY2 strwelcome, strbutton
000636 d02a                      	rcall check_button
000637 ed00
000638 2e30
000639 e008
00063a 930f
00063b 923f
00063c e300
00063d 2e30
00063e e006
00063f 943a
000640 f7f1
000641 943a
000642 950a
000643 f7d9
000644 903f
000645 910f
000646 943a
000647 f791
000648 950a
000649 f781                      	WAIT_MS 2000
00064a cc66                      	rjmp main_loop
                                 
                                 
                                 safe:
00064b 940e 026a
00064d ebea
00064e e0f2
00064f 940e 0288                 	DISPLAY1 str6
000651 c000                      	rjmp end
                                 
                                 
                                 end:
000652 d00e                      	rcall check_button
000653 940e 026a
000655 e0e4
000656 e0f3
000657 940e 0288
000659 e1e0
00065a e0f3
00065b e420
00065c 940e 0276
00065e 940e 0288                 	DISPLAY2 str10, str11
000660 cff1                      	rjmp end
                                 
                                 
                                 check_button:
000661 b360                      	in b0, PIND
000662 ff67                      	sbrs b0, 7 ; Check if PIND7 is pressed
000663 c99c                      	rjmp reset
000664 9508                      	ret
                                 
                                 


RESOURCE USE INFORMATION
------------------------

Notice:
The register and instruction counts are symbol table hit counts,
and hence implicitly used resources are not counted, eg, the
'lpm' instruction without operands implicitly uses r0 and z,
none of which are counted.

x,y,z are separate entities in the symbol table and are
counted separately from r26..r31 here.

.dseg memory usage only counts static data declared with .byte

"ATmega128" register use summary:
x  :   6 y  :   0 z  :   0 r0 :  13 r1 :   0 r2 :   0 r3 : 142 r4 :   5 
r5 :   5 r6 :   0 r7 :   0 r8 :   5 r9 :   5 r10:   5 r11:   6 r12:  11 
r13:   0 r14:   0 r15:   0 r16: 294 r17:   0 r18:  51 r19:  19 r20:  19 
r21:  23 r22: 123 r23:  34 r24:   7 r25:  15 r26:   3 r27:   3 r28:   0 
r29:   0 r30:  61 r31:  55 
Registers used: 23 out of 35 (65.7%)

"ATmega128" instruction use summary:
.lds  :   0 .sts  :   0 adc   :   0 add   :   2 adiw  :   6 and   :   0 
andi  :   7 asr   :   2 bclr  :   0 bld   :   0 brbc  :   0 brbs  :   0 
brcc  :   1 brcs  :   0 break :   0 breq  :  19 brge  :   0 brhc  :   0 
brhs  :   0 brid  :   0 brie  :   0 brlo  :   0 brlt  :   0 brmi  :   1 
brne  :  93 brpl  :   1 brsh  :   1 brtc  :   9 brts  :   4 brvc  :   0 
brvs  :   0 bset  :   0 bst   :   1 call  :  90 cbi   :   0 cbr   :   0 
clc   :   1 clh   :   0 cli   :   0 cln   :   0 clr   :  22 cls   :   0 
clt   :   1 clv   :   0 clz   :   0 com   :   8 cp    :   5 cpc   :   3 
cpi   :  13 cpse  :   0 dec   : 106 elpm  :   0 eor   :   0 fmul  :   0 
fmuls :   0 fmulsu:   0 icall :   1 ijmp  :   1 in    :  20 inc   :   6 
jmp   :   0 ld    :   6 ldd   :   0 ldi   : 243 lds   :   3 lpm   :  27 
lsl   :   1 lsr   :   3 mov   :  72 movw  :   0 mul   :   0 muls  :   0 
mulsu :   0 neg   :   0 nop   :   1 or    :   0 ori   :   2 out   :  23 
pop   :  63 push  :  62 rcall :  43 ret   :  16 reti  :   0 rjmp  : 120 
rol   :  10 ror   :  13 sbc   :   3 sbci  :   0 sbi   :   0 sbic  :   0 
sbis  :   0 sbiw  :   0 sbr   :   1 sbrc  :  11 sbrs  :  69 sec   :   0 
seh   :   0 sei   :   0 sen   :   0 ser   :   0 ses   :   0 set   :   5 
sev   :   0 sez   :   0 sleep :   0 spm   :   0 st    :   0 std   :   0 
sts   :   3 sub   :   7 subi  :   3 swap  :   4 tst   :   9 wdr   :   0 

Instructions used: 53 out of 114 (46.5%)

"ATmega128" memory use summary [bytes]:
Segment   Begin    End      Code   Data   Used    Size   Use%
---------------------------------------------------------------
[.cseg] 0x000000 0x000cca   2650    624   3274  131072   2.5%
[.dseg] 0x000100 0x000100      0      0      0    4096   0.0%
[.eseg] 0x000000 0x000000      0      0      0    4096   0.0%

Assembly complete, 0 errors, 27 warnings
