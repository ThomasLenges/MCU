
AVRASM ver. 2.2.6  C:\Users\renuka\Desktop\projet\MCU\AssemblerApplication1\AssemblerApplication1\mainbis.asm Fri May 24 16:39:57 2024

[builtin](2): Including file 'C:/Program Files (x86)\Atmel\Studio\7.0\Packs\atmel\ATmega_DFP\1.1.130\avrasm\inc\m128def.inc'
C:\Users\renuka\Desktop\projet\MCU\AssemblerApplication1\AssemblerApplication1\mainbis.asm(1): Including file 'C:\Users\renuka\Desktop\projet\MCU\AssemblerApplication1\AssemblerApplication1\definitions.asm'
C:\Users\renuka\Desktop\projet\MCU\AssemblerApplication1\AssemblerApplication1\mainbis.asm(2): Including file 'C:\Users\renuka\Desktop\projet\MCU\AssemblerApplication1\AssemblerApplication1\macros.asm'
C:\Users\renuka\Desktop\projet\MCU\AssemblerApplication1\AssemblerApplication1\mainbis.asm(3): Including file 'C:/Program Files (x86)\Atmel\Studio\7.0\Packs\atmel\ATmega_DFP\1.1.130\avrasm\inc\m128def.inc'
C:\Users\renuka\Desktop\projet\MCU\AssemblerApplication1\AssemblerApplication1\mainbis.asm(12): warning: Register r2 already defined by the .DEF directive
C:\Users\renuka\Desktop\projet\MCU\AssemblerApplication1\AssemblerApplication1\mainbis.asm(13): warning: Register r1 already defined by the .DEF directive
C:\Users\renuka\Desktop\projet\MCU\AssemblerApplication1\AssemblerApplication1\mainbis.asm(14): warning: Register r14 already defined by the .DEF directive
C:\Users\renuka\Desktop\projet\MCU\AssemblerApplication1\AssemblerApplication1\mainbis.asm(15): warning: Register r15 already defined by the .DEF directive
C:\Users\renuka\Desktop\projet\MCU\AssemblerApplication1\AssemblerApplication1\mainbis.asm(100): Including file 'C:\Users\renuka\Desktop\projet\MCU\AssemblerApplication1\AssemblerApplication1\kpd4x4bis.asm'
C:\Users\renuka\Desktop\projet\MCU\AssemblerApplication1\AssemblerApplication1\mainbis.asm(101): Including file 'C:\Users\renuka\Desktop\projet\MCU\AssemblerApplication1\AssemblerApplication1\lcd.asm'
C:\Users\renuka\Desktop\projet\MCU\AssemblerApplication1\AssemblerApplication1\mainbis.asm(102): Including file 'C:\Users\renuka\Desktop\projet\MCU\AssemblerApplication1\AssemblerApplication1\string.asm'
C:\Users\renuka\Desktop\projet\MCU\AssemblerApplication1\AssemblerApplication1\mainbis.asm(103): Including file 'C:\Users\renuka\Desktop\projet\MCU\AssemblerApplication1\AssemblerApplication1\subroutines.asm'
C:\Users\renuka\Desktop\projet\MCU\AssemblerApplication1\AssemblerApplication1\mainbis.asm(104): Including file 'C:\Users\renuka\Desktop\projet\MCU\AssemblerApplication1\AssemblerApplication1\printf.asm'
[builtin](2): Including file 'C:/Program Files (x86)\Atmel\Studio\7.0\Packs\atmel\ATmega_DFP\1.1.130\avrasm\inc\m128def.inc'
C:\Users\renuka\Desktop\projet\MCU\AssemblerApplication1\AssemblerApplication1\mainbis.asm(1): Including file 'C:\Users\renuka\Desktop\projet\MCU\AssemblerApplication1\AssemblerApplication1\definitions.asm'
C:\Users\renuka\Desktop\projet\MCU\AssemblerApplication1\AssemblerApplication1\mainbis.asm(2): Including file 'C:\Users\renuka\Desktop\projet\MCU\AssemblerApplication1\AssemblerApplication1\macros.asm'
C:\Users\renuka\Desktop\projet\MCU\AssemblerApplication1\AssemblerApplication1\mainbis.asm(3): Including file 'C:/Program Files (x86)\Atmel\Studio\7.0\Packs\atmel\ATmega_DFP\1.1.130\avrasm\inc\m128def.inc'
C:\Users\renuka\Desktop\projet\MCU\AssemblerApplication1\AssemblerApplication1\mainbis.asm(100): Including file 'C:\Users\renuka\Desktop\projet\MCU\AssemblerApplication1\AssemblerApplication1\kpd4x4bis.asm'
C:\Users\renuka\Desktop\projet\MCU\AssemblerApplication1\AssemblerApplication1\mainbis.asm(101): Including file 'C:\Users\renuka\Desktop\projet\MCU\AssemblerApplication1\AssemblerApplication1\lcd.asm'
C:\Users\renuka\Desktop\projet\MCU\AssemblerApplication1\AssemblerApplication1\mainbis.asm(102): Including file 'C:\Users\renuka\Desktop\projet\MCU\AssemblerApplication1\AssemblerApplication1\string.asm'
C:\Users\renuka\Desktop\projet\MCU\AssemblerApplication1\AssemblerApplication1\mainbis.asm(103): Including file 'C:\Users\renuka\Desktop\projet\MCU\AssemblerApplication1\AssemblerApplication1\subroutines.asm'
C:\Users\renuka\Desktop\projet\MCU\AssemblerApplication1\AssemblerApplication1\mainbis.asm(104): Including file 'C:\Users\renuka\Desktop\projet\MCU\AssemblerApplication1\AssemblerApplication1\printf.asm'
                                 
                                 .include "definitions.asm"
                                 
                                 ;***** Created: 2011-02-09 12:03 ******* Source: ATmega128.xml ***********
                                 ;*************************************************************************
                                 ;* A P P L I C A T I O N   N O T E   F O R   T H E   A V R   F A M I L Y
                                 ;* 
                                 ;* Number            : AVR000
                                 ;* File Name         : "m128def.inc"
                                 ;* Title             : Register/Bit Definitions for the ATmega128
                                 ;* Date              : 2011-02-09
                                 ;* Version           : 2.35
                                 ;* Support E-mail    : avr@atmel.com
                                 ;* Target MCU        : ATmega128
                                 ;* 
                                 ;* DESCRIPTION
                                 ;* When including this file in the assembly program file, all I/O register 
                                 ;* names and I/O register bit names appearing in the data book can be used.
                                 ;* In addition, the six registers forming the three data pointers X, Y and 
                                 ;* Z have been assigned names XL - ZH. Highest RAM address for Internal 
                                 ;* SRAM is also defined 
                                 ;* 
                                 ;* The Register names are represented by their hexadecimal address.
                                 ;* 
                                 ;* The Register Bit names are represented by their bit number (0-7).
                                 ;* 
                                 ;* Please observe the difference in using the bit names with instructions
                                 ;* such as "sbr"/"cbr" (set/clear bit in register) and "sbrs"/"sbrc"
                                 ;* (skip if bit in register set/cleared). The following example illustrates
                                 ;* this:
                                 ;* 
                                 ;* in    r16,PORTB             ;read PORTB latch
                                 ;* sbr   r16,(1<<PB6)+(1<<PB5) ;set PB6 and PB5 (use masks, not bit#)
                                 ;* out   PORTB,r16             ;output to PORTB
                                 ;* 
                                 ;* in    r16,TIFR              ;read the Timer Interrupt Flag Register
                                 ;* sbrc  r16,TOV0              ;test the overflow flag (use bit#)
                                 ;* rjmp  TOV0_is_set           ;jump if set
                                 ;* ...                         ;otherwise do something else
                                 ;*************************************************************************
                                 
                                 #ifndef _M128DEF_INC_
                                 #define _M128DEF_INC_
                                 
                                 
                                 #pragma partinc 0
                                 
                                 ; ***** SPECIFY DEVICE ***************************************************
                                 .device ATmega128
                                 #pragma AVRPART ADMIN PART_NAME ATmega128
                                 .equ	SIGNATURE_000	= 0x1e
                                 .equ	SIGNATURE_001	= 0x97
                                 .equ	SIGNATURE_002	= 0x02
                                 
                                 #pragma AVRPART CORE CORE_VERSION V2E
                                 
                                 
                                 ; ***** I/O REGISTER DEFINITIONS *****************************************
                                 ; NOTE:
                                 ; Definitions marked "MEMORY MAPPED"are extended I/O ports
                                 ; and cannot be used with IN/OUT instructions
                                 .equ	UCSR1C	= 0x9d	; MEMORY MAPPED
                                 .equ	UDR1	= 0x9c	; MEMORY MAPPED
                                 .equ	UCSR1A	= 0x9b	; MEMORY MAPPED
                                 .equ	UCSR1B	= 0x9a	; MEMORY MAPPED
                                 .equ	UBRR1H	= 0x98	; MEMORY MAPPED
                                 .equ	UBRR1L	= 0x99	; MEMORY MAPPED
                                 .equ	UCSR0C	= 0x95	; MEMORY MAPPED
                                 .equ	UBRR0H	= 0x90	; MEMORY MAPPED
                                 .equ	TCCR3C	= 0x8c	; MEMORY MAPPED
                                 .equ	TCCR3A	= 0x8b	; MEMORY MAPPED
                                 .equ	TCCR3B	= 0x8a	; MEMORY MAPPED
                                 .equ	TCNT3L	= 0x88	; MEMORY MAPPED
                                 .equ	TCNT3H	= 0x89	; MEMORY MAPPED
                                 .equ	OCR3AL	= 0x86	; MEMORY MAPPED
                                 .equ	OCR3AH	= 0x87	; MEMORY MAPPED
                                 .equ	OCR3BL	= 0x84	; MEMORY MAPPED
                                 .equ	OCR3BH	= 0x85	; MEMORY MAPPED
                                 .equ	OCR3CL	= 0x82	; MEMORY MAPPED
                                 .equ	OCR3CH	= 0x83	; MEMORY MAPPED
                                 .equ	ICR3L	= 0x80	; MEMORY MAPPED
                                 .equ	ICR3H	= 0x81	; MEMORY MAPPED
                                 .equ	ETIMSK	= 0x7d	; MEMORY MAPPED
                                 .equ	ETIFR	= 0x7c	; MEMORY MAPPED
                                 .equ	TCCR1C	= 0x7a	; MEMORY MAPPED
                                 .equ	OCR1CL	= 0x78	; MEMORY MAPPED
                                 .equ	OCR1CH	= 0x79	; MEMORY MAPPED
                                 .equ	TWCR	= 0x74	; MEMORY MAPPED
                                 .equ	TWDR	= 0x73	; MEMORY MAPPED
                                 .equ	TWAR	= 0x72	; MEMORY MAPPED
                                 .equ	TWSR	= 0x71	; MEMORY MAPPED
                                 .equ	TWBR	= 0x70	; MEMORY MAPPED
                                 .equ	OSCCAL	= 0x6f	; MEMORY MAPPED
                                 .equ	XMCRA	= 0x6d	; MEMORY MAPPED
                                 .equ	XMCRB	= 0x6c	; MEMORY MAPPED
                                 .equ	EICRA	= 0x6a	; MEMORY MAPPED
                                 .equ	SPMCSR	= 0x68	; MEMORY MAPPED
                                 .equ	PORTG	= 0x65	; MEMORY MAPPED
                                 .equ	DDRG	= 0x64	; MEMORY MAPPED
                                 .equ	PING	= 0x63	; MEMORY MAPPED
                                 .equ	PORTF	= 0x62	; MEMORY MAPPED
                                 .equ	DDRF	= 0x61	; MEMORY MAPPED
                                 .equ	SREG	= 0x3f
                                 .equ	SPL	= 0x3d
                                 .equ	SPH	= 0x3e
                                 .equ	XDIV	= 0x3c
                                 .equ	RAMPZ	= 0x3b
                                 .equ	EICRB	= 0x3a
                                 .equ	EIMSK	= 0x39
                                 .equ	EIFR	= 0x38
                                 .equ	TIMSK	= 0x37
                                 .equ	TIFR	= 0x36
                                 .equ	MCUCR	= 0x35
                                 .equ	MCUCSR	= 0x34
                                 .equ	TCCR0	= 0x33
                                 .equ	TCNT0	= 0x32
                                 .equ	OCR0	= 0x31
                                 .equ	ASSR	= 0x30
                                 .equ	TCCR1A	= 0x2f
                                 .equ	TCCR1B	= 0x2e
                                 .equ	TCNT1L	= 0x2c
                                 .equ	TCNT1H	= 0x2d
                                 .equ	OCR1AL	= 0x2a
                                 .equ	OCR1AH	= 0x2b
                                 .equ	OCR1BL	= 0x28
                                 .equ	OCR1BH	= 0x29
                                 .equ	ICR1L	= 0x26
                                 .equ	ICR1H	= 0x27
                                 .equ	TCCR2	= 0x25
                                 .equ	TCNT2	= 0x24
                                 .equ	OCR2	= 0x23
                                 .equ	OCDR	= 0x22
                                 .equ	WDTCR	= 0x21
                                 .equ	SFIOR	= 0x20
                                 .equ	EEARL	= 0x1e
                                 .equ	EEARH	= 0x1f
                                 .equ	EEDR	= 0x1d
                                 .equ	EECR	= 0x1c
                                 .equ	PORTA	= 0x1b
                                 .equ	DDRA	= 0x1a
                                 .equ	PINA	= 0x19
                                 .equ	PORTB	= 0x18
                                 .equ	DDRB	= 0x17
                                 .equ	PINB	= 0x16
                                 .equ	PORTC	= 0x15
                                 .equ	DDRC	= 0x14
                                 .equ	PINC	= 0x13
                                 .equ	PORTD	= 0x12
                                 .equ	DDRD	= 0x11
                                 .equ	PIND	= 0x10
                                 .equ	SPDR	= 0x0f
                                 .equ	SPSR	= 0x0e
                                 .equ	SPCR	= 0x0d
                                 .equ	UDR0	= 0x0c
                                 .equ	UCSR0A	= 0x0b
                                 .equ	UCSR0B	= 0x0a
                                 .equ	UBRR0L	= 0x09
                                 .equ	ACSR	= 0x08
                                 .equ	ADMUX	= 0x07
                                 .equ	ADCSRA	= 0x06
                                 .equ	ADCH	= 0x05
                                 .equ	ADCL	= 0x04
                                 .equ	PORTE	= 0x03
                                 .equ	DDRE	= 0x02
                                 .equ	PINE	= 0x01
                                 .equ	PINF	= 0x00
                                 
                                 
                                 ; ***** BIT DEFINITIONS **************************************************
                                 
                                 ; ***** ANALOG_COMPARATOR ************
                                 ; SFIOR - Special Function IO Register
                                 .equ	ACME	= 3	; Analog Comparator Multiplexer Enable
                                 
                                 ; ACSR - Analog Comparator Control And Status Register
                                 .equ	ACIS0	= 0	; Analog Comparator Interrupt Mode Select bit 0
                                 .equ	ACIS1	= 1	; Analog Comparator Interrupt Mode Select bit 1
                                 .equ	ACIC	= 2	; Analog Comparator Input Capture Enable
                                 .equ	ACIE	= 3	; Analog Comparator Interrupt Enable
                                 .equ	ACI	= 4	; Analog Comparator Interrupt Flag
                                 .equ	ACO	= 5	; Analog Compare Output
                                 .equ	ACBG	= 6	; Analog Comparator Bandgap Select
                                 .equ	ACD	= 7	; Analog Comparator Disable
                                 
                                 
                                 ; ***** SPI **************************
                                 ; SPDR - SPI Data Register
                                 .equ	SPDR0	= 0	; SPI Data Register bit 0
                                 .equ	SPDR1	= 1	; SPI Data Register bit 1
                                 .equ	SPDR2	= 2	; SPI Data Register bit 2
                                 .equ	SPDR3	= 3	; SPI Data Register bit 3
                                 .equ	SPDR4	= 4	; SPI Data Register bit 4
                                 .equ	SPDR5	= 5	; SPI Data Register bit 5
                                 .equ	SPDR6	= 6	; SPI Data Register bit 6
                                 .equ	SPDR7	= 7	; SPI Data Register bit 7
                                 
                                 ; SPSR - SPI Status Register
                                 .equ	SPI2X	= 0	; Double SPI Speed Bit
                                 .equ	WCOL	= 6	; Write Collision Flag
                                 .equ	SPIF	= 7	; SPI Interrupt Flag
                                 
                                 ; SPCR - SPI Control Register
                                 .equ	SPR0	= 0	; SPI Clock Rate Select 0
                                 .equ	SPR1	= 1	; SPI Clock Rate Select 1
                                 .equ	CPHA	= 2	; Clock Phase
                                 .equ	CPOL	= 3	; Clock polarity
                                 .equ	MSTR	= 4	; Master/Slave Select
                                 .equ	DORD	= 5	; Data Order
                                 .equ	SPE	= 6	; SPI Enable
                                 .equ	SPIE	= 7	; SPI Interrupt Enable
                                 
                                 
                                 ; ***** TWI **************************
                                 ; TWBR - TWI Bit Rate register
                                 .equ	I2BR	= TWBR	; For compatibility
                                 .equ	TWBR0	= 0	; 
                                 .equ	TWBR1	= 1	; 
                                 .equ	TWBR2	= 2	; 
                                 .equ	TWBR3	= 3	; 
                                 .equ	TWBR4	= 4	; 
                                 .equ	TWBR5	= 5	; 
                                 .equ	TWBR6	= 6	; 
                                 .equ	TWBR7	= 7	; 
                                 
                                 ; TWCR - TWI Control Register
                                 .equ	I2CR	= TWCR	; For compatibility
                                 .equ	TWIE	= 0	; TWI Interrupt Enable
                                 .equ	I2IE	= TWIE	; For compatibility
                                 .equ	TWEN	= 2	; TWI Enable Bit
                                 .equ	I2EN	= TWEN	; For compatibility
                                 .equ	ENI2C	= TWEN	; For compatibility
                                 .equ	TWWC	= 3	; TWI Write Collition Flag
                                 .equ	I2WC	= TWWC	; For compatibility
                                 .equ	TWSTO	= 4	; TWI Stop Condition Bit
                                 .equ	I2STO	= TWSTO	; For compatibility
                                 .equ	TWSTA	= 5	; TWI Start Condition Bit
                                 .equ	I2STA	= TWSTA	; For compatibility
                                 .equ	TWEA	= 6	; TWI Enable Acknowledge Bit
                                 .equ	I2EA	= TWEA	; For compatibility
                                 .equ	TWINT	= 7	; TWI Interrupt Flag
                                 .equ	I2INT	= TWINT	; For compatibility
                                 
                                 ; TWSR - TWI Status Register
                                 .equ	I2SR	= TWSR	; For compatibility
                                 .equ	TWPS0	= 0	; TWI Prescaler
                                 .equ	TWS0	= TWPS0	; For compatibility
                                 .equ	I2GCE	= TWPS0	; For compatibility
                                 .equ	TWPS1	= 1	; TWI Prescaler
                                 .equ	TWS1	= TWPS1	; For compatibility
                                 .equ	TWS3	= 3	; TWI Status
                                 .equ	I2S3	= TWS3	; For compatibility
                                 .equ	TWS4	= 4	; TWI Status
                                 .equ	I2S4	= TWS4	; For compatibility
                                 .equ	TWS5	= 5	; TWI Status
                                 .equ	I2S5	= TWS5	; For compatibility
                                 .equ	TWS6	= 6	; TWI Status
                                 .equ	I2S6	= TWS6	; For compatibility
                                 .equ	TWS7	= 7	; TWI Status
                                 .equ	I2S7	= TWS7	; For compatibility
                                 
                                 ; TWDR - TWI Data register
                                 .equ	I2DR	= TWDR	; For compatibility
                                 .equ	TWD0	= 0	; TWI Data Register Bit 0
                                 .equ	TWD1	= 1	; TWI Data Register Bit 1
                                 .equ	TWD2	= 2	; TWI Data Register Bit 2
                                 .equ	TWD3	= 3	; TWI Data Register Bit 3
                                 .equ	TWD4	= 4	; TWI Data Register Bit 4
                                 .equ	TWD5	= 5	; TWI Data Register Bit 5
                                 .equ	TWD6	= 6	; TWI Data Register Bit 6
                                 .equ	TWD7	= 7	; TWI Data Register Bit 7
                                 
                                 ; TWAR - TWI (Slave) Address register
                                 .equ	I2AR	= TWAR	; For compatibility
                                 .equ	TWGCE	= 0	; TWI General Call Recognition Enable Bit
                                 .equ	TWA0	= 1	; TWI (Slave) Address register Bit 0
                                 .equ	TWA1	= 2	; TWI (Slave) Address register Bit 1
                                 .equ	TWA2	= 3	; TWI (Slave) Address register Bit 2
                                 .equ	TWA3	= 4	; TWI (Slave) Address register Bit 3
                                 .equ	TWA4	= 5	; TWI (Slave) Address register Bit 4
                                 .equ	TWA5	= 6	; TWI (Slave) Address register Bit 5
                                 .equ	TWA6	= 7	; TWI (Slave) Address register Bit 6
                                 
                                 
                                 ; ***** USART0 ***********************
                                 ; UDR0 - USART I/O Data Register
                                 .equ	UDR00	= 0	; USART I/O Data Register bit 0
                                 .equ	UDR01	= 1	; USART I/O Data Register bit 1
                                 .equ	UDR02	= 2	; USART I/O Data Register bit 2
                                 .equ	UDR03	= 3	; USART I/O Data Register bit 3
                                 .equ	UDR04	= 4	; USART I/O Data Register bit 4
                                 .equ	UDR05	= 5	; USART I/O Data Register bit 5
                                 .equ	UDR06	= 6	; USART I/O Data Register bit 6
                                 .equ	UDR07	= 7	; USART I/O Data Register bit 7
                                 
                                 ; UCSR0A - USART Control and Status Register A
                                 .equ	MPCM0	= 0	; Multi-processor Communication Mode
                                 .equ	U2X0	= 1	; Double the USART transmission speed
                                 .equ	UPE0	= 2	; Parity Error
                                 .equ	DOR0	= 3	; Data overRun
                                 .equ	FE0	= 4	; Framing Error
                                 .equ	UDRE0	= 5	; USART Data Register Empty
                                 .equ	TXC0	= 6	; USART Transmitt Complete
                                 .equ	RXC0	= 7	; USART Receive Complete
                                 
                                 ; UCSR0B - USART Control and Status Register B
                                 .equ	TXB80	= 0	; Transmit Data Bit 8
                                 .equ	RXB80	= 1	; Receive Data Bit 8
                                 .equ	UCSZ02	= 2	; Character Size
                                 .equ	UCSZ2	= UCSZ02	; For compatibility
                                 .equ	TXEN0	= 3	; Transmitter Enable
                                 .equ	RXEN0	= 4	; Receiver Enable
                                 .equ	UDRIE0	= 5	; USART Data register Empty Interrupt Enable
                                 .equ	TXCIE0	= 6	; TX Complete Interrupt Enable
                                 .equ	RXCIE0	= 7	; RX Complete Interrupt Enable
                                 
                                 ; UCSR0C - USART Control and Status Register C
                                 .equ	UCPOL0	= 0	; Clock Polarity
                                 .equ	UCSZ00	= 1	; Character Size
                                 .equ	UCSZ01	= 2	; Character Size
                                 .equ	USBS0	= 3	; Stop Bit Select
                                 .equ	UPM00	= 4	; Parity Mode Bit 0
                                 .equ	UPM01	= 5	; Parity Mode Bit 1
                                 .equ	UMSEL0	= 6	; USART Mode Select
                                 
                                 ; UBRR0H - USART Baud Rate Register Hight Byte
                                 .equ	UBRR8	= 0	; USART Baud Rate Register bit 8
                                 .equ	UBRR9	= 1	; USART Baud Rate Register bit 9
                                 .equ	UBRR10	= 2	; USART Baud Rate Register bit 10
                                 .equ	UBRR11	= 3	; USART Baud Rate Register bit 11
                                 
                                 ; UBRR0L - USART Baud Rate Register Low Byte
                                 .equ	UBRR0	= 0	; USART Baud Rate Register bit 0
                                 .equ	UBRR1	= 1	; USART Baud Rate Register bit 1
                                 .equ	UBRR2	= 2	; USART Baud Rate Register bit 2
                                 .equ	UBRR3	= 3	; USART Baud Rate Register bit 3
                                 .equ	UBRR4	= 4	; USART Baud Rate Register bit 4
                                 .equ	UBRR5	= 5	; USART Baud Rate Register bit 5
                                 .equ	UBRR6	= 6	; USART Baud Rate Register bit 6
                                 .equ	UBRR7	= 7	; USART Baud Rate Register bit 7
                                 
                                 
                                 ; ***** USART1 ***********************
                                 ; UDR1 - USART I/O Data Register
                                 .equ	UDR10	= 0	; USART I/O Data Register bit 0
                                 .equ	UDR11	= 1	; USART I/O Data Register bit 1
                                 .equ	UDR12	= 2	; USART I/O Data Register bit 2
                                 .equ	UDR13	= 3	; USART I/O Data Register bit 3
                                 .equ	UDR14	= 4	; USART I/O Data Register bit 4
                                 .equ	UDR15	= 5	; USART I/O Data Register bit 5
                                 .equ	UDR16	= 6	; USART I/O Data Register bit 6
                                 .equ	UDR17	= 7	; USART I/O Data Register bit 7
                                 
                                 ; UCSR1A - USART Control and Status Register A
                                 .equ	MPCM1	= 0	; Multi-processor Communication Mode
                                 .equ	U2X1	= 1	; Double the USART transmission speed
                                 .equ	UPE1	= 2	; Parity Error
                                 .equ	DOR1	= 3	; Data overRun
                                 .equ	FE1	= 4	; Framing Error
                                 .equ	UDRE1	= 5	; USART Data Register Empty
                                 .equ	TXC1	= 6	; USART Transmitt Complete
                                 .equ	RXC1	= 7	; USART Receive Complete
                                 
                                 ; UCSR1B - USART Control and Status Register B
                                 .equ	TXB81	= 0	; Transmit Data Bit 8
                                 .equ	RXB81	= 1	; Receive Data Bit 8
                                 .equ	UCSZ12	= 2	; Character Size
                                 .equ	TXEN1	= 3	; Transmitter Enable
                                 .equ	RXEN1	= 4	; Receiver Enable
                                 .equ	UDRIE1	= 5	; USART Data register Empty Interrupt Enable
                                 .equ	TXCIE1	= 6	; TX Complete Interrupt Enable
                                 .equ	RXCIE1	= 7	; RX Complete Interrupt Enable
                                 
                                 ; UCSR1C - USART Control and Status Register C
                                 .equ	UCPOL1	= 0	; Clock Polarity
                                 .equ	UCSZ10	= 1	; Character Size
                                 .equ	UCSZ11	= 2	; Character Size
                                 .equ	USBS1	= 3	; Stop Bit Select
                                 .equ	UPM10	= 4	; Parity Mode Bit 0
                                 .equ	UPM11	= 5	; Parity Mode Bit 1
                                 .equ	UMSEL1	= 6	; USART Mode Select
                                 
                                 ; UBRR1H - USART Baud Rate Register Hight Byte
                                 ;.equ	UBRR8	= 0	; USART Baud Rate Register bit 8
                                 ;.equ	UBRR9	= 1	; USART Baud Rate Register bit 9
                                 ;.equ	UBRR10	= 2	; USART Baud Rate Register bit 10
                                 ;.equ	UBRR11	= 3	; USART Baud Rate Register bit 11
                                 
                                 ; UBRR1L - USART Baud Rate Register Low Byte
                                 ;.equ	UBRR0	= 0	; USART Baud Rate Register bit 0
                                 ;.equ	UBRR1	= 1	; USART Baud Rate Register bit 1
                                 ;.equ	UBRR2	= 2	; USART Baud Rate Register bit 2
                                 ;.equ	UBRR3	= 3	; USART Baud Rate Register bit 3
                                 ;.equ	UBRR4	= 4	; USART Baud Rate Register bit 4
                                 ;.equ	UBRR5	= 5	; USART Baud Rate Register bit 5
                                 ;.equ	UBRR6	= 6	; USART Baud Rate Register bit 6
                                 ;.equ	UBRR7	= 7	; USART Baud Rate Register bit 7
                                 
                                 
                                 ; ***** CPU **************************
                                 ; SREG - Status Register
                                 .equ	SREG_C	= 0	; Carry Flag
                                 .equ	SREG_Z	= 1	; Zero Flag
                                 .equ	SREG_N	= 2	; Negative Flag
                                 .equ	SREG_V	= 3	; Two's Complement Overflow Flag
                                 .equ	SREG_S	= 4	; Sign Bit
                                 .equ	SREG_H	= 5	; Half Carry Flag
                                 .equ	SREG_T	= 6	; Bit Copy Storage
                                 .equ	SREG_I	= 7	; Global Interrupt Enable
                                 
                                 ; MCUCR - MCU Control Register
                                 .equ	IVCE	= 0	; Interrupt Vector Change Enable
                                 .equ	IVSEL	= 1	; Interrupt Vector Select
                                 .equ	SM2	= 2	; Sleep Mode Select
                                 .equ	SM0	= 3	; Sleep Mode Select
                                 .equ	SM1	= 4	; Sleep Mode Select
                                 .equ	SE	= 5	; Sleep Enable
                                 .equ	SRW10	= 6	; External SRAM Wait State Select
                                 .equ	SRE	= 7	; External SRAM Enable
                                 
                                 ; XMCRA - External Memory Control Register A
                                 .equ	SRW11	= 1	; Wait state select bit upper page
                                 .equ	SRW00	= 2	; Wait state select bit lower page
                                 .equ	SRW01	= 3	; Wait state select bit lower page
                                 .equ	SRL0	= 4	; Wait state page limit
                                 .equ	SRL1	= 5	; Wait state page limit
                                 .equ	SRL2	= 6	; Wait state page limit
                                 
                                 ; XMCRB - External Memory Control Register B
                                 .equ	XMM0	= 0	; External Memory High Mask
                                 .equ	XMM1	= 1	; External Memory High Mask
                                 .equ	XMM2	= 2	; External Memory High Mask
                                 .equ	XMBK	= 7	; External Memory Bus Keeper Enable
                                 
                                 ; OSCCAL - Oscillator Calibration Value
                                 .equ	CAL0	= 0	; Oscillator Calibration Value
                                 .equ	CAL1	= 1	; Oscillator Calibration Value
                                 .equ	CAL2	= 2	; Oscillator Calibration Value
                                 .equ	CAL3	= 3	; Oscillator Calibration Value
                                 .equ	CAL4	= 4	; Oscillator Calibration Value
                                 .equ	CAL5	= 5	; Oscillator Calibration Value
                                 .equ	CAL6	= 6	; Oscillator Calibration Value
                                 .equ	CAL7	= 7	; Oscillator Calibration Value
                                 
                                 ; XDIV - XTAL Divide Control Register
                                 .equ	XDIV0	= 0	; XTAl Divide Select Bit 0
                                 .equ	XDIV1	= 1	; XTAl Divide Select Bit 1
                                 .equ	XDIV2	= 2	; XTAl Divide Select Bit 2
                                 .equ	XDIV3	= 3	; XTAl Divide Select Bit 3
                                 .equ	XDIV4	= 4	; XTAl Divide Select Bit 4
                                 .equ	XDIV5	= 5	; XTAl Divide Select Bit 5
                                 .equ	XDIV6	= 6	; XTAl Divide Select Bit 6
                                 .equ	XDIVEN	= 7	; XTAL Divide Enable
                                 
                                 ; MCUCSR - MCU Control And Status Register
                                 .equ	PORF	= 0	; Power-on reset flag
                                 .equ	EXTRF	= 1	; External Reset Flag
                                 .equ	BORF	= 2	; Brown-out Reset Flag
                                 .equ	WDRF	= 3	; Watchdog Reset Flag
                                 .equ	JTRF	= 4	; JTAG Reset Flag
                                 .equ	JTD	= 7	; JTAG Interface Disable
                                 
                                 ; RAMPZ - RAM Page Z Select Register
                                 .equ	RAMPZ0	= 0	; RAM Page Z Select Register Bit 0
                                 
                                 
                                 ; ***** BOOT_LOAD ********************
                                 ; SPMCSR - Store Program Memory Control Register
                                 .equ	SPMCR	= SPMCSR	; For compatibility
                                 .equ	SPMEN	= 0	; Store Program Memory Enable
                                 .equ	PGERS	= 1	; Page Erase
                                 .equ	PGWRT	= 2	; Page Write
                                 .equ	BLBSET	= 3	; Boot Lock Bit Set
                                 .equ	RWWSRE	= 4	; Read While Write section read enable
                                 .equ	ASRE	= RWWSRE	; For compatibility
                                 .equ	RWWSB	= 6	; Read While Write Section Busy
                                 .equ	ASB	= RWWSB	; For compatibility
                                 .equ	SPMIE	= 7	; SPM Interrupt Enable
                                 
                                 
                                 ; ***** JTAG *************************
                                 ; OCDR - On-Chip Debug Related Register in I/O Memory
                                 .equ	OCDR0	= 0	; On-Chip Debug Register Bit 0
                                 .equ	OCDR1	= 1	; On-Chip Debug Register Bit 1
                                 .equ	OCDR2	= 2	; On-Chip Debug Register Bit 2
                                 .equ	OCDR3	= 3	; On-Chip Debug Register Bit 3
                                 .equ	OCDR4	= 4	; On-Chip Debug Register Bit 4
                                 .equ	OCDR5	= 5	; On-Chip Debug Register Bit 5
                                 .equ	OCDR6	= 6	; On-Chip Debug Register Bit 6
                                 .equ	OCDR7	= 7	; On-Chip Debug Register Bit 7
                                 .equ	IDRD	= OCDR7	; For compatibility
                                 
                                 ; MCUCSR - MCU Control And Status Register
                                 ;.equ	JTRF	= 4	; JTAG Reset Flag
                                 ;.equ	JTD	= 7	; JTAG Interface Disable
                                 
                                 
                                 ; ***** MISC *************************
                                 ; SFIOR - Special Function IO Register
                                 .equ	PSR321	= 0	; Prescaler Reset Timer/Counter3, Timer/Counter2, and Timer/Counter1
                                 .equ	PSR1	= PSR321	; For compatibility
                                 .equ	PSR2	= PSR321	; For compatibility
                                 .equ	PSR3	= PSR321	; For compatibility
                                 .equ	PSR0	= 1	; Prescaler Reset Timer/Counter0
                                 .equ	PUD	= 2	; Pull Up Disable
                                 ;.equ	ACME	= 3	; Analog Comparator Multiplexer Enable
                                 .equ	TSM	= 7	; Timer/Counter Synchronization Mode
                                 
                                 
                                 ; ***** EXTERNAL_INTERRUPT ***********
                                 ; EICRA - External Interrupt Control Register A
                                 .equ	ISC00	= 0	; External Interrupt Sense Control Bit
                                 .equ	ISC01	= 1	; External Interrupt Sense Control Bit
                                 .equ	ISC10	= 2	; External Interrupt Sense Control Bit
                                 .equ	ISC11	= 3	; External Interrupt Sense Control Bit
                                 .equ	ISC20	= 4	; External Interrupt Sense Control Bit
                                 .equ	ISC21	= 5	; External Interrupt Sense Control Bit
                                 .equ	ISC30	= 6	; External Interrupt Sense Control Bit
                                 .equ	ISC31	= 7	; External Interrupt Sense Control Bit
                                 
                                 ; EICRB - External Interrupt Control Register B
                                 .equ	ISC40	= 0	; External Interrupt 7-4 Sense Control Bit
                                 .equ	ISC41	= 1	; External Interrupt 7-4 Sense Control Bit
                                 .equ	ISC50	= 2	; External Interrupt 7-4 Sense Control Bit
                                 .equ	ISC51	= 3	; External Interrupt 7-4 Sense Control Bit
                                 .equ	ISC60	= 4	; External Interrupt 7-4 Sense Control Bit
                                 .equ	ISC61	= 5	; External Interrupt 7-4 Sense Control Bit
                                 .equ	ISC70	= 6	; External Interrupt 7-4 Sense Control Bit
                                 .equ	ISC71	= 7	; External Interrupt 7-4 Sense Control Bit
                                 
                                 ; EIMSK - External Interrupt Mask Register
                                 .equ	GICR	= EIMSK	; For compatibility
                                 .equ	GIMSK	= EIMSK	; For compatibility
                                 .equ	INT0	= 0	; External Interrupt Request 0 Enable
                                 .equ	INT1	= 1	; External Interrupt Request 1 Enable
                                 .equ	INT2	= 2	; External Interrupt Request 2 Enable
                                 .equ	INT3	= 3	; External Interrupt Request 3 Enable
                                 .equ	INT4	= 4	; External Interrupt Request 4 Enable
                                 .equ	INT5	= 5	; External Interrupt Request 5 Enable
                                 .equ	INT6	= 6	; External Interrupt Request 6 Enable
                                 .equ	INT7	= 7	; External Interrupt Request 7 Enable
                                 
                                 ; EIFR - External Interrupt Flag Register
                                 .equ	GIFR	= EIFR	; For compatibility
                                 .equ	INTF0	= 0	; External Interrupt Flag 0
                                 .equ	INTF1	= 1	; External Interrupt Flag 1
                                 .equ	INTF2	= 2	; External Interrupt Flag 2
                                 .equ	INTF3	= 3	; External Interrupt Flag 3
                                 .equ	INTF4	= 4	; External Interrupt Flag 4
                                 .equ	INTF5	= 5	; External Interrupt Flag 5
                                 .equ	INTF6	= 6	; External Interrupt Flag 6
                                 .equ	INTF7	= 7	; External Interrupt Flag 7
                                 
                                 
                                 ; ***** EEPROM ***********************
                                 ; EEDR - EEPROM Data Register
                                 .equ	EEDR0	= 0	; EEPROM Data Register bit 0
                                 .equ	EEDR1	= 1	; EEPROM Data Register bit 1
                                 .equ	EEDR2	= 2	; EEPROM Data Register bit 2
                                 .equ	EEDR3	= 3	; EEPROM Data Register bit 3
                                 .equ	EEDR4	= 4	; EEPROM Data Register bit 4
                                 .equ	EEDR5	= 5	; EEPROM Data Register bit 5
                                 .equ	EEDR6	= 6	; EEPROM Data Register bit 6
                                 .equ	EEDR7	= 7	; EEPROM Data Register bit 7
                                 
                                 ; EECR - EEPROM Control Register
                                 .equ	EERE	= 0	; EEPROM Read Enable
                                 .equ	EEWE	= 1	; EEPROM Write Enable
                                 .equ	EEMWE	= 2	; EEPROM Master Write Enable
                                 .equ	EERIE	= 3	; EEPROM Ready Interrupt Enable
                                 
                                 
                                 ; ***** PORTA ************************
                                 ; PORTA - Port A Data Register
                                 .equ	PORTA0	= 0	; Port A Data Register bit 0
                                 .equ	PA0	= 0	; For compatibility
                                 .equ	PORTA1	= 1	; Port A Data Register bit 1
                                 .equ	PA1	= 1	; For compatibility
                                 .equ	PORTA2	= 2	; Port A Data Register bit 2
                                 .equ	PA2	= 2	; For compatibility
                                 .equ	PORTA3	= 3	; Port A Data Register bit 3
                                 .equ	PA3	= 3	; For compatibility
                                 .equ	PORTA4	= 4	; Port A Data Register bit 4
                                 .equ	PA4	= 4	; For compatibility
                                 .equ	PORTA5	= 5	; Port A Data Register bit 5
                                 .equ	PA5	= 5	; For compatibility
                                 .equ	PORTA6	= 6	; Port A Data Register bit 6
                                 .equ	PA6	= 6	; For compatibility
                                 .equ	PORTA7	= 7	; Port A Data Register bit 7
                                 .equ	PA7	= 7	; For compatibility
                                 
                                 ; DDRA - Port A Data Direction Register
                                 .equ	DDA0	= 0	; Data Direction Register, Port A, bit 0
                                 .equ	DDA1	= 1	; Data Direction Register, Port A, bit 1
                                 .equ	DDA2	= 2	; Data Direction Register, Port A, bit 2
                                 .equ	DDA3	= 3	; Data Direction Register, Port A, bit 3
                                 .equ	DDA4	= 4	; Data Direction Register, Port A, bit 4
                                 .equ	DDA5	= 5	; Data Direction Register, Port A, bit 5
                                 .equ	DDA6	= 6	; Data Direction Register, Port A, bit 6
                                 .equ	DDA7	= 7	; Data Direction Register, Port A, bit 7
                                 
                                 ; PINA - Port A Input Pins
                                 .equ	PINA0	= 0	; Input Pins, Port A bit 0
                                 .equ	PINA1	= 1	; Input Pins, Port A bit 1
                                 .equ	PINA2	= 2	; Input Pins, Port A bit 2
                                 .equ	PINA3	= 3	; Input Pins, Port A bit 3
                                 .equ	PINA4	= 4	; Input Pins, Port A bit 4
                                 .equ	PINA5	= 5	; Input Pins, Port A bit 5
                                 .equ	PINA6	= 6	; Input Pins, Port A bit 6
                                 .equ	PINA7	= 7	; Input Pins, Port A bit 7
                                 
                                 
                                 ; ***** PORTB ************************
                                 ; PORTB - Port B Data Register
                                 .equ	PORTB0	= 0	; Port B Data Register bit 0
                                 .equ	PB0	= 0	; For compatibility
                                 .equ	PORTB1	= 1	; Port B Data Register bit 1
                                 .equ	PB1	= 1	; For compatibility
                                 .equ	PORTB2	= 2	; Port B Data Register bit 2
                                 .equ	PB2	= 2	; For compatibility
                                 .equ	PORTB3	= 3	; Port B Data Register bit 3
                                 .equ	PB3	= 3	; For compatibility
                                 .equ	PORTB4	= 4	; Port B Data Register bit 4
                                 .equ	PB4	= 4	; For compatibility
                                 .equ	PORTB5	= 5	; Port B Data Register bit 5
                                 .equ	PB5	= 5	; For compatibility
                                 .equ	PORTB6	= 6	; Port B Data Register bit 6
                                 .equ	PB6	= 6	; For compatibility
                                 .equ	PORTB7	= 7	; Port B Data Register bit 7
                                 .equ	PB7	= 7	; For compatibility
                                 
                                 ; DDRB - Port B Data Direction Register
                                 .equ	DDB0	= 0	; Port B Data Direction Register bit 0
                                 .equ	DDB1	= 1	; Port B Data Direction Register bit 1
                                 .equ	DDB2	= 2	; Port B Data Direction Register bit 2
                                 .equ	DDB3	= 3	; Port B Data Direction Register bit 3
                                 .equ	DDB4	= 4	; Port B Data Direction Register bit 4
                                 .equ	DDB5	= 5	; Port B Data Direction Register bit 5
                                 .equ	DDB6	= 6	; Port B Data Direction Register bit 6
                                 .equ	DDB7	= 7	; Port B Data Direction Register bit 7
                                 
                                 ; PINB - Port B Input Pins
                                 .equ	PINB0	= 0	; Port B Input Pins bit 0
                                 .equ	PINB1	= 1	; Port B Input Pins bit 1
                                 .equ	PINB2	= 2	; Port B Input Pins bit 2
                                 .equ	PINB3	= 3	; Port B Input Pins bit 3
                                 .equ	PINB4	= 4	; Port B Input Pins bit 4
                                 .equ	PINB5	= 5	; Port B Input Pins bit 5
                                 .equ	PINB6	= 6	; Port B Input Pins bit 6
                                 .equ	PINB7	= 7	; Port B Input Pins bit 7
                                 
                                 
                                 ; ***** PORTC ************************
                                 ; PORTC - Port C Data Register
                                 .equ	PORTC0	= 0	; Port C Data Register bit 0
                                 .equ	PC0	= 0	; For compatibility
                                 .equ	PORTC1	= 1	; Port C Data Register bit 1
                                 .equ	PC1	= 1	; For compatibility
                                 .equ	PORTC2	= 2	; Port C Data Register bit 2
                                 .equ	PC2	= 2	; For compatibility
                                 .equ	PORTC3	= 3	; Port C Data Register bit 3
                                 .equ	PC3	= 3	; For compatibility
                                 .equ	PORTC4	= 4	; Port C Data Register bit 4
                                 .equ	PC4	= 4	; For compatibility
                                 .equ	PORTC5	= 5	; Port C Data Register bit 5
                                 .equ	PC5	= 5	; For compatibility
                                 .equ	PORTC6	= 6	; Port C Data Register bit 6
                                 .equ	PC6	= 6	; For compatibility
                                 .equ	PORTC7	= 7	; Port C Data Register bit 7
                                 .equ	PC7	= 7	; For compatibility
                                 
                                 ; DDRC - Port C Data Direction Register
                                 .equ	DDC0	= 0	; Port C Data Direction Register bit 0
                                 .equ	DDC1	= 1	; Port C Data Direction Register bit 1
                                 .equ	DDC2	= 2	; Port C Data Direction Register bit 2
                                 .equ	DDC3	= 3	; Port C Data Direction Register bit 3
                                 .equ	DDC4	= 4	; Port C Data Direction Register bit 4
                                 .equ	DDC5	= 5	; Port C Data Direction Register bit 5
                                 .equ	DDC6	= 6	; Port C Data Direction Register bit 6
                                 .equ	DDC7	= 7	; Port C Data Direction Register bit 7
                                 
                                 ; PINC - Port C Input Pins
                                 .equ	PINC0	= 0	; Port C Input Pins bit 0
                                 .equ	PINC1	= 1	; Port C Input Pins bit 1
                                 .equ	PINC2	= 2	; Port C Input Pins bit 2
                                 .equ	PINC3	= 3	; Port C Input Pins bit 3
                                 .equ	PINC4	= 4	; Port C Input Pins bit 4
                                 .equ	PINC5	= 5	; Port C Input Pins bit 5
                                 .equ	PINC6	= 6	; Port C Input Pins bit 6
                                 .equ	PINC7	= 7	; Port C Input Pins bit 7
                                 
                                 
                                 ; ***** PORTD ************************
                                 ; PORTD - Port D Data Register
                                 .equ	PORTD0	= 0	; Port D Data Register bit 0
                                 .equ	PD0	= 0	; For compatibility
                                 .equ	PORTD1	= 1	; Port D Data Register bit 1
                                 .equ	PD1	= 1	; For compatibility
                                 .equ	PORTD2	= 2	; Port D Data Register bit 2
                                 .equ	PD2	= 2	; For compatibility
                                 .equ	PORTD3	= 3	; Port D Data Register bit 3
                                 .equ	PD3	= 3	; For compatibility
                                 .equ	PORTD4	= 4	; Port D Data Register bit 4
                                 .equ	PD4	= 4	; For compatibility
                                 .equ	PORTD5	= 5	; Port D Data Register bit 5
                                 .equ	PD5	= 5	; For compatibility
                                 .equ	PORTD6	= 6	; Port D Data Register bit 6
                                 .equ	PD6	= 6	; For compatibility
                                 .equ	PORTD7	= 7	; Port D Data Register bit 7
                                 .equ	PD7	= 7	; For compatibility
                                 
                                 ; DDRD - Port D Data Direction Register
                                 .equ	DDD0	= 0	; Port D Data Direction Register bit 0
                                 .equ	DDD1	= 1	; Port D Data Direction Register bit 1
                                 .equ	DDD2	= 2	; Port D Data Direction Register bit 2
                                 .equ	DDD3	= 3	; Port D Data Direction Register bit 3
                                 .equ	DDD4	= 4	; Port D Data Direction Register bit 4
                                 .equ	DDD5	= 5	; Port D Data Direction Register bit 5
                                 .equ	DDD6	= 6	; Port D Data Direction Register bit 6
                                 .equ	DDD7	= 7	; Port D Data Direction Register bit 7
                                 
                                 ; PIND - Port D Input Pins
                                 .equ	PIND0	= 0	; Port D Input Pins bit 0
                                 .equ	PIND1	= 1	; Port D Input Pins bit 1
                                 .equ	PIND2	= 2	; Port D Input Pins bit 2
                                 .equ	PIND3	= 3	; Port D Input Pins bit 3
                                 .equ	PIND4	= 4	; Port D Input Pins bit 4
                                 .equ	PIND5	= 5	; Port D Input Pins bit 5
                                 .equ	PIND6	= 6	; Port D Input Pins bit 6
                                 .equ	PIND7	= 7	; Port D Input Pins bit 7
                                 
                                 
                                 ; ***** PORTE ************************
                                 ; PORTE - Data Register, Port E
                                 .equ	PORTE0	= 0	; 
                                 .equ	PE0	= 0	; For compatibility
                                 .equ	PORTE1	= 1	; 
                                 .equ	PE1	= 1	; For compatibility
                                 .equ	PORTE2	= 2	; 
                                 .equ	PE2	= 2	; For compatibility
                                 .equ	PORTE3	= 3	; 
                                 .equ	PE3	= 3	; For compatibility
                                 .equ	PORTE4	= 4	; 
                                 .equ	PE4	= 4	; For compatibility
                                 .equ	PORTE5	= 5	; 
                                 .equ	PE5	= 5	; For compatibility
                                 .equ	PORTE6	= 6	; 
                                 .equ	PE6	= 6	; For compatibility
                                 .equ	PORTE7	= 7	; 
                                 .equ	PE7	= 7	; For compatibility
                                 
                                 ; DDRE - Data Direction Register, Port E
                                 .equ	DDE0	= 0	; 
                                 .equ	DDE1	= 1	; 
                                 .equ	DDE2	= 2	; 
                                 .equ	DDE3	= 3	; 
                                 .equ	DDE4	= 4	; 
                                 .equ	DDE5	= 5	; 
                                 .equ	DDE6	= 6	; 
                                 .equ	DDE7	= 7	; 
                                 
                                 ; PINE - Input Pins, Port E
                                 .equ	PINE0	= 0	; 
                                 .equ	PINE1	= 1	; 
                                 .equ	PINE2	= 2	; 
                                 .equ	PINE3	= 3	; 
                                 .equ	PINE4	= 4	; 
                                 .equ	PINE5	= 5	; 
                                 .equ	PINE6	= 6	; 
                                 .equ	PINE7	= 7	; 
                                 
                                 
                                 ; ***** PORTF ************************
                                 ; PORTF - Data Register, Port F
                                 .equ	PORTF0	= 0	; 
                                 .equ	PF0	= 0	; For compatibility
                                 .equ	PORTF1	= 1	; 
                                 .equ	PF1	= 1	; For compatibility
                                 .equ	PORTF2	= 2	; 
                                 .equ	PF2	= 2	; For compatibility
                                 .equ	PORTF3	= 3	; 
                                 .equ	PF3	= 3	; For compatibility
                                 .equ	PORTF4	= 4	; 
                                 .equ	PF4	= 4	; For compatibility
                                 .equ	PORTF5	= 5	; 
                                 .equ	PF5	= 5	; For compatibility
                                 .equ	PORTF6	= 6	; 
                                 .equ	PF6	= 6	; For compatibility
                                 .equ	PORTF7	= 7	; 
                                 .equ	PF7	= 7	; For compatibility
                                 
                                 ; DDRF - Data Direction Register, Port F
                                 .equ	DDF0	= 0	; 
                                 .equ	DDF1	= 1	; 
                                 .equ	DDF2	= 2	; 
                                 .equ	DDF3	= 3	; 
                                 .equ	DDF4	= 4	; 
                                 .equ	DDF5	= 5	; 
                                 .equ	DDF6	= 6	; 
                                 .equ	DDF7	= 7	; 
                                 
                                 ; PINF - Input Pins, Port F
                                 .equ	PINF0	= 0	; 
                                 .equ	PINF1	= 1	; 
                                 .equ	PINF2	= 2	; 
                                 .equ	PINF3	= 3	; 
                                 .equ	PINF4	= 4	; 
                                 .equ	PINF5	= 5	; 
                                 .equ	PINF6	= 6	; 
                                 .equ	PINF7	= 7	; 
                                 
                                 
                                 ; ***** PORTG ************************
                                 ; PORTG - Data Register, Port G
                                 .equ	PORTG0	= 0	; 
                                 .equ	PG0	= 0	; For compatibility
                                 .equ	PORTG1	= 1	; 
                                 .equ	PG1	= 1	; For compatibility
                                 .equ	PORTG2	= 2	; 
                                 .equ	PG2	= 2	; For compatibility
                                 .equ	PORTG3	= 3	; 
                                 .equ	PG3	= 3	; For compatibility
                                 .equ	PORTG4	= 4	; 
                                 .equ	PG4	= 4	; For compatibility
                                 
                                 ; DDRG - Data Direction Register, Port G
                                 .equ	DDG0	= 0	; 
                                 .equ	DDG1	= 1	; 
                                 .equ	DDG2	= 2	; 
                                 .equ	DDG3	= 3	; 
                                 .equ	DDG4	= 4	; 
                                 
                                 ; PING - Input Pins, Port G
                                 .equ	PING0	= 0	; 
                                 .equ	PING1	= 1	; 
                                 .equ	PING2	= 2	; 
                                 .equ	PING3	= 3	; 
                                 .equ	PING4	= 4	; 
                                 
                                 
                                 ; ***** TIMER_COUNTER_0 **************
                                 ; TCCR0 - Timer/Counter Control Register
                                 .equ	CS00	= 0	; Clock Select 0
                                 .equ	CS01	= 1	; Clock Select 1
                                 .equ	CS02	= 2	; Clock Select 2
                                 .equ	WGM01	= 3	; Waveform Generation Mode 1
                                 .equ	CTC0	= WGM01	; For compatibility
                                 .equ	COM00	= 4	; Compare match Output Mode 0
                                 .equ	COM01	= 5	; Compare Match Output Mode 1
                                 .equ	WGM00	= 6	; Waveform Generation Mode 0
                                 .equ	PWM0	= WGM00	; For compatibility
                                 .equ	FOC0	= 7	; Force Output Compare
                                 
                                 ; TCNT0 - Timer/Counter Register
                                 .equ	TCNT0_0	= 0	; 
                                 .equ	TCNT0_1	= 1	; 
                                 .equ	TCNT0_2	= 2	; 
                                 .equ	TCNT0_3	= 3	; 
                                 .equ	TCNT0_4	= 4	; 
                                 .equ	TCNT0_5	= 5	; 
                                 .equ	TCNT0_6	= 6	; 
                                 .equ	TCNT0_7	= 7	; 
                                 
                                 ; OCR0 - Output Compare Register
                                 .equ	OCR0_0	= 0	; 
                                 .equ	OCR0_1	= 1	; 
                                 .equ	OCR0_2	= 2	; 
                                 .equ	OCR0_3	= 3	; 
                                 .equ	OCR0_4	= 4	; 
                                 .equ	OCR0_5	= 5	; 
                                 .equ	OCR0_6	= 6	; 
                                 .equ	OCR0_7	= 7	; 
                                 
                                 ; ASSR - Asynchronus Status Register
                                 .equ	TCR0UB	= 0	; Timer/Counter Control Register 0 Update Busy
                                 .equ	OCR0UB	= 1	; Output Compare register 0 Busy
                                 .equ	TCN0UB	= 2	; Timer/Counter0 Update Busy
                                 .equ	AS0	= 3	; Asynchronus Timer/Counter 0
                                 
                                 ; TIMSK - Timer/Counter Interrupt Mask Register
                                 .equ	TOIE0	= 0	; Timer/Counter0 Overflow Interrupt Enable
                                 .equ	OCIE0	= 1	; Timer/Counter0 Output Compare Match Interrupt register
                                 
                                 ; TIFR - Timer/Counter Interrupt Flag register
                                 .equ	TOV0	= 0	; Timer/Counter0 Overflow Flag
                                 .equ	OCF0	= 1	; Output Compare Flag 0
                                 
                                 ; SFIOR - Special Function IO Register
                                 ;.equ	PSR0	= 1	; Prescaler Reset Timer/Counter0
                                 ;.equ	TSM	= 7	; Timer/Counter Synchronization Mode
                                 
                                 
                                 ; ***** TIMER_COUNTER_1 **************
                                 ; TIMSK - Timer/Counter Interrupt Mask Register
                                 .equ	TOIE1	= 2	; Timer/Counter1 Overflow Interrupt Enable
                                 .equ	OCIE1B	= 3	; Timer/Counter1 Output CompareB Match Interrupt Enable
                                 .equ	OCIE1A	= 4	; Timer/Counter1 Output CompareA Match Interrupt Enable
                                 .equ	TICIE1	= 5	; Timer/Counter1 Input Capture Interrupt Enable
                                 
                                 ; ETIMSK - Extended Timer/Counter Interrupt Mask Register
                                 .equ	OCIE1C	= 0	; Timer/Counter 1, Output Compare Match C Interrupt Enable
                                 
                                 ; TIFR - Timer/Counter Interrupt Flag register
                                 .equ	TOV1	= 2	; Timer/Counter1 Overflow Flag
                                 .equ	OCF1B	= 3	; Output Compare Flag 1B
                                 .equ	OCF1A	= 4	; Output Compare Flag 1A
                                 .equ	ICF1	= 5	; Input Capture Flag 1
                                 
                                 ; ETIFR - Extended Timer/Counter Interrupt Flag register
                                 .equ	OCF1C	= 0	; Timer/Counter 1, Output Compare C Match Flag
                                 
                                 ; SFIOR - Special Function IO Register
                                 ;.equ	PSR321	= 0	; Prescaler Reset, T/C3, T/C2, T/C1
                                 ;.equ	TSM	= 7	; Timer/Counter Synchronization Mode
                                 
                                 ; TCCR1A - Timer/Counter1 Control Register A
                                 .equ	WGM10	= 0	; Waveform Generation Mode Bit 0
                                 .equ	PWM10	= WGM10	; For compatibility
                                 .equ	WGM11	= 1	; Waveform Generation Mode Bit 1
                                 .equ	PWM11	= WGM11	; For compatibility
                                 .equ	COM1C0	= 2	; Compare Output Mode 1C, bit 0
                                 .equ	COM1C1	= 3	; Compare Output Mode 1C, bit 1
                                 .equ	COM1B0	= 4	; Compare Output Mode 1B, bit 0
                                 .equ	COM1B1	= 5	; Compare Output Mode 1B, bit 1
                                 .equ	COM1A0	= 6	; Compare Ouput Mode 1A, bit 0
                                 .equ	COM1A1	= 7	; Compare Output Mode 1A, bit 1
                                 
                                 ; TCCR1B - Timer/Counter1 Control Register B
                                 .equ	CS10	= 0	; Clock Select bit 0
                                 .equ	CS11	= 1	; Clock Select 1 bit 1
                                 .equ	CS12	= 2	; Clock Select1 bit 2
                                 .equ	WGM12	= 3	; Waveform Generation Mode
                                 .equ	CTC10	= WGM12	; For compatibility
                                 .equ	WGM13	= 4	; Waveform Generation Mode
                                 .equ	CTC11	= WGM13	; For compatibility
                                 .equ	ICES1	= 6	; Input Capture 1 Edge Select
                                 .equ	ICNC1	= 7	; Input Capture 1 Noise Canceler
                                 
                                 ; TCCR1C - Timer/Counter1 Control Register C
                                 .equ	FOC1C	= 5	; Force Output Compare for channel C
                                 .equ	FOC1B	= 6	; Force Output Compare for channel B
                                 .equ	FOC1A	= 7	; Force Output Compare for channel A
                                 
                                 
                                 ; ***** TIMER_COUNTER_2 **************
                                 ; TCCR2 - Timer/Counter Control Register
                                 .equ	CS20	= 0	; Clock Select
                                 .equ	CS21	= 1	; Clock Select
                                 .equ	CS22	= 2	; Clock Select
                                 .equ	WGM21	= 3	; Waveform Generation Mode
                                 .equ	CTC2	= WGM21	; For compatibility
                                 .equ	COM20	= 4	; Compare Match Output Mode
                                 .equ	COM21	= 5	; Compare Match Output Mode
                                 .equ	WGM20	= 6	; Wafeform Generation Mode
                                 .equ	PWM2	= WGM20	; For compatibility
                                 .equ	FOC2	= 7	; Force Output Compare
                                 
                                 ; TCNT2 - Timer/Counter Register
                                 .equ	TCNT2_0	= 0	; Timer/Counter Register Bit 0
                                 .equ	TCNT2_1	= 1	; Timer/Counter Register Bit 1
                                 .equ	TCNT2_2	= 2	; Timer/Counter Register Bit 2
                                 .equ	TCNT2_3	= 3	; Timer/Counter Register Bit 3
                                 .equ	TCNT2_4	= 4	; Timer/Counter Register Bit 4
                                 .equ	TCNT2_5	= 5	; Timer/Counter Register Bit 5
                                 .equ	TCNT2_6	= 6	; Timer/Counter Register Bit 6
                                 .equ	TCNT2_7	= 7	; Timer/Counter Register Bit 7
                                 
                                 ; OCR2 - Output Compare Register
                                 .equ	OCR2_0	= 0	; Output Compare Register Bit 0
                                 .equ	OCR2_1	= 1	; Output Compare Register Bit 1
                                 .equ	OCR2_2	= 2	; Output Compare Register Bit 2
                                 .equ	OCR2_3	= 3	; Output Compare Register Bit 3
                                 .equ	OCR2_4	= 4	; Output Compare Register Bit 4
                                 .equ	OCR2_5	= 5	; Output Compare Register Bit 5
                                 .equ	OCR2_6	= 6	; Output Compare Register Bit 6
                                 .equ	OCR2_7	= 7	; Output Compare Register Bit 7
                                 
                                 ; TIMSK - 
                                 .equ	TOIE2	= 6	; 
                                 .equ	OCIE2	= 7	; 
                                 
                                 ; TIFR - Timer/Counter Interrupt Flag Register
                                 .equ	TOV2	= 6	; Timer/Counter2 Overflow Flag
                                 .equ	OCF2	= 7	; Output Compare Flag 2
                                 
                                 
                                 ; ***** TIMER_COUNTER_3 **************
                                 ; ETIMSK - Extended Timer/Counter Interrupt Mask Register
                                 .equ	OCIE3C	= 1	; Timer/Counter3, Output Compare Match Interrupt Enable
                                 .equ	TOIE3	= 2	; Timer/Counter3 Overflow Interrupt Enable
                                 .equ	OCIE3B	= 3	; Timer/Counter3 Output CompareB Match Interrupt Enable
                                 .equ	OCIE3A	= 4	; Timer/Counter3 Output CompareA Match Interrupt Enable
                                 .equ	TICIE3	= 5	; Timer/Counter3 Input Capture Interrupt Enable
                                 
                                 ; ETIFR - Extended Timer/Counter Interrupt Flag register
                                 .equ	OCF3C	= 1	; Timer/Counter3 Output Compare C Match Flag
                                 .equ	TOV3	= 2	; Timer/Counter3 Overflow Flag
                                 .equ	OCF3B	= 3	; Output Compare Flag 1B
                                 .equ	OCF3A	= 4	; Output Compare Flag 1A
                                 .equ	ICF3	= 5	; Input Capture Flag 1
                                 
                                 ; SFIOR - Special Function IO Register
                                 ;.equ	PSR321	= 0	; Prescaler Reset, T/C3, T/C2, T/C1
                                 ;.equ	PSR1	= PSR321	; For compatibility
                                 ;.equ	PSR2	= PSR321	; For compatibility
                                 ;.equ	TSM	= 7	; Timer/Counter Synchronization Mode
                                 
                                 ; TCCR3A - Timer/Counter3 Control Register A
                                 .equ	WGM30	= 0	; Waveform Generation Mode Bit 0
                                 .equ	PWM30	= WGM30	; For compatibility
                                 .equ	WGM31	= 1	; Waveform Generation Mode Bit 1
                                 .equ	PWM31	= WGM31	; For compatibility
                                 .equ	COM3C0	= 2	; Compare Output Mode 3C, bit 0
                                 .equ	COM3C1	= 3	; Compare Output Mode 3C, bit 1
                                 .equ	COM3B0	= 4	; Compare Output Mode 3B, bit 0
                                 .equ	COM3B1	= 5	; Compare Output Mode 3B, bit 1
                                 .equ	COM3A0	= 6	; Comparet Ouput Mode 3A, bit 0
                                 .equ	COM3A1	= 7	; Compare Output Mode 3A, bit 1
                                 
                                 ; TCCR3B - Timer/Counter3 Control Register B
                                 .equ	CS30	= 0	; Clock Select 3 bit 0
                                 .equ	CS31	= 1	; Clock Select 3 bit 1
                                 .equ	CS32	= 2	; Clock Select3 bit 2
                                 .equ	WGM32	= 3	; Waveform Generation Mode
                                 .equ	CTC30	= WGM32	; For compatibility
                                 .equ	WGM33	= 4	; Waveform Generation Mode
                                 .equ	CTC31	= WGM33	; For compatibility
                                 .equ	ICES3	= 6	; Input Capture 3 Edge Select
                                 .equ	ICNC3	= 7	; Input Capture 3  Noise Canceler
                                 
                                 ; TCCR3C - Timer/Counter3 Control Register C
                                 .equ	FOC3C	= 5	; Force Output Compare for channel C
                                 .equ	FOC3B	= 6	; Force Output Compare for channel B
                                 .equ	FOC3A	= 7	; Force Output Compare for channel A
                                 
                                 ; TCNT3L - Timer/Counter3 Low Byte
                                 .equ	TCN3L0	= 0	; Timer/Counter 3 bit 0
                                 .equ	TCN3L1	= 1	; Timer/Counter 3 bit 1
                                 .equ	TCN3L2	= 2	; Timer/Counter 3 bit 2
                                 .equ	TCN3L3	= 3	; Timer/Counter 3 bit 3
                                 .equ	TCN3L4	= 4	; Timer/Counter 3 bit 4
                                 .equ	TCN3L5	= 5	; Timer/Counter 3 bit 5
                                 .equ	TCN3L6	= 6	; Timer/Counter 3 bit 6
                                 .equ	TCN3L7	= 7	; Timer/Counter 3 bit 7
                                 
                                 
                                 ; ***** WATCHDOG *********************
                                 ; WDTCR - Watchdog Timer Control Register
                                 .equ	WDTCSR	= WDTCR	; For compatibility
                                 .equ	WDP0	= 0	; Watch Dog Timer Prescaler bit 0
                                 .equ	WDP1	= 1	; Watch Dog Timer Prescaler bit 1
                                 .equ	WDP2	= 2	; Watch Dog Timer Prescaler bit 2
                                 .equ	WDE	= 3	; Watch Dog Enable
                                 .equ	WDCE	= 4	; Watchdog Change Enable
                                 .equ	WDTOE	= WDCE	; For compatibility
                                 
                                 
                                 ; ***** AD_CONVERTER *****************
                                 ; ADMUX - The ADC multiplexer Selection Register
                                 .equ	MUX0	= 0	; Analog Channel and Gain Selection Bits
                                 .equ	MUX1	= 1	; Analog Channel and Gain Selection Bits
                                 .equ	MUX2	= 2	; Analog Channel and Gain Selection Bits
                                 .equ	MUX3	= 3	; Analog Channel and Gain Selection Bits
                                 .equ	MUX4	= 4	; Analog Channel and Gain Selection Bits
                                 .equ	ADLAR	= 5	; Left Adjust Result
                                 .equ	REFS0	= 6	; Reference Selection Bit 0
                                 .equ	REFS1	= 7	; Reference Selection Bit 1
                                 
                                 ; ADCSRA - The ADC Control and Status register
                                 .equ	ADCSR	= ADCSRA	; For compatibility
                                 .equ	ADPS0	= 0	; ADC  Prescaler Select Bits
                                 .equ	ADPS1	= 1	; ADC  Prescaler Select Bits
                                 .equ	ADPS2	= 2	; ADC  Prescaler Select Bits
                                 .equ	ADIE	= 3	; ADC Interrupt Enable
                                 .equ	ADIF	= 4	; ADC Interrupt Flag
                                 .equ	ADFR	= 5	; ADC  Free Running Select
                                 .equ	ADSC	= 6	; ADC Start Conversion
                                 .equ	ADEN	= 7	; ADC Enable
                                 
                                 ; ADCH - ADC Data Register High Byte
                                 .equ	ADCH0	= 0	; ADC Data Register High Byte Bit 0
                                 .equ	ADCH1	= 1	; ADC Data Register High Byte Bit 1
                                 .equ	ADCH2	= 2	; ADC Data Register High Byte Bit 2
                                 .equ	ADCH3	= 3	; ADC Data Register High Byte Bit 3
                                 .equ	ADCH4	= 4	; ADC Data Register High Byte Bit 4
                                 .equ	ADCH5	= 5	; ADC Data Register High Byte Bit 5
                                 .equ	ADCH6	= 6	; ADC Data Register High Byte Bit 6
                                 .equ	ADCH7	= 7	; ADC Data Register High Byte Bit 7
                                 
                                 ; ADCL - ADC Data Register Low Byte
                                 .equ	ADCL0	= 0	; ADC Data Register Low Byte Bit 0
                                 .equ	ADCL1	= 1	; ADC Data Register Low Byte Bit 1
                                 .equ	ADCL2	= 2	; ADC Data Register Low Byte Bit 2
                                 .equ	ADCL3	= 3	; ADC Data Register Low Byte Bit 3
                                 .equ	ADCL4	= 4	; ADC Data Register Low Byte Bit 4
                                 .equ	ADCL5	= 5	; ADC Data Register Low Byte Bit 5
                                 .equ	ADCL6	= 6	; ADC Data Register Low Byte Bit 6
                                 .equ	ADCL7	= 7	; ADC Data Register Low Byte Bit 7
                                 
                                 
                                 
                                 ; ***** LOCKSBITS ********************************************************
                                 .equ	LB1	= 0	; Lock bit
                                 .equ	LB2	= 1	; Lock bit
                                 .equ	BLB01	= 2	; Boot Lock bit
                                 .equ	BLB02	= 3	; Boot Lock bit
                                 .equ	BLB11	= 4	; Boot lock bit
                                 .equ	BLB12	= 5	; Boot lock bit
                                 
                                 
                                 ; ***** FUSES ************************************************************
                                 ; LOW fuse bits
                                 .equ	CKSEL0	= 0	; Select Clock Source
                                 .equ	CKSEL1	= 1	; Select Clock Source
                                 .equ	CKSEL2	= 2	; Select Clock Source
                                 .equ	CKSEL3	= 3	; Select Clock Source
                                 .equ	SUT0	= 4	; Select start-up time
                                 .equ	SUT1	= 5	; Select start-up time
                                 .equ	BODEN	= 6	; Brown out detector enable
                                 .equ	BODLEVEL	= 7	; Brown out detector trigger level
                                 
                                 ; HIGH fuse bits
                                 .equ	BOOTRST	= 0	; Select Reset Vector
                                 .equ	BOOTSZ0	= 1	; Select Boot Size
                                 .equ	BOOTSZ1	= 2	; Select Boot Size
                                 .equ	EESAVE	= 3	; EEPROM memory is preserved through chip erase
                                 .equ	CKOPT	= 4	; Oscillator Options
                                 .equ	SPIEN	= 5	; Enable Serial programming and Data Downloading
                                 .equ	JTAGEN	= 6	; Enable JTAG
                                 .equ	OCDEN	= 7	; Enable OCD
                                 
                                 ; EXTENDED fuse bits
                                 .equ	WDTON	= 0	; Watchdog timer always on
                                 .equ	M103C	= 1	; ATmega103 compatibility mode
                                 
                                 
                                 
                                 ; ***** CPU REGISTER DEFINITIONS *****************************************
                                 .def	XH	= r27
                                 .def	XL	= r26
                                 .def	YH	= r29
                                 .def	YL	= r28
                                 .def	ZH	= r31
                                 .def	ZL	= r30
                                 
                                 
                                 
                                 ; ***** DATA MEMORY DECLARATIONS *****************************************
                                 .equ	FLASHEND	= 0xffff	; Note: Word address
                                 .equ	IOEND	= 0x00ff
                                 .equ	SRAM_START	= 0x0100
                                 .equ	SRAM_SIZE	= 4096
                                 .equ	RAMEND	= 0x10ff
                                 .equ	XRAMEND	= 0xffff
                                 .equ	E2END	= 0x0fff
                                 .equ	EEPROMEND	= 0x0fff
                                 .equ	EEADRBITS	= 12
                                 #pragma AVRPART MEMORY PROG_FLASH 131072
                                 #pragma AVRPART MEMORY EEPROM 4096
                                 #pragma AVRPART MEMORY INT_SRAM SIZE 4096
                                 #pragma AVRPART MEMORY INT_SRAM START_ADDR 0x100
                                 
                                 
                                 
                                 ; ***** BOOTLOADER DECLARATIONS ******************************************
                                 .equ	NRWW_START_ADDR	= 0xf000
                                 .equ	NRWW_STOP_ADDR	= 0xffff
                                 .equ	RWW_START_ADDR	= 0x0
                                 .equ	RWW_STOP_ADDR	= 0xefff
                                 .equ	PAGESIZE	= 128
                                 .equ	FIRSTBOOTSTART	= 0xfe00
                                 .equ	SECONDBOOTSTART	= 0xfc00
                                 .equ	THIRDBOOTSTART	= 0xf800
                                 .equ	FOURTHBOOTSTART	= 0xf000
                                 .equ	SMALLBOOTSTART	= FIRSTBOOTSTART
                                 .equ	LARGEBOOTSTART	= FOURTHBOOTSTART
                                 
                                 
                                 
                                 ; ***** INTERRUPT VECTORS ************************************************
                                 .equ	INT0addr	= 0x0002	; External Interrupt Request 0
                                 .equ	INT1addr	= 0x0004	; External Interrupt Request 1
                                 .equ	INT2addr	= 0x0006	; External Interrupt Request 2
                                 .equ	INT3addr	= 0x0008	; External Interrupt Request 3
                                 .equ	INT4addr	= 0x000a	; External Interrupt Request 4
                                 .equ	INT5addr	= 0x000c	; External Interrupt Request 5
                                 .equ	INT6addr	= 0x000e	; External Interrupt Request 6
                                 .equ	INT7addr	= 0x0010	; External Interrupt Request 7
                                 .equ	OC2addr	= 0x0012	; Timer/Counter2 Compare Match
                                 .equ	OVF2addr	= 0x0014	; Timer/Counter2 Overflow
                                 .equ	ICP1addr	= 0x0016	; Timer/Counter1 Capture Event
                                 .equ	OC1Aaddr	= 0x0018	; Timer/Counter1 Compare Match A
                                 .equ	OC1Baddr	= 0x001a	; Timer/Counter Compare Match B
                                 .equ	OVF1addr	= 0x001c	; Timer/Counter1 Overflow
                                 .equ	OC0addr	= 0x001e	; Timer/Counter0 Compare Match
                                 .equ	OVF0addr	= 0x0020	; Timer/Counter0 Overflow
                                 .equ	SPIaddr	= 0x0022	; SPI Serial Transfer Complete
                                 .equ	URXC0addr	= 0x0024	; USART0, Rx Complete
                                 .equ	UDRE0addr	= 0x0026	; USART0 Data Register Empty
                                 .equ	UTXC0addr	= 0x0028	; USART0, Tx Complete
                                 .equ	ADCCaddr	= 0x002a	; ADC Conversion Complete
                                 .equ	ERDYaddr	= 0x002c	; EEPROM Ready
                                 .equ	ACIaddr	= 0x002e	; Analog Comparator
                                 .equ	OC1Caddr	= 0x0030	; Timer/Counter1 Compare Match C
                                 .equ	ICP3addr	= 0x0032	; Timer/Counter3 Capture Event
                                 .equ	OC3Aaddr	= 0x0034	; Timer/Counter3 Compare Match A
                                 .equ	OC3Baddr	= 0x0036	; Timer/Counter3 Compare Match B
                                 .equ	OC3Caddr	= 0x0038	; Timer/Counter3 Compare Match C
                                 .equ	OVF3addr	= 0x003a	; Timer/Counter3 Overflow
                                 .equ	URXC1addr	= 0x003c	; USART1, Rx Complete
                                 .equ	UDRE1addr	= 0x003e	; USART1, Data Register Empty
                                 .equ	UTXC1addr	= 0x0040	; USART1, Tx Complete
                                 .equ	TWIaddr	= 0x0042	; 2-wire Serial Interface
                                 .equ	SPMRaddr	= 0x0044	; Store Program Memory Read
                                 
                                 .equ	INT_VECTORS_SIZE	= 70	; size in words
                                 
                                 #endif  /* _M128DEF_INC_ */
                                 
                                 ; ***** END OF FILE ******************************************************
                                 
                                 
                                 ; purpose library, definition of addresses and constants
                                 ; 20171114 A.S.
                                 
                                 ; === definitions  ===
                                 .list
                                 .include "macros.asm"
                                 
                                 ; purpose library, general-purpose macros
                                 ; author (c) R.Holzer (adapted MICRO210/EE208 A.Schmid)
                                 ; modified to include newer macros used for project
                                 
                                 ; ==============
                                 ;	display macros
                                 ; ==============
                                 .macro DISPLAY1 
                                 
                                 	call	LCD_init
                                 	ldi	zl, low(2*@0)
                                 	ldi	zh, high(2*@0)
                                 	call	LCD_putstring
                                 
                                 .endmacro
                                 
                                 .macro DISPLAY2
                                 
                                 	call	LCD_init
                                 	ldi	zl, low(2*@0)
                                 	ldi	zh, high(2*@0)
                                 	call	LCD_putstring
                                 	ldi	zl, low(2*@1)
                                 	ldi	zh, high(2*@1)
                                 	ldi	a0, 0x40
                                 	call	LCD_pos
                                 	call	LCD_putstring
                                 
                                 .endmacro
                                 
                                 ; ==============
                                 ; 	trivia macros
                                 ; ==============
                                 
                                 ; --- display question and answers as long as answer buttons not pressed
                                 
                                 .macro QUESTION ; question: str0, str1 answer: str2, str3, str4, str5
                                 question_start:
                                 display1:
                                 	call	LCD_init
                                 	ldi	zl, low(2*@0)
                                 	ldi	zh, high(2*@0)
                                 	call	LCD_putstring
                                 	ldi	zl, low(2*@1)
                                 	ldi	zh, high(2*@1)
                                 	ldi	a0, 0x40
                                 	call	LCD_pos
                                 	call	LCD_putstring
                                 	call reset_kpd
                                 	call check_reset
                                 	mov b0, a0
                                 	andi a0, 0b10000000
                                 	breq PC+2
                                 	jmp question_end
                                 	cpi b0, 0x48
                                 	brne display1
                                 display2:
                                 	call	LCD_init
                                 	ldi	zl, low(2*@2)
                                 	ldi	zh, high(2*@2)
                                 	call	LCD_putstring
                                 	ldi	zl, low(2*@3)
                                 	ldi	zh, high(2*@3)
                                 	ldi	a0, 0x40
                                 	call	LCD_pos
                                 	call	LCD_putstring
                                 	call reset_kpd
                                 	call check_reset
                                 	mov b0, a0
                                 	andi a0, 0b10000000
                                 	breq PC+2
                                 	jmp question_end
                                 	cpi b0, 0x48
                                 	brne display2
                                 display3:
                                 	call	LCD_init
                                 	ldi	zl, low(2*@4)
                                 	ldi	zh, high(2*@4)
                                 	call	LCD_putstring
                                 	ldi	zl, low(2*@5)
                                 	ldi	zh, high(2*@5)
                                 	ldi	a0, 0x40
                                 	call	LCD_pos
                                 	call	LCD_putstring
                                 	call reset_kpd
                                 	call check_reset
                                 	mov b0, a0
                                 	andi a0, 0b10000000
                                 	breq PC+2
                                 	jmp question_end
                                 	cpi b0, 0x48
                                 	brne display3
                                 	jmp question_start
                                 question_end:
                                 .endmacro
                                 
                                 ; --- set T in SREG if answer correct
                                 .macro COMPARE
                                 	ldi zl, low(2*@0)
                                 	ldi zh, high(2*@0)
                                 	lpm
                                 	cp b0, r0
                                 	brne PC+2
                                 	set
                                 .endmacro
                                 
                                 ; --- print score on LCD as well as fail or pass message
                                 .macro PRINT_SCORE
                                 	call LCD_clear
                                 	brts PC+2
                                 	jmp incorrect
                                 correct:
                                 	DISPLAY1 strcorrect
                                 	jmp score
                                 incorrect:
                                 	DISPLAY1 strfalse
                                 score:
                                 	CLR4 a3, a2, a1, a0
                                 	mov a0, @0
                                 	PRINTF LCD
                                 .db "Score:",FDEC,a,0
                                 .endmacro
                                 
                                 
                                 ; ==============
                                 ; 	pointers
                                 ; ==============
                                 
                                 ; --- loading an immediate into a pointer XYZ,SP ---
                                 .macro 	LDIX	; sram
                                 	ldi	xl, low(@0)
                                 	ldi	xh,high(@0)
                                 	.endmacro	
                                 .macro 	LDIY	; sram	
                                 	ldi	yl, low(@0)
                                 	ldi	yh,high(@0)
                                 	.endmacro	
                                 .macro 	LDIZ	; sram
                                 	ldi	zl, low(@0)
                                 	ldi	zh,high(@0)
                                 	
                                 	.endmacro
                                 .macro	LDZD	; sram, reg	; sram+reg -> Z
                                 	mov	zl,@1
                                 	clr	zh
                                 	subi	zl, low(-@0)
                                 	sbci	zh,high(-@0)
                                 	.endmacro
                                 .macro	LDSP	; sram
                                 	ldi	r16, low(@0)
                                 	out	spl,r16
                                 	ldi	r16,high(@0)
                                 	out	sph,r16
                                 	.endmacro
                                 
                                 ; --- load/store SRAM addr into pointer XYZ ---	
                                 .macro 	LDSX	; sram
                                 	lds	xl,@0
                                 	lds	xh,@0+1
                                 	.endmacro
                                 .macro 	LDSY	; sram
                                 	lds	yl,@0
                                 	lds	yh,@0+1
                                 	.endmacro
                                 .macro 	LDSZ	; sram
                                 	lds	zl,@0
                                 	lds	zh,@0+1
                                 	.endmacro
                                 .macro 	STSX	; sram
                                 	sts	@0,  xl
                                 	sts	@0+1,xh
                                 	.endmacro	
                                 .macro 	STSY	; sram
                                 	sts	@0,  yl
                                 	sts	@0+1,yh
                                 	.endmacro
                                 .macro 	STSZ	; sram
                                 	sts	@0,  zl
                                 	sts	@0+1,zh
                                 	.endmacro	
                                 
                                 ; --- push/pop pointer XYZ ---
                                 .macro	PUSHX			; push X
                                 	push	xl
                                 	push	xh
                                 	.endmacro
                                 .macro	POPX			; pop X
                                 	pop	xh
                                 	pop	xl
                                 	.endmacro
                                 	
                                 .macro	PUSHY			; push Y
                                 	push	yl
                                 	push	yh
                                 	.endmacro
                                 .macro	POPY			; pop Y
                                 	pop	yh
                                 	pop	yl
                                 	.endmacro
                                 
                                 .macro	PUSHZ			; push Z
                                 	push	zl
                                 	push	zh
                                 	.endmacro
                                 .macro	POPZ			; pop Z
                                 	pop	zh
                                 	pop	zl
                                 	.endmacro
                                 
                                 ; --- multiply/divide Z ---	
                                 .macro	MUL2Z			; multiply Z by 2
                                 	lsl	zl
                                 	rol	zh
                                 	.endmacro
                                 .macro	DIV2Z			; divide Z by 2
                                 	lsr	zh
                                 	ror	zl
                                 	.endmacro
                                 
                                 ; --- add register to pointer XYZ ---	
                                 .macro	ADDX	;reg		; x <- y+reg
                                 	add	xl,@0
                                 	brcc	PC+2
                                 	subi	xh,-1		; add carry
                                 	.endmacro
                                 .macro	ADDY	;reg		; y <- y+reg
                                 	add	yl,@0
                                 	brcc	PC+2
                                 	subi	yh,-1		; add carry
                                 	.endmacro
                                 .macro	ADDZ	;reg		; z <- z+reg
                                 	add	zl,@0
                                 	brcc	PC+2
                                 	subi	zh,-1		; add carry
                                 	.endmacro
                                 
                                 ; ===================
                                 ; 	miscellaneous
                                 ; ===================
                                 
                                 ; --- output/store (regular I/O space) immediate value ---
                                 .macro	OUTI	; port,k	output immediate value to port
                                 	ldi	w,@1
                                 	out	@0,w
                                 	.endmacro
                                 
                                 ; --- output/store (extended I/O space) immediate value ---
                                 .macro OUTEI	; port,k    output immediate value to port
                                 	ldi	w,@1
                                 	sts	@0,w
                                 	.endmacro
                                 
                                 ; --- add immediate value ---
                                 .macro	ADDI
                                 	subi	@0,-@1
                                 	.endmacro
                                 .macro	ADCI
                                 	sbci	@0,-@1
                                 	.endmacro
                                 
                                 ; --- inc/dec with range limitation ---
                                 .macro	INC_LIM	; reg,limit
                                 	cpi	@0,@1
                                 	brlo	PC+3
                                 	ldi	@0,@1	
                                 	rjmp	PC+2
                                 	inc	@0
                                 	.endmacro
                                 
                                 .macro	DEC_LIM	; reg,limit
                                 	cpi	@0,@1
                                 	breq	PC+5
                                 	brlo	PC+3
                                 	dec	@0
                                 	rjmp	PC+2
                                 	ldi	@0,@1
                                 	.endmacro
                                 
                                 ; --- inc/dec with cyclic range ---
                                 .macro	INC_CYC	; reg,low,high
                                 	cpi	@0,@2
                                 	brsh	_low	; reg>=high then reg=low
                                 	cpi	@0,@1
                                 	brlo	_low	; reg< low  then reg=low
                                 	inc	@0
                                 	rjmp	_done
                                 _low:	ldi	@0,@1
                                 _done:	
                                     .endmacro
                                 	
                                 .macro	DEC_CYC	; reg,low,high
                                 	cpi	@0,@1
                                 	breq	_high	; reg=low then reg=high
                                 	brlo	_high	; reg<low then reg=high
                                 	dec	@0	
                                 	cpi	@0,@2
                                 	brsh	_high	; reg>=high then high
                                 	rjmp	_done
                                 _high:	ldi	@0,@2
                                 _done:	
                                 	.endmacro
                                 
                                 .macro	INCDEC	;port,b1,b2,reg,low,high
                                 	sbic	@0,@1
                                 	rjmp	PC+6
                                 
                                 	cpi	@3,@5
                                 	brlo	PC+3
                                 	ldi	@3,@4	
                                 	rjmp	PC+2
                                 	inc	@3
                                 
                                 	sbic	@0,@2
                                 	rjmp	PC+7
                                 	
                                 	cpi	@3,@4
                                 	breq	PC+5
                                 	brlo	PC+3
                                 	dec	@3
                                 	rjmp	PC+2
                                 	ldi	@3,@5
                                 	.endmacro		
                                 
                                 ; --- wait loops ---
                                 ; wait 10...196608 cycles
                                 .macro	WAIT_C	; k
                                 	ldi	w,  low((@0-7)/3)
                                 	mov	u,w			; u=LSB
                                 	ldi	w,high((@0-7)/3)+1	; w=MSB
                                 	dec	u
                                 	brne	PC-1
                                 	dec	u
                                 	dec	w
                                 	brne	PC-4
                                 	.endmacro
                                 
                                 ; wait micro-seconds (us)
                                 ; us = x*3*1000'000/clock)	==> x=us*clock/3000'000
                                 .macro	WAIT_US ; k
                                 	ldi	w, low((clock/1000*@0/3000)-1)
                                 	mov	u,w
                                 	ldi	w,high((clock/1000*@0/3000)-1)+1 ; set up: 3 cyles
                                 	dec	u
                                 	brne	PC-1		; inner loop: 3 cycles
                                 	dec	u		; adjustment for outer loop
                                 	dec	w
                                 	brne	PC-4
                                 	.endmacro
                                 
                                 ; wait mili-seconds (ms)
                                 .macro	WAIT_MS ; k
                                 	ldi	w, low(@0)
                                 	mov	u,w		; u = LSB	
                                 	ldi	w,high(@0)+1	; w = MSB
                                 wait_ms:
                                 	push	w		; wait 1000 usec
                                 	push	u
                                 	ldi	w, low((clock/3000)-5)	
                                 	mov	u,w
                                 	ldi	w,high((clock/3000)-5)+1
                                 	dec	u
                                 	brne	PC-1		; inner loop: 3 cycles
                                 	dec	u		; adjustment for outer loop
                                 	dec	w
                                 	brne	PC-4
                                 	pop	u
                                 	pop	w
                                 	
                                 	dec	u
                                 	brne	wait_ms
                                 	dec	w
                                 	brne	wait_ms
                                 	.endmacro
                                 
                                 ; --- conditional jumps/calls ---
                                 .macro	JC0			; jump if carry=0
                                 	brcs	PC+2	
                                 	rjmp	@0
                                 	.endmacro
                                 .macro	JC1			; jump if carry=1
                                 	brcc	PC+2	
                                 	rjmp	@0
                                 	.endmacro
                                 
                                 .macro	JK	; reg,k,addr	; jump if reg=k
                                 	cpi	@0,@1
                                 	breq	@2
                                 	.endmacro
                                 .macro	_JK	; reg,k,addr	; jump if reg=k
                                 	cpi	@0,@1
                                 	brne	PC+2
                                 	rjmp	@2
                                 	.endmacro	
                                 .macro	JNK	; reg,k,addr	; jump if not(reg=k)
                                 	cpi	@0,@1
                                 	brne	@2
                                 	.endmacro 
                                 
                                 .macro	CK	; reg,k,addr	; call if reg=k
                                 	cpi	@0,@1
                                 	brne	PC+2
                                 	rcall	@2
                                 	.endmacro
                                 .macro	CNK	; reg,k,addr	; call if not(reg=k)
                                 	cpi	@0,@1
                                 	breq	PC+2
                                 	rcall	@2
                                 	.endmacro 
                                 
                                 .macro	JSK	; sram,k,addr	; jump if sram=k
                                 	lds	w,@0
                                 	cpi	w,@1
                                 	breq	@2
                                 	.endmacro 
                                 .macro	JSNK	; sram,k,addr	; jump if not(sram=k)
                                 	lds	w,@0
                                 	cpi	w,@1
                                 	brne	@2
                                 	.endmacro
                                 
                                 ; --- loops ---
                                 .macro	DJNZ	; reg,addr	; decr and jump if not zero
                                 	dec	@0
                                 	brne	@1
                                 	.endmacro
                                 .macro	DJNK	; reg,k,addr	; decr and jump if not k
                                 	dec	@0
                                 	cpi	@0,@1
                                 	brne	@2
                                 	.endmacro
                                 
                                 .macro	IJNZ	; reg,addr	; inc and jump if not zero
                                 	inc	@0
                                 	brne	@1
                                 	.endmacro
                                 .macro	IJNK	; reg,k,addr	; inc and jump if not k
                                 	inc	@0
                                 	cpi	@0,@1
                                 	brne	@2
                                 	.endmacro
                                 .macro	_IJNK	; reg,k,addr	; inc and jump if not k
                                 	inc	@0
                                 	ldi	w,@1
                                 	cp	@0,w
                                 	brne	@2
                                 	.endmacro
                                 
                                 .macro	ISJNK	; sram,k,addr	; inc sram and jump if not k
                                 	lds	w,@0
                                 	inc	w
                                 	sts	@0,w
                                 	cpi	w,@1
                                 	brne	@2
                                 	.endmacro
                                 .macro	_ISJNK	; sram,k,addr	; inc sram and jump if not k
                                 	lds	w,@0
                                 	inc	w
                                 	sts	@0,w
                                 	cpi	w,@1
                                 	breq	PC+2	
                                 	rjmp	@2
                                 	.endmacro
                                 
                                 .macro	DSJNK	; sram,k,addr	; dec sram and jump if not k
                                 	lds	w,@0
                                 	dec	w
                                 	sts	@0,w
                                 	cpi	w,@1
                                 	brne	@2
                                 	.endmacro
                                 
                                 ; --- table lookup ---
                                 .macro	LOOKUP	;reg, index,tbl
                                 	push	ZL
                                 	push	ZH
                                 	mov	zl,@1		; move index into z
                                 	clr	zh
                                 	subi	zl, low(-2*@2)	; add base address of table
                                 	sbci	zh,high(-2*@2)	
                                 	lpm			; load program memory (into r0)
                                 	mov	@0,r0
                                 	pop	ZH
                                 	pop	ZL
                                 	.endmacro
                                 
                                 .macro	LOOKUP2	;r1,r0, index,tbl
                                 	mov	zl,@2		; move index into z
                                 	clr	zh
                                 	lsl	zl		; multiply by 2
                                 	rol	zh
                                 	subi	zl, low(-2*@3)	; add base address of table
                                 	sbci	zh,high(-2*@3)
                                 	lpm			; get LSB byte
                                 	mov	w,r0		; temporary store LSB in w
                                 	adiw	zl,1		; increment Z
                                 	lpm			; get MSB byte
                                 	mov	@0,r0		; mov MSB to res1
                                 	mov	@1,w		; mov LSB to res0
                                 	.endmacro
                                 
                                 .macro	LOOKUP4	;r3,r2,r1,r0, index,tbl
                                 	mov	zl,@4		; move index into z
                                 	clr	zh
                                 	lsl	zl		; multiply by 2
                                 	rol	zh
                                 	lsl	zl		; multiply by 2
                                 	rol	zh	
                                 	subi	zl, low(-2*@5)	; add base address of table
                                 	sbci	zh,high(-2*@5)
                                 	lpm
                                 	mov	@1,r0		; load high word LSB
                                 	adiw	zl,1
                                 	lpm
                                 	mov	@0,r0		; load high word MSB
                                 	adiw	zl,1
                                 	lpm
                                 	mov	@3,r0		; load low word LSB		
                                 	adiw	zl,1
                                 	lpm
                                 	mov	@2,r0		; load low word MSB
                                 	.endmacro
                                 
                                 .macro	LOOKDOWN ;reg,index,tbl
                                 	ldi	ZL, low(2*@2)	; load table address
                                 	ldi	ZH,high(2*@2)
                                 	clr	@1
                                 loop:	lpm
                                 	cp	r0,@0
                                 	breq	found
                                 	inc	@1 
                                 	adiw	ZL,1
                                 	tst	r0
                                 	breq	notfound
                                 	rjmp	loop
                                 notfound:
                                 	ldi	@1,-1
                                 found:	
                                 	.endmacro
                                 
                                 ; --- branch table ---
                                 .macro	C_TBL	; reg,tbl
                                 	ldi	ZL, low(2*@1)
                                 	ldi	ZH,high(2*@1)
                                 	lsl	@0
                                 	add	ZL,@0
                                 	brcc	PC+2
                                 	inc	ZH
                                 	lpm
                                 	push	r0
                                 	lpm
                                 	mov	zh,r0
                                 	pop	zl
                                 	icall
                                 	.endmacro
                                 .macro	J_TBL	; reg,tbl	
                                 	ldi	ZL, low(2*@1)
                                 	ldi	ZH,high(2*@1)
                                 	lsl	@0
                                 	add	ZL,@0
                                 	brcc	PC+2
                                 	inc	ZH
                                 	lpm
                                 	push	r0
                                 	lpm
                                 	mov	zh,r0
                                 	pop	zl	
                                 	ijmp
                                 	.endmacro
                                 
                                 .macro	BRANCH	; reg		; branching using the stack
                                 	ldi	w, low(tbl)
                                 	add	w,@0
                                 	push	w
                                 	ldi	w,high(tbl)
                                 	brcc	PC+2
                                 	inc	w
                                 	push	w
                                 	ret
                                 tbl:
                                 	.endmacro	
                                 
                                 ; --- multiply/division ---
                                 .macro	DIV2	; reg
                                 	lsr	@0
                                 	.endmacro
                                 .macro	DIV4	; reg
                                 	lsr	@0
                                 	lsr	@0
                                 	.endmacro	
                                 .macro	DIV8	; reg
                                 	lsr	@0
                                 	lsr	@0
                                 	lsr	@0
                                 	.endmacro
                                 	
                                 .macro	MUL2	; reg
                                 	lsl	@0
                                 	.endmacro
                                 .macro	MUL4	; reg
                                 	lsl	@0
                                 	lsl	@0
                                 	.endmacro
                                 .macro	MUL8	; reg
                                 	lsl	@0
                                 	lsl	@0
                                 	lsl	@0
                                 	.endmacro
                                 
                                 ; ====================================
                                 ; 	extending existing instructios
                                 ; ====================================
                                 
                                 ; --- immediate ops with r0..r15 ---
                                 .macro	_ADDI
                                 	ldi	w,@1
                                 	add	@0,w
                                 	.endmacro
                                 .macro	_ADCI
                                 	ldi	w,@1
                                 	adc	@0,w
                                 	.endmacro
                                 .macro	_SUBI
                                 	ldi	w,@1
                                 	sub	@0,w
                                 	.endmacro
                                 .macro	_SBCI
                                 	ldi	w,@1
                                 	sbc	@0,w
                                 	.endmacro
                                 .macro	_ANDI
                                 	ldi	w,@1
                                 	and	@0,w
                                 	.endmacro
                                 .macro	_ORI
                                 	ldi	w,@1
                                 	or	@0,w
                                 	.endmacro
                                 .macro	_EORI
                                 	ldi	w,@1
                                 	eor	@0,w
                                 	.endmacro
                                 .macro	_SBR
                                 	ldi	w,@1
                                 	or	@0,w
                                 	.endmacro
                                 .macro	_CBR
                                 	ldi	w,~@1
                                 	and	@0,w
                                 	.endmacro
                                 .macro	_CPI
                                 	ldi	w,@1
                                 	cp	@0,w
                                 	.endmacro
                                 .macro	_LDI
                                 	ldi	w,@1
                                 	mov	@0,w
                                 	.endmacro
                                 
                                 ; --- bit access for port p32..p63 ---
                                 .macro	_SBI
                                 	in	w,@0
                                 	ori	w,1<<@1
                                 	out	@0,w
                                 	.endmacro
                                 .macro	_CBI
                                 	in	w,@0
                                 	andi	w,~(1<<@1)
                                 	out	@0,w
                                 	.endmacro
                                 	
                                 ; --- extending branch distance to +/-2k ---
                                 .macro	_BREQ
                                 	brne	PC+2
                                 	rjmp	@0
                                 	.endmacro
                                 .macro	_BRNE
                                 	breq	PC+2
                                 	rjmp	@0
                                 	.endmacro
                                 .macro	_BRCS
                                 	brcc	PC+2
                                 	rjmp	@0
                                 	.endmacro
                                 .macro	_BRCC
                                 	brcs	PC+2
                                 	rjmp	@0
                                 	.endmacro
                                 .macro	_BRSH
                                 	brlo	PC+2
                                 	rjmp	@0
                                 	.endmacro
                                 .macro	_BRLO
                                 	brsh	PC+2
                                 	rjmp	@0
                                 	.endmacro
                                 .macro	_BRMI
                                 	brpl	PC+2
                                 	rjmp	@0
                                 	.endmacro
                                 .macro	_BRPL
                                 	brmi	PC+2
                                 	rjmp	@0
                                 	.endmacro
                                 .macro	_BRGE
                                 	brlt	PC+2
                                 	rjmp	@0
                                 	.endmacro
                                 .macro	_BRLT
                                 	brge	PC+2
                                 	rjmp	@0
                                 	.endmacro
                                 .macro	_BRHS
                                 	brhc	PC+2
                                 	rjmp	@0
                                 	.endmacro
                                 .macro	_BRHC
                                 	brhs	PC+2
                                 	rjmp	@0
                                 	.endmacro
                                 .macro	_BRTS
                                 	brtc	PC+2
                                 	rjmp	@0
                                 	.endmacro
                                 .macro	_BRTC
                                 	brts	PC+2
                                 	rjmp	@0
                                 	.endmacro
                                 .macro	_BRVS
                                 	brvc	PC+2
                                 	rjmp	@0
                                 	.endmacro
                                 .macro	_BRVC
                                 	brvs	PC+2
                                 	rjmp	@0
                                 	.endmacro
                                 .macro	_BRIE
                                 	brid	PC+2
                                 	rjmp	@0
                                 	.endmacro
                                 .macro	_BRID
                                 	brie	PC+2
                                 	rjmp	@0
                                 	.endmacro
                                 
                                 ; ====================
                                 ; 	bit operations
                                 ; ====================
                                 
                                 ; --- moving bits ---
                                 .macro	MOVB	; reg1,b1, reg2,b2	; reg1,bit1 <- reg2,bit2
                                 	bst	@2,@3
                                 	bld	@0,@1
                                 	.endmacro
                                 .macro	OUTB	; port1,b1, reg2,b2	; port1,bit1 <- reg2,bit2
                                 	sbrs	@2,@3
                                 	cbi	@0,@1
                                 	sbrc	@2,@3
                                 	sbi	@0,@1
                                 	.endmacro
                                 .macro	INB	; reg1,b1, port2,b2	; reg1,bit1 <- port2,bit2
                                 	sbis	@2,@3
                                 	cbr	@0,1<<@1
                                 	sbic	@2,@3
                                 	sbr	@0,1<<@1
                                 	.endmacro
                                 
                                 .macro	Z2C				; zero to carry
                                 	sec
                                 	breq	PC+2	; (Z=1)
                                 	clc
                                 	.endmacro
                                 .macro	Z2INVC				; zero to inverse carry
                                 	sec
                                 	brne	PC+2	; (Z=0)
                                 	clc
                                 	.endmacro
                                 
                                 .macro	C2Z				; carry to zero
                                 	sez
                                 	brcs	PC+2	; (C=1)
                                 	clz
                                 	.endmacro
                                 
                                 .macro	B2C	; reg,b			; bit to carry
                                 	sbrc	@0,@1
                                 	sec
                                 	sbrs	@0,@1
                                 	clc
                                 	.endmacro
                                 .macro	C2B	; reg,b			; carry to bit
                                 	brcc	PC+2
                                 	sbr	@0,(1<<@1)
                                 	brcs	PC+2
                                 	cbr	@0,(1<<@1)
                                 	.endmacro
                                 .macro	P2C	; port,b		; port to carry
                                 	sbic	@0,@1
                                 	sec
                                 	sbis	@0,@1
                                 	clc
                                 	.endmacro
                                 .macro	C2P	; port,b		; carry to port
                                 	brcc	PC+2
                                 	sbi	@0,@1
                                 	brcs	PC+2
                                 	cbi	@0,@1
                                 	.endmacro
                                 
                                 ; --- inverting bits ---
                                 .macro	INVB	; reg,bit		; inverse reg,bit
                                 	ldi	w,(1<<@1)
                                 	eor	@0,w
                                 	.endmacro
                                 .macro	INVP	; port,bit		; inverse port,bit	
                                 	sbis	@0,@1
                                 	rjmp	PC+3
                                 	cbi	@0,@1
                                 	rjmp	PC+2
                                 	sbi	@0,@1
                                 	.endmacro
                                 .macro	INVC				; inverse carry	
                                 	brcs	PC+3
                                 	sec
                                 	rjmp	PC+2
                                 	clc
                                 	.endmacro
                                 
                                 ; --- setting a single bit ---
                                 .macro	SETBIT	; reg(0..7)
                                 ; in	reg (0..7)
                                 ; out	reg with bit (0..7) set to 1.
                                 ; 0=00000001
                                 ; 1=00000010
                                 ; ...
                                 ; 7=10000000
                                 	mov	w,@0
                                 	clr	@0
                                 	inc	@0
                                 	andi	w,0b111	
                                 	breq	PC+4
                                 	lsl	@0
                                 	dec	w
                                 	brne	PC-2
                                 	.endmacro
                                 
                                 ; --- logical operations with masks ---
                                 .macro	MOVMSK	; reg1,reg2,mask	; reg1 <- reg2 (mask)
                                 	ldi	w,~@2	
                                 	and	@0,w
                                 	ldi	w,@2
                                 	and	@1,w	
                                 	or	@0,@1
                                 	.endmacro	
                                 .macro	ANDMSK	; reg1,reg2,mask	; reg1 <- ret 1 AND reg2 (mask)		
                                 	mov	w,@1
                                 	ori	w,~@2
                                 	and	@0,w
                                 	.endmacro	
                                 .macro	ORMSK	; reg1,reg2,mask	; reg1 <- ret 1 AND reg2 (mask)		
                                 	mov	w,@1
                                 	andi	w,@2
                                 	or	@0,w
                                 	.endmacro
                                 	
                                 ; --- logical operations on bits ---
                                 .macro	ANDB	; r1,b1, r2,b2, r3,b3	; reg1,b1 <- reg2,b2 AND reg3,b3
                                 	set
                                 	sbrs	@4,@5	
                                 	clt
                                 	sbrs	@2,@3	
                                 	clt
                                 	bld	@0,@1
                                 	.endmacro
                                 .macro	ORB	; r1,b1, r2,b2, r3,b3	; reg1.b1 <- reg2.b2 OR reg3.b3
                                 	clt
                                 	sbrc	@4,@5	
                                 	set
                                 	sbrc	@2,@3	
                                 	set
                                 	bld	@0,@1
                                 	.endmacro
                                 .macro	EORB	; r1,b1, r2,b2, r3,b3	; reg1.b1 <- reg2.b2 XOR reg3.b3
                                 	sbrc	@4,@5
                                 	rjmp	f1
                                 f0:	bst	@2,@3	
                                 	rjmp	PC+4
                                 f1:	set
                                 	sbrc	@0,@1
                                 	clt
                                 	bld	@0,@0	
                                 	.endmacro
                                 	
                                 ; --- operations based on register bits ---
                                 .macro	FB0	; reg,bit		; bit=0
                                 	cbr	@0,1<<@1
                                 	.endmacro
                                 .macro	FB1	; reg,bit		; bit=1
                                 	sbr	@0,1<<@1
                                 	.endmacro
                                 .macro	_FB0	; reg,bit		; bit=0
                                 	ldi	w,~(1<<@1)
                                 	and	@0,w
                                 	.endmacro
                                 .macro	_FB1	; reg,bit		; bit=1
                                 	ldi	w,1<<@1
                                 	or	@0,w
                                 	.endmacro
                                 .macro	SB0	; reg,bit,addr		; skip if bit=0
                                 	sbrc	@0,@1
                                 	.endmacro
                                 .macro	SB1	; reg,bit,addr		; skip if bit=1
                                 	sbrs	@0,@1
                                 	.endmacro
                                 .macro	JB0	; reg,bit,addr		; jump if bit=0
                                 	sbrs	@0,@1
                                 	rjmp	@2
                                 	.endmacro
                                 .macro	JB1	; reg,bit,addr		; jump if bit=1
                                 	sbrc	@0,@1
                                 	rjmp	@2
                                 	.endmacro
                                 .macro	CB0	; reg,bit,addr		; call if bit=0
                                 	sbrs	@0,@1
                                 	call	@2
                                 	.endmacro
                                 .macro	CB1	; reg,bit,addr		; call if bit=1
                                 	sbrc	@0,@1
                                 	call	@2
                                 	.endmacro
                                 .macro	WB0	; reg,bit		; wait if bit=0
                                 	sbrs	@0,@1
                                 	rjmp	PC-1
                                 	.endmacro
                                 .macro	WB1	; reg,bit		; wait if bit=1
                                 	sbrc	@0,@1
                                 	rjmp	PC-1
                                 	.endmacro
                                 .macro	RB0	; reg,bit		; return if bit=0
                                 	sbrs	@0,@1
                                 	ret
                                 	.endmacro
                                 .macro	RB1	; reg,bit		; return if bit=1
                                 	sbrc	@0,@1
                                 	ret
                                 	.endmacro
                                 
                                 ; wait if bit=0 with timeout
                                 ; if timeout (in units of 5 cyc) then jump to addr
                                 .macro	WB0T	; reg,bit,timeout,addr
                                 	ldi	w,@2+1
                                 	dec	w	; 1 cyc
                                 	breq	@3	; 1 cyc
                                 	sbrs	@0,@1	; 1 cyc
                                 	rjmp	PC-3	; 2 cyc = 5 cycles
                                 	.endmacro
                                 
                                 ; wait if bit=1 with timeout
                                 ; if timeout (in units of 5 cyc) then jump to addr	
                                 .macro	WB1T	; reg,bit,timeout,addr
                                 	ldi	w,@2+1
                                 	dec	w	; 1 cyc
                                 	breq	@3	; 1 cyc
                                 	sbrc	@0,@1	; 1 cyc
                                 	rjmp	PC-3	; 2 cyc = 5 cycles
                                 	.endmacro	
                                 	
                                 ; --- operations based on port bits ---
                                 .macro	P0	; port,bit		; port=0
                                 	cbi	@0,@1
                                 	.endmacro
                                 .macro	P1	; port,bit		; port=1
                                 	sbi	@0,@1
                                 	.endmacro
                                 .macro	SP0	; port,bit		; skip if port=0
                                 	sbic	@0,@1
                                 	.endmacro
                                 .macro	SP1	; port,bit		; skip if port=1
                                 	sbis	@0,@1
                                 	.endmacro
                                 .macro	JP0	; port,bit,addr		; jump if port=0
                                 	sbis	@0,@1
                                 	rjmp	@2
                                 	.endmacro
                                 .macro	JP1	; port,bit,addr		; jump if port=1
                                 	sbic	@0,@1
                                 	rjmp	@2
                                 	.endmacro
                                 .macro	CP0	; port,bit,addr		; call if port=0
                                 	sbis	@0,@1
                                 	rcall	@2
                                 	.endmacro
                                 .macro	CP1	; port,bit,addr		; call if port=1
                                 	sbic	@0,@1
                                 	rcall	@2
                                 	.endmacro
                                 .macro	WP0	; port,bit		; wait if port=0
                                 	sbis	@0,@1
                                 	rjmp	PC-1
                                 	.endmacro
                                 .macro	WP1	; port,bit		; wait if port=1
                                 	sbic	@0,@1
                                 	rjmp	PC-1
                                 	.endmacro
                                 .macro	RP0	; port,bit		; return if port=0
                                 	sbis	@0,@1
                                 	ret
                                 	.endmacro
                                 .macro	RP1	; port,bit		; return if port=1
                                 	sbic	@0,@1
                                 	ret
                                 	.endmacro
                                 
                                 ; wait if port=0 with timeout
                                 ; if timeout (in units of 5 cyc) then jump to addr
                                 .macro	WP0T	; port,bit,timeout,addr
                                 	ldi	w,@2+1
                                 	dec	w	; 1 cyc
                                 	breq	@3	; 1 cyc
                                 	sbis	@0,@1	; 1 cyc
                                 	rjmp	PC-3	; 2 cyc = 5 cycles
                                 	.endmacro
                                 
                                 ; wait if port=1 with timeout
                                 ; if timeout (in units of 5 cyc) then jump to addr	
                                 .macro	WP1T	; port,bit,timeout,addr
                                 	ldi	w,@2+1
                                 	dec	w	; 1 cyc
                                 	breq	@3	; 1 cyc
                                 	sbic	@0,@1	; 1 cyc
                                 	rjmp	PC-3	; 2 cyc = 5 cycles
                                 	.endmacro	
                                 
                                 ; ===========================
                                 ; 	multi-byte operations
                                 ; ===========================
                                 
                                 .macro	SWAP4			; swap 2 variables
                                 	mov	w ,@0
                                 	mov	@0,@4
                                 	mov	@4,w
                                 	mov	w ,@1
                                 	mov	@1,@5
                                 	mov	@5,w
                                 	mov	w ,@2
                                 	mov	@2,@6
                                 	mov	@6,w
                                 	mov	w ,@3
                                 	mov	@3,@7
                                 	mov	@7,w
                                 	.endmacro
                                 .macro	SWAP3
                                 	mov	w ,@0
                                 	mov	@0,@3
                                 	mov	@3,w
                                 	mov	w ,@1
                                 	mov	@1,@4
                                 	mov	@4,w
                                 	mov	w ,@2
                                 	mov	@2,@5
                                 	mov	@5,w
                                 	.endmacro
                                 .macro	SWAP2
                                 	mov	w ,@0
                                 	mov	@0,@2
                                 	mov	@2,w
                                 	mov	w ,@1
                                 	mov	@1,@3
                                 	mov	@3,w
                                 	.endmacro
                                 .macro	SWAP1
                                 	mov	w ,@0
                                 	mov	@0,@1
                                 	mov	@1,w
                                 	.endmacro
                                 
                                 .macro	LDX4	;r..r0		; load from (x+)
                                 	ld	@3,x+
                                 	ld	@2,x+	
                                 	ld	@1,x+
                                 	ld	@0,x+
                                 	.endmacro
                                 .macro	LDX3	;r..r0
                                 	ld	@2,x+	
                                 	ld	@1,x+
                                 	ld	@0,x+
                                 	.endmacro
                                 .macro	LDX2	;r..r0	
                                 	ld	@1,x+
                                 	ld	@0,x+
                                 	.endmacro
                                 	
                                 .macro	LDY4	;r..r0		; load from (y+)
                                 	ld	@3,y+
                                 	ld	@2,y+	
                                 	ld	@1,y+
                                 	ld	@0,y+
                                 	.endmacro
                                 .macro	LDY3	;r..r0
                                 	ld	@2,y+	
                                 	ld	@1,y+
                                 	ld	@0,y+
                                 	.endmacro
                                 .macro	LDY2	;r..r0	
                                 	ld	@1,y+
                                 	ld	@0,y+
                                 	.endmacro
                                 
                                 .macro	LDZ4	;r..r0		; load from (z+)
                                 	ld	@3,z+
                                 	ld	@2,z+	
                                 	ld	@1,z+
                                 	ld	@0,z+
                                 	.endmacro
                                 .macro	LDZ3	;r..r0
                                 	ld	@2,z+	
                                 	ld	@1,z+
                                 	ld	@0,z+
                                 	.endmacro
                                 .macro	LDZ2	;r..r0
                                 	ld	@1,z+
                                 	ld	@0,z+
                                 	.endmacro
                                 
                                 .macro	STX4	;r..r0		; store to (x+)
                                 	st	x+,@3
                                 	st	x+,@2	
                                 	st	x+,@1
                                 	st	x+,@0
                                 	.endmacro
                                 .macro	STX3	;r..r0
                                 	st	x+,@2	
                                 	st	x+,@1
                                 	st	x+,@0
                                 	.endmacro
                                 .macro	STX2	;r..r0
                                 	st	x+,@1
                                 	st	x+,@0
                                 	.endmacro
                                 	
                                 .macro	STY4	;r..r0		; store to (y+)
                                 	st	y+,@3
                                 	st	y+,@2	
                                 	st	y+,@1
                                 	st	y+,@0
                                 	.endmacro
                                 .macro	STY3	;r..r0
                                 	st	y+,@2	
                                 	st	y+,@1
                                 	st	y+,@0
                                 	.endmacro
                                 .macro	STY2	;r..r0	
                                 	st	y+,@1
                                 	st	y+,@0
                                 	.endmacro
                                 	
                                 .macro	STZ4	;r..r0		; store to (z+)
                                 	st	z+,@3
                                 	st	z+,@2	
                                 	st	z+,@1
                                 	st	z+,@0
                                 	.endmacro	
                                 .macro	STZ3	;r..r0
                                 	st	z+,@2	
                                 	st	z+,@1
                                 	st	z+,@0
                                 	.endmacro	
                                 .macro	STZ2	;r..r0	
                                 	st	z+,@1
                                 	st	z+,@0
                                 	.endmacro	
                                 	
                                 .macro	STI4	;addr,k		; store immediate
                                 	ldi	w,  low(@1)
                                 	sts	@0+0,w
                                 	ldi	w, high(@1)
                                 	sts	@0+1,w
                                 	ldi	w,byte3(@1)
                                 	sts	@0+2,w
                                 	ldi	w,byte4(@1)
                                 	sts	@0+3,w	
                                 	.endmacro	
                                 .macro	STI3	;addr,k
                                 	ldi	w,  low(@1)
                                 	sts	@0+0,w
                                 	ldi	w, high(@1)
                                 	sts	@0+1,w
                                 	ldi	w,byte3(@1)
                                 	sts	@0+2,w
                                 	.endmacro	
                                 .macro	STI2	;addr,k
                                 	ldi	w,  low(@1)
                                 	sts	@0+0,w
                                 	ldi	w, high(@1)
                                 	sts	@0+1,w
                                 	.endmacro
                                 .macro	STI	;addr,k
                                 	ldi	w,@1
                                 	sts	@0,w
                                 	.endmacro
                                 
                                 .macro	INC4			; increment
                                 	ldi	w,0xff
                                 	sub	@3,w
                                 	sbc	@2,w
                                 	sbc	@1,w
                                 	sbc	@0,w
                                 	.endmacro
                                 .macro	INC3
                                 	ldi	w,0xff
                                 	sub	@2,w
                                 	sbc	@1,w
                                 	sbc	@0,w
                                 	.endmacro
                                 .macro	INC2
                                 	ldi	w,0xff
                                 	sub	@1,w
                                 	sbc	@0,w
                                 	.endmacro
                                 
                                 .macro	DEC4			; decrement
                                 	ldi	w,0xff
                                 	add	@3,w
                                 	adc	@2,w
                                 	adc	@1,w
                                 	adc	@0,w
                                 	.endmacro
                                 .macro	DEC3
                                 	ldi	w,0xff
                                 	add	@2,w
                                 	adc	@1,w
                                 	adc	@0,w
                                 	.endmacro
                                 .macro	DEC2
                                 	ldi	w,0xff
                                 	add	@1,w
                                 	adc	@0,w
                                 	.endmacro
                                 
                                 .macro	CLR9			; clear (also clears the carry)
                                 	sub	@0,@0
                                 	clr	@1
                                 	clr	@2
                                 	clr	@3
                                 	clr	@4
                                 	clr	@5
                                 	clr	@6
                                 	clr	@7
                                 	clr	@8
                                 	.endmacro
                                 .macro	CLR8
                                 	sub	@0,@0
                                 	clr	@1
                                 	clr	@2
                                 	clr	@3
                                 	clr	@4
                                 	clr	@5
                                 	clr	@6
                                 	clr	@7
                                 	.endmacro
                                 .macro	CLR7
                                 	sub	@0,@0
                                 	clr	@1
                                 	clr	@2
                                 	clr	@3
                                 	clr	@4
                                 	clr	@5
                                 	clr	@6
                                 	.endmacro
                                 .macro	CLR6
                                 	sub	@0,@0
                                 	clr	@1
                                 	clr	@2
                                 	clr	@3
                                 	clr	@4
                                 	clr	@5
                                 	.endmacro
                                 .macro	CLR5
                                 	sub	@0,@0
                                 	clr	@1
                                 	clr	@2
                                 	clr	@3
                                 	clr	@4
                                 	.endmacro
                                 .macro	CLR4
                                 	sub	@0,@0
                                 	clr	@1
                                 	clr	@2
                                 	clr	@3
                                 	.endmacro
                                 .macro	CLR3
                                 	sub	@0,@0
                                 	clr	@1
                                 	clr	@2
                                 	.endmacro
                                 .macro	CLR2
                                 	sub	@0,@0
                                 	clr	@1
                                 	.endmacro
                                 
                                 .macro	COM4			; one's complement
                                 	com	@0
                                 	com	@1
                                 	com	@2
                                 	com	@3
                                 	.endmacro
                                 .macro	COM3
                                 	com	@0
                                 	com	@1
                                 	com	@2
                                 	.endmacro
                                 .macro	COM2
                                 	com	@0
                                 	com	@1
                                 	.endmacro
                                 
                                 .macro	NEG4			; negation (two's complement)
                                 	com	@0
                                 	com	@1
                                 	com	@2
                                 	com	@3
                                 	ldi	w,0xff
                                 	sub	@3,w
                                 	sbc	@2,w
                                 	sbc	@1,w
                                 	sbc	@0,w
                                 	.endmacro
                                 .macro	NEG3
                                 	com	@0
                                 	com	@1
                                 	com	@2
                                 	ldi	w,0xff
                                 	sub	@2,w
                                 	sbc	@1,w
                                 	sbc	@0,w
                                 	.endmacro
                                 .macro	NEG2
                                 	com	@0
                                 	com	@1
                                 	ldi	w,0xff
                                 	sub	@1,w
                                 	sbc	@0,w
                                 	.endmacro
                                 	
                                 .macro	LDI4 	; r..r0, k	; load immediate
                                 	ldi	@3,  low(@4)
                                 	ldi	@2, high(@4)
                                 	ldi	@1,byte3(@4)
                                 	ldi	@0,byte4(@4)
                                 	.endmacro
                                 .macro	LDI3
                                 	ldi	@2,  low(@3)
                                 	ldi	@1, high(@3)
                                 	ldi	@0,byte3(@3)
                                 	.endmacro
                                 .macro	LDI2
                                 	ldi	@1,  low(@2)
                                 	ldi	@0, high(@2)
                                 	.endmacro
                                 
                                 .macro	LDS4			; load direct from SRAM
                                 	lds	@3,@4
                                 	lds	@2,@4+1
                                 	lds	@1,@4+2
                                 	lds	@0,@4+3
                                 	.endmacro
                                 .macro	LDS3
                                 	lds	@2,@3
                                 	lds	@1,@3+1
                                 	lds	@0,@3+2
                                 	.endmacro
                                 .macro	LDS2
                                 	lds	@1,@2
                                 	lds	@0,@2+1
                                 	.endmacro
                                 
                                 .macro	STS4			; store direct to SRAM
                                 	sts	@0+0,@4
                                 	sts	@0+1,@3
                                 	sts	@0+2,@2
                                 	sts	@0+3,@1
                                 	.endmacro
                                 .macro	STS3
                                 	sts	@0+0,@3
                                 	sts	@0+1,@2
                                 	sts	@0+2,@1
                                 	.endmacro
                                 .macro	STS2
                                 	sts	@0+0,@2
                                 	sts	@0+1,@1
                                 	.endmacro
                                 
                                 .macro	STDZ4	; d, r3,r2,r1,r0
                                 	std	z+@0+0,@4
                                 	std	z+@0+1,@3
                                 	std	z+@0+2,@2
                                 	std	z+@0+3,@1
                                 	.endmacro
                                 .macro	STDZ3	; d, r2,r1,r0
                                 	std	z+@0+0,@3
                                 	std	z+@0+1,@2
                                 	std	z+@0+2,@1
                                 	.endmacro
                                 .macro	STDZ2	; d, r1,r0
                                 	std	z+@0+0,@2
                                 	std	z+@0+1,@1
                                 	.endmacro
                                 	
                                 .macro	LPM4			; load program memory
                                 	lpm
                                 	mov	@3,r0
                                 	adiw	zl,1
                                 	lpm
                                 	mov	@2,r0
                                 	adiw	zl,1
                                 	lpm
                                 	mov	@1,r0
                                 	adiw	zl,1
                                 	lpm
                                 	mov	@0,r0
                                 	adiw	zl,1
                                 	.endmacro
                                 .macro	LPM3
                                 	lpm
                                 	mov	@2,r0
                                 	adiw	zl,1
                                 	lpm
                                 	mov	@1,r0
                                 	adiw	zl,1
                                 	lpm
                                 	mov	@0,r0
                                 	adiw	zl,1
                                 	.endmacro
                                 .macro	LPM2
                                 	lpm
                                 	mov	@1,r0
                                 	adiw	zl,1
                                 	lpm
                                 	mov	@0,r0
                                 	adiw	zl,1
                                 	.endmacro
                                 .macro	LPM1
                                 	lpm
                                 	mov	@0,r0
                                 	adiw	zl,1
                                 	.endmacro
                                 
                                 .macro	MOV4			; move between registers
                                 	mov	@3,@7
                                 	mov	@2,@6
                                 	mov	@1,@5
                                 	mov	@0,@4
                                 	.endmacro
                                 .macro	MOV3
                                 	mov	@2,@5
                                 	mov	@1,@4
                                 	mov	@0,@3
                                 	.endmacro
                                 .macro	MOV2
                                 	mov	@1,@3
                                 	mov	@0,@2
                                 	.endmacro
                                 
                                 .macro	ADD4			; add
                                 	add	@3,@7
                                 	adc	@2,@6
                                 	adc	@1,@5
                                 	adc	@0,@4
                                 	.endmacro
                                 .macro	ADD3
                                 	add	@2,@5
                                 	adc	@1,@4
                                 	adc	@0,@3
                                 	.endmacro
                                 .macro	ADD2
                                 	add	@1,@3
                                 	adc	@0,@2
                                 	.endmacro
                                 
                                 .macro	SUB4			; subtract
                                 	sub	@3,@7
                                 	sbc	@2,@6
                                 	sbc	@1,@5
                                 	sbc	@0,@4
                                 	.endmacro
                                 .macro	SUB3
                                 	sub	@2,@5
                                 	sbc	@1,@4
                                 	sbc	@0,@3
                                 	.endmacro
                                 .macro	SUB2
                                 	sub	@1,@3
                                 	sbc	@0,@2
                                 	.endmacro
                                 	
                                 .macro	CP4			; compare
                                 	cp	@3,@7
                                 	cpc	@2,@6
                                 	cpc	@1,@5
                                 	cpc	@0,@4
                                 	.endmacro
                                 .macro	CP3
                                 	cp	@2,@5
                                 	cpc	@1,@4
                                 	cpc	@0,@3
                                 	.endmacro
                                 .macro	CP2
                                 	cp	@1,@3
                                 	cpc	@0,@2
                                 	.endmacro
                                 
                                 .macro	TST4			; test
                                 	clr	w
                                 	cp	@3,w
                                 	cpc	@2,w
                                 	cpc	@1,w
                                 	cpc	@0,w
                                 	.endmacro
                                 .macro	TST3
                                 	clr	w
                                 	cp	@2,w
                                 	cpc	@1,w
                                 	cpc	@0,w
                                 	.endmacro
                                 .macro	TST2
                                 	clr	w
                                 	cp	@1,w
                                 	cpc	@0,w
                                 	.endmacro
                                 
                                 .macro	ADDI4			; add immediate
                                 	subi	@3,  low(-@4)
                                 	sbci	@2, high(-@4)
                                 	sbci	@1,byte3(-@4)
                                 	sbci	@0,byte4(-@4)
                                 	.endmacro
                                 .macro	ADDI3
                                 	subi	@2,  low(-@3)
                                 	sbci	@1, high(-@3)
                                 	sbci	@0,byte3(-@3)
                                 	.endmacro
                                 .macro	ADDI2
                                 	subi	@1,  low(-@2)
                                 	sbci	@0, high(-@2)
                                 	.endmacro
                                 	
                                 .macro	SUBI4			; subtract immediate
                                 	subi	@3,  low(@4)
                                 	sbci	@2, high(@4)
                                 	sbci	@1,byte3(@4)
                                 	sbci	@0,byte4(@4)
                                 	.endmacro
                                 .macro	SUBI3
                                 	subi	@2,  low(@3)
                                 	sbci	@1, high(@3)
                                 	sbci	@0,byte3(@3)
                                 	.endmacro
                                 .macro	SUBI2
                                 	subi	@1,  low(@2)
                                 	sbci	@0, high(@2)
                                 	.endmacro
                                 
                                 .macro	LSL5			; logical shift left
                                 	lsl	@4
                                 	rol	@3
                                 	rol	@2
                                 	rol	@1
                                 	rol	@0
                                 	.endmacro
                                 .macro	LSL4
                                 	lsl	@3
                                 	rol	@2
                                 	rol	@1
                                 	rol	@0
                                 	.endmacro
                                 .macro	LSL3
                                 	lsl	@2
                                 	rol	@1
                                 	rol	@0
                                 	.endmacro
                                 .macro	LSL2
                                 	lsl	@1
                                 	rol	@0
                                 	.endmacro
                                 	
                                 .macro	LSR4			; logical shift right
                                 	lsr	@0
                                 	ror	@1
                                 	ror	@2
                                 	ror	@3
                                 	.endmacro
                                 .macro	LSR3
                                 	lsr	@0
                                 	ror	@1
                                 	ror	@2
                                 	.endmacro
                                 .macro	LSR2
                                 	lsr	@0
                                 	ror	@1
                                 	.endmacro
                                 
                                 .macro	ASR4			; arithmetic shift right
                                 	asr	@0
                                 	ror	@1
                                 	ror	@2
                                 	ror	@3
                                 	.endmacro
                                 .macro	ASR3
                                 	asr	@0
                                 	ror	@1
                                 	ror	@2
                                 	.endmacro
                                 .macro	ASR2
                                 	asr	@0
                                 	ror	@1
                                 	.endmacro
                                 
                                 .macro	ROL8			; rotate left through carry
                                 	rol	@7
                                 	rol	@6
                                 	rol	@5
                                 	rol	@4
                                 	rol	@3
                                 	rol	@2
                                 	rol	@1
                                 	rol	@0
                                 	.endmacro
                                 .macro	ROL7
                                 	rol	@6
                                 	rol	@5
                                 	rol	@4
                                 	rol	@3
                                 	rol	@2
                                 	rol	@1
                                 	rol	@0
                                 	.endmacro
                                 .macro	ROL6
                                 	rol	@5
                                 	rol	@4
                                 	rol	@3
                                 	rol	@2
                                 	rol	@1
                                 	rol	@0
                                 	.endmacro
                                 .macro	ROL5
                                 	rol	@4
                                 	rol	@3
                                 	rol	@2
                                 	rol	@1
                                 	rol	@0
                                 	.endmacro
                                 .macro	ROL4
                                 	rol	@3
                                 	rol	@2
                                 	rol	@1
                                 	rol	@0
                                 	.endmacro
                                 .macro	ROL3
                                 	rol	@2
                                 	rol	@1
                                 	rol	@0
                                 	.endmacro
                                 .macro	ROL2
                                 	rol	@1
                                 	rol	@0
                                 	.endmacro
                                 
                                 .macro	ROR8			; rotate right through carry
                                 	ror	@0
                                 	ror	@1
                                 	ror	@2
                                 	ror	@3
                                 	ror	@4
                                 	ror	@5
                                 	ror	@6
                                 	ror	@7
                                 	.endmacro
                                 .macro	ROR7
                                 	ror	@0
                                 	ror	@1
                                 	ror	@2
                                 	ror	@3
                                 	ror	@4
                                 	ror	@5
                                 	ror	@6
                                 	.endmacro
                                 .macro	ROR6
                                 	ror	@0
                                 	ror	@1
                                 	ror	@2
                                 	ror	@3
                                 	ror	@4
                                 	ror	@5
                                 	.endmacro
                                 .macro	ROR5
                                 	ror	@0
                                 	ror	@1
                                 	ror	@2
                                 	ror	@3
                                 	ror	@4
                                 	.endmacro	
                                 .macro	ROR4
                                 	ror	@0
                                 	ror	@1
                                 	ror	@2
                                 	ror	@3
                                 	.endmacro
                                 .macro	ROR3
                                 	ror	@0
                                 	ror	@1
                                 	ror	@2
                                 	.endmacro
                                 .macro	ROR2
                                 	ror	@0
                                 	ror	@1
                                 	.endmacro
                                 
                                 .macro	PUSH2
                                 	push	@0
                                 	push	@1
                                 	.endmacro	
                                 .macro	POP2
                                 	pop	@1
                                 	pop	@0
                                 	.endmacro
                                 
                                 .macro	PUSH3
                                 	push	@0
                                 	push	@1
                                 	push	@2
                                 	.endmacro	
                                 .macro	POP3
                                 	pop	@2
                                 	pop	@1
                                 	pop	@0
                                 	.endmacro
                                 	
                                 .macro	PUSH4
                                 	push	@0
                                 	push	@1
                                 	push	@2
                                 	push	@3
                                 	.endmacro	
                                 .macro	POP4
                                 	pop	@3
                                 	pop	@2
                                 	pop	@1
                                 	pop	@0
                                 	.endmacro	
                                 	
                                 .macro	PUSH5
                                 	pop	@0
                                 	pop	@1
                                 	pop	@2
                                 	pop	@3
                                 	pop	@4
                                 	.endmacro	
                                 .macro	POP5
                                 	pop	@4
                                 	pop	@3
                                 	pop	@2
                                 	pop	@1
                                 	pop	@0
                                 	.endmacro	
                                 
                                 ; --- SRAM operations ---
                                 .macro	INCS4	; sram		; increment SRAM 4-byte variable
                                 	lds	w,@0
                                 	inc	w
                                 	sts	@0,w
                                 	brne	end
                                 	lds	w,@0+1
                                 	inc	w
                                 	sts	@0+1,w
                                 	brne	end
                                 	lds	w,@0+2
                                 	inc	w
                                 	sts	@0+2,w
                                 	brne	end
                                 	lds	w,@0+3
                                 	inc	w
                                 	sts	@0+3,w
                                 end:	
                                 	.endmacro
                                 
                                 .macro	INCS3	; sram		; increment SRAM 3-byte variable
                                 	lds	w,@0
                                 	inc	w
                                 	sts	@0,w
                                 	brne	end
                                 	lds	w,@0+1
                                 	inc	w
                                 	sts	@0+1,w
                                 	brne	end
                                 	lds	w,@0+2
                                 	inc	w
                                 	sts	@0+2,w
                                 end:	
                                 	.endmacro
                                 
                                 .macro	INCS2	; sram		; increment SRAM 2-byte variable
                                 	lds	w,@0
                                 	inc	w
                                 	sts	@0,w
                                 	brne	end
                                 	lds	w,@0+1
                                 	inc	w
                                 	sts	@0+1,w
                                 end:	
                                 	.endmacro
                                 
                                 .macro	INCS	; sram		; increment SRAM 1-byte variable
                                 	lds	w,@0
                                 	inc	w
                                 	sts	@0,w
                                 	.endmacro
                                 
                                 .macro	DECS4	; sram		; decrement SRAM 4-byte variable
                                 	ldi	w,1
                                 	lds	u,@0
                                 	sub	u,w
                                 	sts	@0,u
                                 	clr	w
                                 	lds	u,@0+1
                                 	sbc	u,w
                                 	sts	@0+1,u
                                 	lds	u,@0+2
                                 	sbc	u,w
                                 	sts	@0+2,u
                                 	lds	u,@0+3
                                 	sbc	u,w
                                 	sts	@0+3,u
                                 	.endmacro
                                 .macro	DECS3	; sram		; decrement SRAM 3-byte variable
                                 	ldi	w,1
                                 	lds	u,@0
                                 	sub	u,w
                                 	sts	@0,u
                                 	clr	w
                                 	lds	u,@0+1
                                 	sbc	u,w
                                 	sts	@0+1,u
                                 	lds	u,@0+2
                                 	sbc	u,w
                                 	sts	@0+2,u
                                 	.endmacro
                                 .macro	DECS2	; sram		; decrement SRAM 2-byte variable
                                 	ldi	w,1
                                 	lds	u,@0
                                 	sub	u,w
                                 	sts	@0,u
                                 	clr	w
                                 	lds	u,@0+1
                                 	sbc	u,w
                                 	sts	@0+1,u
                                 	.endmacro
                                 .macro	DECS	; sram		; decrement
                                 	lds	w,@0
                                 	dec	w
                                 	sts	@0,w
                                 	.endmacro
                                 
                                 .macro	MOVS4	; addr0,addr1	; [addr0] <-- [addr1]
                                 	lds	w,@1
                                 	sts	@0,w
                                 	lds	w,@1+1
                                 	sts	@0+1,w
                                 	lds	w,@1+2
                                 	sts	@0+2,w
                                 	lds	w,@3+1
                                 	sts	@0+3,w	
                                 	.endmacro
                                 .macro	MOVS3	; addr0,addr1	; [addr0] <-- [addr1]
                                 	lds	w,@1
                                 	sts	@0,w
                                 	lds	w,@1+1
                                 	sts	@0+1,w
                                 	lds	w,@1+2
                                 	sts	@0+2,w
                                 	.endmacro
                                 .macro	MOVS2	; addr0,addr1	; [addr0] <-- [addr1]
                                 	lds	w,@1
                                 	sts	@0,w
                                 	lds	w,@1+1
                                 	sts	@0+1,w
                                 	.endmacro
                                 .macro	MOVS	; addr0,addr1	; [addr0] <-- [addr1]
                                 	lds	w,@1
                                 	sts	@0,w
                                 	.endmacro
                                 
                                 .macro	SEXT	; reg1,reg0	; sign extend
                                 	clr	@0
                                 	sbrc	@1,7
                                 	dec	@0
                                 	.endmacro
                                 
                                 ; =======================================
                                 ;	Jump/Call with constant arguments
                                 ; =======================================
                                 	
                                 ; --- calls with arguments a,b,XYZ ---
                                 .macro	CX	; subroutine,x
                                 	ldi	xl, low(@1)
                                 	ldi	xh,high(@1)
                                 	rcall	@0
                                 	.endmacro
                                 .macro	CXY	; subroutine,x,y
                                 	ldi	xl, low(@1)
                                 	ldi	xh,high(@1)
                                 	ldi	yl, low(@2)
                                 	ldi	yh,high(@2)	
                                 	rcall	@0
                                 	.endmacro		
                                 .macro	CXZ	; subroutine,x,z
                                 	ldi	xl, low(@1)
                                 	ldi	xh,high(@1)
                                 	ldi	zl, low(@2)
                                 	ldi	zh,high(@2)	
                                 	rcall	@0
                                 	.endmacro		
                                 .macro	CXYZ	; subroutine,x,y,z
                                 	ldi	xl, low(@1)
                                 	ldi	xh,high(@1)
                                 	ldi	yl, low(@2)
                                 	ldi	yh,high(@2)
                                 	ldi	zl, low(@3)
                                 	ldi	zh,high(@3)		
                                 	rcall	@0
                                 	.endmacro
                                 .macro	CW	; subroutine,w
                                 	ldi	w, @1
                                 	rcall	@0
                                 	.endmacro
                                 .macro	CA	; subroutine,a
                                 	ldi	a0, @1
                                 	rcall	@0
                                 	.endmacro
                                 .macro	CAB	; subroutine,a,b
                                 	ldi	a0, @1
                                 	ldi	b0, @2
                                 	rcall	@0
                                 	.endmacro
                                 
                                 ; --- jump with arguments w,a,b ---
                                 .macro	JW	; subroutine,w
                                 	ldi	w, @1
                                 	rjmp	@0
                                 	.endmacro
                                 .macro	JA	; subroutine,a
                                 	ldi	a0, @1
                                 	rjmp	@0
                                 	.endmacro
                                 .macro	JAB	; subroutine,a,b
                                 	ldi	a0, @1
                                 	ldi	b0, @2
                                 	rjmp	@0
                                 	.endmacro
                                 .list
                                 
                                 
                                 .include "m128def.inc"
                                 
                                 ;***** Created: 2011-02-09 12:03 ******* Source: ATmega128.xml ***********
                                 ;*************************************************************************
                                 ;* A P P L I C A T I O N   N O T E   F O R   T H E   A V R   F A M I L Y
                                 ;* 
                                 ;* Number            : AVR000
                                 ;* File Name         : "m128def.inc"
                                 ;* Title             : Register/Bit Definitions for the ATmega128
                                 ;* Date              : 2011-02-09
                                 ;* Version           : 2.35
                                 ;* Support E-mail    : avr@atmel.com
                                 ;* Target MCU        : ATmega128
                                 ;* 
                                 ;* DESCRIPTION
                                 ;* When including this file in the assembly program file, all I/O register 
                                 ;* names and I/O register bit names appearing in the data book can be used.
                                 ;* In addition, the six registers forming the three data pointers X, Y and 
                                 ;* Z have been assigned names XL - ZH. Highest RAM address for Internal 
                                 ;* SRAM is also defined 
                                 ;* 
                                 ;* The Register names are represented by their hexadecimal address.
                                 ;* 
                                 ;* The Register Bit names are represented by their bit number (0-7).
                                 ;* 
                                 ;* Please observe the difference in using the bit names with instructions
                                 ;* such as "sbr"/"cbr" (set/clear bit in register) and "sbrs"/"sbrc"
                                 ;* (skip if bit in register set/cleared). The following example illustrates
                                 ;* this:
                                 ;* 
                                 ;* in    r16,PORTB             ;read PORTB latch
                                 ;* sbr   r16,(1<<PB6)+(1<<PB5) ;set PB6 and PB5 (use masks, not bit#)
                                 ;* out   PORTB,r16             ;output to PORTB
                                 ;* 
                                 ;* in    r16,TIFR              ;read the Timer Interrupt Flag Register
                                 ;* sbrc  r16,TOV0              ;test the overflow flag (use bit#)
                                 ;* rjmp  TOV0_is_set           ;jump if set
                                 ;* ...                         ;otherwise do something else
                                 ;*************************************************************************
                                 
                                 #ifndef _M128DEF_INC_
                                 #endif  /* _M128DEF_INC_ */
                                 
                                 ; ***** END OF FILE ******************************************************
                                 
                                 	; === definitions ===
                                 .equ	KPDD = DDRD
                                 .equ	KPDO = PORTD
                                 .equ	KPDI = PIND
                                 
                                 .equ	KPD_DELAY = 30	; msec, debouncing keys of keypad
                                 
                                 .def	wr0 = r2		; detected row in hex
                                 .def	wr1 = r1		; detected column in hex
                                 .def	mask = r14		; row mask indicating which row has been detected in bin
                                 .def	wr2 = r15		; semaphore: must enter LCD display routine, unary: 0 or other
                                 
                                 	; === interrupt vector table ===
                                 .org 0
000000 940c 04dc                 	jmp reset
000002 940c 000a                 	jmp	isr_ext_int0	; external interrupt INT0
000004 940c 000f                 	jmp	isr_ext_int1	; external interrupt INT1
000006 940c 0014                 	jmp isr_ext_int2
000008 940c 0019                 	jmp isr_ext_int3
                                 
                                 	; === interrupt service routines ===
                                 	
                                 isr_ext_int0:
00000a e001
00000b 2e10                      	_LDI	wr1, 0x01		; detect row 1
00000c e001
00000d 2ee0                      	_LDI	mask, 0b00000001
00000e c00f                      	rjmp	column_detect
                                 
                                 isr_ext_int1:
00000f e002
000010 2e10                      	_LDI	wr1, 0x02		; detect row 2
000011 e002
000012 2ee0                      	_LDI	mask, 0b00000010
000013 c00a                      	rjmp	column_detect
                                 
                                 isr_ext_int2:		
000014 e004
000015 2e10                      	_LDI	wr1, 0x04		; detect row 3 (LSB 0100)
000016 e004
000017 2ee0                      	_LDI	mask, 0b00000100
000018 c005                      	rjmp	column_detect
                                 
                                 isr_ext_int3:
000019 e008
00001a 2e10                      	_LDI	wr1, 0x08		; detect row 4 (LSB 1000)
00001b e008
00001c 2ee0                      	_LDI	mask, 0b00001000
00001d c000                      	rjmp	column_detect
                                 
                                 
                                 column_detect:
00001e ef0f
00001f bb02                          OUTI    KPDO,0xff       ; bit4-7 driven high
                                 col7: ; X2: 369#
000020 e10e
000021 2e30
000022 e001
000023 930f
000024 923f
000025 e300
000026 2e30
000027 e006
000028 943a
000029 f7f1
00002a 943a
00002b 950a
00002c f7d9
00002d 903f
00002e 910f
00002f 943a
000030 f791
000031 950a
000032 f781                      	WAIT_MS KPD_DELAY
000033 e70f
000034 bb02                      	OUTI KPDO,0x7f ; check column 7
000035 e10e
000036 2e30
000037 e001
000038 930f
000039 923f
00003a e300
00003b 2e30
00003c e006
00003d 943a
00003e f7f1
00003f 943a
000040 950a
000041 f7d9
000042 903f
000043 910f
000044 943a
000045 f791
000046 950a
000047 f781                      	WAIT_MS KPD_DELAY
000048 b300                      	in w,KPDI
000049 210e                      	and w,mask
00004a 2300                      	tst w
00004b f419                      	brne col6
00004c e400
00004d 2e20                      	_LDI wr0,0x40 ; (MSB 0100)
00004e c08c                      	rjmp isr_return
                                 
                                 col6: ; X1: ABCD
00004f e10e
000050 2e30
000051 e001
000052 930f
000053 923f
000054 e300
000055 2e30
000056 e006
000057 943a
000058 f7f1
000059 943a
00005a 950a
00005b f7d9
00005c 903f
00005d 910f
00005e 943a
00005f f791
000060 950a
000061 f781                      	WAIT_MS KPD_DELAY
000062 eb0f
000063 bb02                      	OUTI KPDO,0xbf ; check column 6
000064 e10e
000065 2e30
000066 e001
000067 930f
000068 923f
000069 e300
00006a 2e30
00006b e006
00006c 943a
00006d f7f1
00006e 943a
00006f 950a
000070 f7d9
000071 903f
000072 910f
000073 943a
000074 f791
000075 950a
000076 f781                      	WAIT_MS KPD_DELAY
000077 b300                      	in w,KPDI
000078 210e                      	and w,mask
000079 2300                      	tst w
00007a f419                      	brne col5
00007b e800
00007c 2e20                      	_LDI wr0,0x80 ; (MSB 1000)
00007d c05d                      	rjmp isr_return
                                 
                                 col5: ; X3: 2580
00007e e10e
00007f 2e30
000080 e001
000081 930f
000082 923f
000083 e300
000084 2e30
000085 e006
000086 943a
000087 f7f1
000088 943a
000089 950a
00008a f7d9
00008b 903f
00008c 910f
00008d 943a
00008e f791
00008f 950a
000090 f781                      	WAIT_MS KPD_DELAY
000091 ed0f
000092 bb02                      	OUTI KPDO,0xdf ; check column 5
000093 e10e
000094 2e30
000095 e001
000096 930f
000097 923f
000098 e300
000099 2e30
00009a e006
00009b 943a
00009c f7f1
00009d 943a
00009e 950a
00009f f7d9
0000a0 903f
0000a1 910f
0000a2 943a
0000a3 f791
0000a4 950a
0000a5 f781                      	WAIT_MS KPD_DELAY
0000a6 b300                      	in w,KPDI
0000a7 210e                      	and w,mask
0000a8 2300                      	tst w
0000a9 f419                      	brne col4
0000aa e200
0000ab 2e20                      	_LDI wr0,0x20
0000ac c02e                      	rjmp isr_return
                                 
                                 col4: ; X4: 147*
0000ad e10e
0000ae 2e30
0000af e001
0000b0 930f
0000b1 923f
0000b2 e300
0000b3 2e30
0000b4 e006
0000b5 943a
0000b6 f7f1
0000b7 943a
0000b8 950a
0000b9 f7d9
0000ba 903f
0000bb 910f
0000bc 943a
0000bd f791
0000be 950a
0000bf f781                      	WAIT_MS KPD_DELAY
0000c0 ee0f
0000c1 bb02                      	OUTI KPDO,0xef ; check column 4
0000c2 e10e
0000c3 2e30
0000c4 e001
0000c5 930f
0000c6 923f
0000c7 e300
0000c8 2e30
0000c9 e006
0000ca 943a
0000cb f7f1
0000cc 943a
0000cd 950a
0000ce f7d9
0000cf 903f
0000d0 910f
0000d1 943a
0000d2 f791
0000d3 950a
0000d4 f781                      	WAIT_MS KPD_DELAY
0000d5 b300                      	in w,KPDI
0000d6 210e                      	and w,mask
0000d7 2300                      	tst w
0000d8 f411                      	brne isr_return
0000d9 e100
0000da 2e20                      	_LDI wr0,0x10
                                  
                                 isr_return:
0000db e01a                      	ldi _w,10 ; sound feedback of key pressed acknowledge
                                 beep01:    
0000dc ef0f
0000dd 2ef0                          _LDI    wr2,0xff
0000de e00f
0000df bb02                      	OUTI	KPDO,0x0f
0000e0 9518                          reti
                                 
                                 .include "kpd4x4bis.asm"
                                 
                                 ; === initialization and configuration ===
                                 
                                 reset_kpd:	
0000e1 ef00
0000e2 bb01                      	OUTI	KPDD,0xf0		; bit0-3 pull-up and bits4-7 driven low
0000e3 e00f
0000e4 bb02                      	OUTI	KPDO,0x0f		;>(needs the two lines)
0000e5 ef0f
0000e6 bb07                      	OUTI	DDRB,0xff		; turn on LEDs
0000e7 e00f
0000e8 bf09                      	OUTI	EIMSK,0x0f		; enable INT0-INT3
0000e9 e000
0000ea bf0a                      	OUTI	EICRB,0b0		;>at low level
0000eb 9a12                      	sbi		DDRE,SPEAKER	; enable sound
                                 
0000ec 2422                      	clr		wr0
0000ed 2411                      	clr		wr1
0000ee 24ff                      	clr		wr2
                                 
0000ef 2733                      	clr		a1				
0000f0 2744                      	clr		a2
0000f1 2755                      	clr		a3
0000f2 2777                      	clr		b1
0000f3 2788                      	clr		b2
0000f4 2799                      	clr		b3
                                 
0000f5 9478                      	sei
0000f6 940c 00f8                 	jmp	main_kpd				; not useful in this case, kept for modularity
                                 
                                 	; === main program ===
                                 main_kpd:
                                 
0000f8 20ff                      	tst		wr2				; check flag/semaphore
0000f9 f3f1                      	breq	main_kpd			; branch to main as long as no key pressed
0000fa 24ff                      	clr		wr2				; clear wr2 to avoid detecting key pressed once back at beginning of main
                                 
0000fb 2722                      	clr		a0
0000fc 0d21                      	add		a0, wr1			; col
0000fd 0d22                      	add		a0, wr0			; row
0000fe 2766                      	clr b0 ; used to compute offset to LUT
                                 	; offset due to low nibble (row)
0000ff 2e82                      	mov c0, a0
                                 
000100 fd21                      	sbrc a0, 1
000101 5f6c                      	subi b0, -4
000102 fd22                      	sbrc a0, 2
000103 5f68                      	subi b0, -8
000104 fd23                      	sbrc a0, 3
000105 5f64                      	subi b0, -12
                                 	; offset due to high nibble (col)
000106 fd25                      	sbrc a0, 5
000107 5f6f                      	subi b0, -1
000108 fd26                      	sbrc a0, 6
000109 5f6e                      	subi b0, -2
00010a fd27                      	sbrc a0, 7
00010b 5f6d                      	subi b0, -3
                                 
00010c 2fe6                      	mov zl, b0
00010d 27ff                      	clr zh
00010e 54e4                      	subi zl, low(-2*KeySet01)
00010f 4ffd                      	sbci zh, high(-2*KeySet01)
000110 95c8                      	lpm
000111 2d60                      	mov b0, r0
000112 9508                      	ret
                                 .include "lcd.asm"
                                 
                                 ; purpose  LCD HD44780U library
                                 ; ATmega 128 and Atmel Studio 7.0 compliant
                                 
                                 ; === definitions ===
                                 .equ	LCD_IR	= 0x8000	; address LCD instruction reg
                                 .equ	LCD_DR	= 0xc000	; address LCD data register
                                 
                                 ; === subroutines ===
                                 LCD_wr_ir:
                                 ; in	w (byte to write to LCD IR)
000113 9030 8000                 	lds	u, LCD_IR		; read IR to check busy flag  (bit7)
000115 fc37
000116 cffc                      	JB1	u,7,LCD_wr_ir	; Jump if Bit=1 (still busy)
000117 d003                      	rcall	lcd_4us		; delay to increment DRAM addr counter
000118 9300 8000                 	sts	LCD_IR, w		; store w in IR
00011a 9508                      	ret
                                 	
                                 lcd_4us:
00011b d000                      	rcall	lcd_2us		; recursive call		
                                 lcd_2us:
00011c 0000                      	nop					; rcall(3) + nop(1) + ret(4) = 8 cycles (2us)
00011d 9508                      	ret
                                 
                                 LCD:
                                 LCD_putc:
00011e 302d
00011f f179                      	JK	a0,CR,LCD_cr	; Jump if a0=CR
000120 302a
000121 f1b9                      	JK	a0,LF,LCD_lf	; Jump if a0=LF
                                 LCD_wr_dr:
                                 ; in	a0 (byte to write to LCD DR)
000122 9100 8000                 	lds	w, LCD_IR		; read IR to check busy flag  (bit7)
000124 fd07
000125 cffc                      	JB1	w,7,LCD_wr_dr	; Jump if Bit=1 (still busy)
000126 dff4                      	rcall	lcd_4us		; delay to increment DRAM addr counter
000127 9320 c000                 	sts	LCD_DR, a0		; store a0 in DR
000129 9508                      	ret	
                                 	
00012a e001
00012b cfe7                      LCD_clear:		JW	LCD_wr_ir, 0b00000001		; clear display
00012c e002
00012d cfe5                      LCD_home:		JW	LCD_wr_ir, 0b00000010		; return home
00012e e100
00012f cfe3                      LCD_cursor_left:	JW	LCD_wr_ir, 0b00010000	; move cursor to left
000130 e104
000131 cfe1                      LCD_cursor_right:	JW	LCD_wr_ir, 0b00010100	; move cursor to right
000132 e108
000133 cfdf                      LCD_display_left:	JW	LCD_wr_ir, 0b00011000	; shifts display to left
000134 e10c
000135 cfdd                      LCD_display_right:	JW	LCD_wr_ir, 0b00011100	; shifts display to right
000136 e00d
000137 cfdb                      LCD_blink_on:		JW	LCD_wr_ir, 0b00001101	; Display=1,Cursor=0,Blink=1
000138 e00c
000139 cfd9                      LCD_blink_off:		JW	LCD_wr_ir, 0b00001100	; Display=1,Cursor=0,Blink=0
00013a e00e
00013b cfd7                      LCD_cursor_on:		JW	LCD_wr_ir, 0b00001110	; Display=1,Cursor=1,Blink=0
00013c e00c
00013d cfd5                      LCD_cursor_off:		JW	LCD_wr_ir, 0b00001100	; Display=1,Cursor=0,Blink=0
00013e e00f
00013f cfd3                      LCD_cursorblink: 	JW	LCD_wr_ir, 0b00001111	; Display=1,Cursor=1,Blink=1	
                                 LCD_init:
000140 b705                      	in	w,MCUCR					; enable access to ext. SRAM
000141 6c00                      	sbr	w,(1<<SRE)+(1<<SRW10)
000142 bf05                      	out	MCUCR,w
000143 e001
000144 dfce                      	CW	LCD_wr_ir, 0b00000001	; clear display
000145 e006
000146 dfcc                      	CW	LCD_wr_ir, 0b00000110	; entry mode set (Inc=1, Shift=0)
000147 e00c
000148 dfca                      	CW	LCD_wr_ir, 0b00001100	; Display=1,Cursor=0,Blink=0	
000149 e308
00014a dfc8                      	CW	LCD_wr_ir, 0b00111000	; 8bits=1, 2lines=1, 5x8dots=0
00014b 9508                      	ret
                                 
                                 LCD_pos:
                                 ; in	a0 = position (0x00..0x0f first line, 0x40..0x4f second line)
00014c 2f02                      	mov	w,a0
00014d 6800                      	ori	w,0b10000000
00014e cfc4                      	rjmp	LCD_wr_ir
                                 
                                 LCD_cr:
                                 ; moving the cursor to the beginning of the line (carriage return)
00014f 9100 8000                 	lds	w, LCD_IR			; read IR to check busy flag  (bit7)
000151 fd07
000152 cffc                      	JB1	w,7,LCD_cr			; Jump if Bit=1 (still busy)
000153 7400                      	andi	w,0b01000000	; keep bit6 (begin of line 1/2)
000154 6800                      	ori	w,0b10000000		; write address command
000155 dfc5                      	rcall	lcd_4us			; delay to increment DRAM addr counter
000156 9300 8000                 	sts	LCD_IR,w			; store in IR
000158 9508                      	ret
                                 
                                 LCD_lf:
                                 ; moving the cursor to the beginning of the line 2 (line feed)
000159 932f                      	push	a0				; safeguard a0
00015a e420                      	ldi	a0,$40				; load position $40 (begin of line 2)
00015b dff0                      	rcall	LCD_pos			; set cursor position
00015c 912f                      	pop	a0					; restore a0
                                 .include "string.asm"
00015d 9508                      
                                 ; AssemblerApplication1.asm
                                 ;
                                 ; Created: 30/04/2024 10:34:37
                                 ; Author : renuka
                                 ; File containing all strings to 
                                 ; print on LCD screen
                                 
                                 
                                 .cseg
                                 ;.org 
                                 ; Keypad LUT
                                 KeySet01:
00015e 3231
00015f 4133
000160 3534
000161 4236
000162 3837
000163 4339
000164 302a
000165 4423
C:\Users\renuka\Desktop\projet\MCU\AssemblerApplication1\AssemblerApplication1\string.asm(14): warning: .cseg .db misalignment - padding zero byte
C:\Users\renuka\Desktop\projet\MCU\AssemblerApplication1\AssemblerApplication1\mainbis.asm(102): 'C:\Users\renuka\Desktop\projet\MCU\AssemblerApplication1\AssemblerApplication1\string.asm' included form here
000166 0000                      .db "123A456B789C*0#D", 0 
                                 
                                 ; Menu of game
                                 str0:
000167 4557
000168 434c
000169 4d4f
00016a 2045
00016b 4f54
00016c 0020                      .db "WELCOME TO ", 0
                                 str1:
00016d 434d
00016e 2055
00016f 4150
000170 5452
000171 0059                      .db "MCU PARTY", 0
                                 str2:
000172 2e41
000173 5020
000174 414c
000175 2059
000176 4147
000177 454d
C:\Users\renuka\Desktop\projet\MCU\AssemblerApplication1\AssemblerApplication1\string.asm(22): warning: .cseg .db misalignment - padding zero byte
C:\Users\renuka\Desktop\projet\MCU\AssemblerApplication1\AssemblerApplication1\mainbis.asm(102): 'C:\Users\renuka\Desktop\projet\MCU\AssemblerApplication1\AssemblerApplication1\string.asm' included form here
000178 0000                      .db "A. PLAY GAME", 0
                                 str3:
000179 2e42
00017a 4f20
00017b 4550
00017c 204e
00017d 4153
00017e 4546
C:\Users\renuka\Desktop\projet\MCU\AssemblerApplication1\AssemblerApplication1\string.asm(24): warning: .cseg .db misalignment - padding zero byte
C:\Users\renuka\Desktop\projet\MCU\AssemblerApplication1\AssemblerApplication1\mainbis.asm(102): 'C:\Users\renuka\Desktop\projet\MCU\AssemblerApplication1\AssemblerApplication1\string.asm' included form here
00017f 0000                      .db "B. OPEN SAFE", 0
                                 
                                 ; general
                                 strwelcome:
000180 6557
000181 636c
000182 6d6f
000183 2065
000184 6f74
C:\Users\renuka\Desktop\projet\MCU\AssemblerApplication1\AssemblerApplication1\string.asm(28): warning: .cseg .db misalignment - padding zero byte
C:\Users\renuka\Desktop\projet\MCU\AssemblerApplication1\AssemblerApplication1\mainbis.asm(102): 'C:\Users\renuka\Desktop\projet\MCU\AssemblerApplication1\AssemblerApplication1\string.asm' included form here
000185 0000                      .db "Welcome to",0
                                 
                                 strivia:
000186 7274
000187 7669
000188 6169
000189 3a20
00018a 0029                      .db "trivia :)",0
                                 
                                 strbutton:
00018b 6874
00018c 2065
00018d 7562
00018e 7474
00018f 6e6f
000190 3a20
000191 0029                      .db "the button :)",0
                                 
                                 strcorrect:
000192 6f43
000193 7272
000194 6365
000195 2174
C:\Users\renuka\Desktop\projet\MCU\AssemblerApplication1\AssemblerApplication1\string.asm(37): warning: .cseg .db misalignment - padding zero byte
C:\Users\renuka\Desktop\projet\MCU\AssemblerApplication1\AssemblerApplication1\mainbis.asm(102): 'C:\Users\renuka\Desktop\projet\MCU\AssemblerApplication1\AssemblerApplication1\string.asm' included form here
000196 0000                      .db "Correct!",0
                                 
                                 strfalse:
000197 6146
000198 736c
000199 2165
C:\Users\renuka\Desktop\projet\MCU\AssemblerApplication1\AssemblerApplication1\string.asm(40): warning: .cseg .db misalignment - padding zero byte
C:\Users\renuka\Desktop\projet\MCU\AssemblerApplication1\AssemblerApplication1\mainbis.asm(102): 'C:\Users\renuka\Desktop\projet\MCU\AssemblerApplication1\AssemblerApplication1\string.asm' included form here
00019a 0000                      .db "False!",0
                                 
                                 strivia2:
00019b 6e41
00019c 7773
00019d 7265
00019e 3520
00019f 312f
0001a0 2030
0001a1 6f63
0001a2 002d                      .db "Answer 5/10 co-",0
                                 
                                 strivia3:
0001a3 7272
0001a4 6365
0001a5 6c74
0001a6 2079
0001a7 6f74
0001a8 7720
0001a9 6e69
C:\Users\renuka\Desktop\projet\MCU\AssemblerApplication1\AssemblerApplication1\string.asm(46): warning: .cseg .db misalignment - padding zero byte
C:\Users\renuka\Desktop\projet\MCU\AssemblerApplication1\AssemblerApplication1\mainbis.asm(102): 'C:\Users\renuka\Desktop\projet\MCU\AssemblerApplication1\AssemblerApplication1\string.asm' included form here
0001aa 0000                      .db "rrectly to win",0
                                 
                                 strclue1a:
0001ab 7331
0001ac 2074
0001ad 6c63
0001ae 6575
0001af 003a                      .db "1st clue:",0
                                 
                                 strclue1b:
0001b0 4e53
0001b1 574f
0001b2 5720
0001b3 4948
0001b4 4554
C:\Users\renuka\Desktop\projet\MCU\AssemblerApplication1\AssemblerApplication1\string.asm(52): warning: .cseg .db misalignment - padding zero byte
C:\Users\renuka\Desktop\projet\MCU\AssemblerApplication1\AssemblerApplication1\mainbis.asm(102): 'C:\Users\renuka\Desktop\projet\MCU\AssemblerApplication1\AssemblerApplication1\string.asm' included form here
0001b5 0000                      .db "SNOW WHITE",0
                                 
                                 strwin1:
0001b6 4f43
0001b7 474e
0001b8 4152
0001b9 5554
0001ba 414c
0001bb 4954
0001bc 4e4f
0001bd 0053                      .db "CONGRATULATIONS",0
                                 
                                 strwin2:
0001be 4f59
0001bf 2055
0001c0 4957
0001c1 004e                      .db "YOU WIN",0
                                 
                                 strlose1:
0001c2 4f59
0001c3 2055
0001c4 4f4c
0001c5 4553
0001c6 002c                      .db "YOU LOSE,",0
                                 
                                 strlose2:
0001c7 5254
0001c8 2059
0001c9 4741
0001ca 4941
0001cb 004e                      .db "TRY AGAIN",0
                                 
                                 ; Choose games
                                 str4:
0001cc 2e41
0001cd 5420
0001ce 4952
0001cf 4956
0001d0 2041
0001d1 5551
0001d2 5a49
C:\Users\renuka\Desktop\projet\MCU\AssemblerApplication1\AssemblerApplication1\string.asm(68): warning: .cseg .db misalignment - padding zero byte
C:\Users\renuka\Desktop\projet\MCU\AssemblerApplication1\AssemblerApplication1\mainbis.asm(102): 'C:\Users\renuka\Desktop\projet\MCU\AssemblerApplication1\AssemblerApplication1\string.asm' included form here
0001d3 0000                      .db "A. TRIVIA QUIZ", 0
                                 str5:
0001d4 2e42
0001d5 4220
0001d6 5455
0001d7 4f54
0001d8 204e
0001d9 4144
0001da 434e
0001db 0045                      .db "B. BUTTON DANCE", 0
                                 
                                 ; Open safe
                                 str6:
0001dc 4e45
0001dd 4554
0001de 2052
0001df 4150
0001e0 5353
0001e1 4f43
0001e2 4544
C:\Users\renuka\Desktop\projet\MCU\AssemblerApplication1\AssemblerApplication1\string.asm(74): warning: .cseg .db misalignment - padding zero byte
C:\Users\renuka\Desktop\projet\MCU\AssemblerApplication1\AssemblerApplication1\mainbis.asm(102): 'C:\Users\renuka\Desktop\projet\MCU\AssemblerApplication1\AssemblerApplication1\string.asm' included form here
0001e3 0000                      .db "ENTER PASSCODE", 0
                                 str7:
0001e4 4e49
0001e5 4f43
0001e6 5252
0001e7 4345
0001e8 2054
0001e9 4150
0001ea 5353
0001eb 4f43
0001ec 4544
C:\Users\renuka\Desktop\projet\MCU\AssemblerApplication1\AssemblerApplication1\string.asm(76): warning: .cseg .db misalignment - padding zero byte
C:\Users\renuka\Desktop\projet\MCU\AssemblerApplication1\AssemblerApplication1\mainbis.asm(102): 'C:\Users\renuka\Desktop\projet\MCU\AssemblerApplication1\AssemblerApplication1\string.asm' included form here
0001ed 0000                      .db "INCORRECT PASSCODE", 0
                                 str8:
0001ee 4f43
0001ef 474e
0001f0 4152
0001f1 5554
0001f2 414c
0001f3 4954
0001f4 4e4f
0001f5 2c53
0001f6 0020                      .db "CONGRATULATIONS, ", 0
                                 str9:
0001f7 4f59
0001f8 2055
0001f9 4957
0001fa 204e
0001fb 4854
0001fc 5349
0001fd 4720
0001fe 4d41
0001ff 2045
000200 0021                      .db "YOU WIN THIS GAME !", 0
                                 str10:
000201 4854
000202 4e41
000203 534b
000204 4620
000205 524f
C:\Users\renuka\Desktop\projet\MCU\AssemblerApplication1\AssemblerApplication1\string.asm(82): warning: .cseg .db misalignment - padding zero byte
C:\Users\renuka\Desktop\projet\MCU\AssemblerApplication1\AssemblerApplication1\mainbis.asm(102): 'C:\Users\renuka\Desktop\projet\MCU\AssemblerApplication1\AssemblerApplication1\string.asm' included form here
000206 0000                      .db "THANKS FOR", 0
                                 str11:
000207 4c50
000208 5941
000209 4e49
00020a 2147
00020b 3a20
00020c 0044                      .db "PLAYING! :D", 0
                                 
                                 ; Quiz trivia
                                 ; Question 1
                                 striviaQ1:
00020d 6857
00020e 206f
00020f 7277
000210 746f
000211 2065
000212 6874
000213 0065                      .db "Who wrote the", 0
                                 striviaQ12:
000214 6f73
000215 676e
000216 2720
000217 6874
000218 6972
000219 6c6c
00021a 7265
00021b 3f27
C:\Users\renuka\Desktop\projet\MCU\AssemblerApplication1\AssemblerApplication1\string.asm(91): warning: .cseg .db misalignment - padding zero byte
C:\Users\renuka\Desktop\projet\MCU\AssemblerApplication1\AssemblerApplication1\mainbis.asm(102): 'C:\Users\renuka\Desktop\projet\MCU\AssemblerApplication1\AssemblerApplication1\string.asm' included form here
00021c 0000                      .db "song 'thriller'?", 0
                                 strivia1A:
00021d 2e41
00021e 5020
00021f 414c
000220 4259
000221 494f
000222 4320
000223 5241
000224 4954
C:\Users\renuka\Desktop\projet\MCU\AssemblerApplication1\AssemblerApplication1\string.asm(93): warning: .cseg .db misalignment - padding zero byte
C:\Users\renuka\Desktop\projet\MCU\AssemblerApplication1\AssemblerApplication1\mainbis.asm(102): 'C:\Users\renuka\Desktop\projet\MCU\AssemblerApplication1\AssemblerApplication1\string.asm' included form here
000225 0000                      .db "A. PLAYBOI CARTI", 0
                                 strivia1B:
000226 2e42
000227 5420
000228 4152
000229 5943
00022a 4320
00022b 4148
00022c 4d50
00022d 4e41
C:\Users\renuka\Desktop\projet\MCU\AssemblerApplication1\AssemblerApplication1\string.asm(95): warning: .cseg .db misalignment - padding zero byte
C:\Users\renuka\Desktop\projet\MCU\AssemblerApplication1\AssemblerApplication1\mainbis.asm(102): 'C:\Users\renuka\Desktop\projet\MCU\AssemblerApplication1\AssemblerApplication1\string.asm' included form here
00022e 0000                      .db "B. TRACY CHAPMAN", 0
                                 strivia1C:
00022f 2e43
000230 4120
000231 202e
000232 4353
000233 4d48
000234 4449
C:\Users\renuka\Desktop\projet\MCU\AssemblerApplication1\AssemblerApplication1\string.asm(97): warning: .cseg .db misalignment - padding zero byte
C:\Users\renuka\Desktop\projet\MCU\AssemblerApplication1\AssemblerApplication1\mainbis.asm(102): 'C:\Users\renuka\Desktop\projet\MCU\AssemblerApplication1\AssemblerApplication1\string.asm' included form here
000235 0000                      .db "C. A. SCHMID", 0
                                 strivia1D:
000236 2e44
000237 4d20
000238 202e
000239 414a
00023a 4b43
00023b 4f53
00023c 004e                      .db "D. M. JACKSON", 0
                                 answer1:
C:\Users\renuka\Desktop\projet\MCU\AssemblerApplication1\AssemblerApplication1\string.asm(101): warning: .cseg .db misalignment - padding zero byte
C:\Users\renuka\Desktop\projet\MCU\AssemblerApplication1\AssemblerApplication1\mainbis.asm(102): 'C:\Users\renuka\Desktop\projet\MCU\AssemblerApplication1\AssemblerApplication1\string.asm' included form here
00023d 0088                      .db 0x88 ; 0xef
                                 
                                 ; Question 2
                                 striviaQ2:
00023e 6857
00023f 206f
000240 6c70
000241 7961
000242 0073                      .db "Who plays", 0
                                 striviaQ22:
000243 6548
000244 6d72
000245 6f69
000246 656e
000247 003f                      .db "Hermione?", 0
                                 strivia2A:
000248 2e41
000249 4520
00024a 4d4d
00024b 2041
00024c 4157
00024d 5354
00024e 4e4f
C:\Users\renuka\Desktop\projet\MCU\AssemblerApplication1\AssemblerApplication1\string.asm(109): warning: .cseg .db misalignment - padding zero byte
C:\Users\renuka\Desktop\projet\MCU\AssemblerApplication1\AssemblerApplication1\mainbis.asm(102): 'C:\Users\renuka\Desktop\projet\MCU\AssemblerApplication1\AssemblerApplication1\string.asm' included form here
00024f 0000                      .db "A. EMMA WATSON", 0
                                 strivia2B:
000250 2e42
000251 4520
000252 4d4d
000253 2041
000254 5453
000255 4e4f
000256 0045                      .db "B. EMMA STONE", 0
                                 strivia2C:
000257 2e43
000258 5020
000259 414c
00025a 4259
00025b 494f
00025c 4320
00025d 5241
00025e 4954
C:\Users\renuka\Desktop\projet\MCU\AssemblerApplication1\AssemblerApplication1\string.asm(113): warning: .cseg .db misalignment - padding zero byte
C:\Users\renuka\Desktop\projet\MCU\AssemblerApplication1\AssemblerApplication1\mainbis.asm(102): 'C:\Users\renuka\Desktop\projet\MCU\AssemblerApplication1\AssemblerApplication1\string.asm' included form here
00025f 0000                      .db "C. PLAYBOI CARTI", 0
                                 strivia2D:
000260 2e44
000261 5a20
000262 454f
000263 5320
000264 4c41
000265 4144
000266 414e
C:\Users\renuka\Desktop\projet\MCU\AssemblerApplication1\AssemblerApplication1\string.asm(115): warning: .cseg .db misalignment - padding zero byte
C:\Users\renuka\Desktop\projet\MCU\AssemblerApplication1\AssemblerApplication1\mainbis.asm(102): 'C:\Users\renuka\Desktop\projet\MCU\AssemblerApplication1\AssemblerApplication1\string.asm' included form here
000267 0000                      .db "D. ZOE SALDANA", 0
                                 answer2:
C:\Users\renuka\Desktop\projet\MCU\AssemblerApplication1\AssemblerApplication1\string.asm(117): warning: .cseg .db misalignment - padding zero byte
C:\Users\renuka\Desktop\projet\MCU\AssemblerApplication1\AssemblerApplication1\mainbis.asm(102): 'C:\Users\renuka\Desktop\projet\MCU\AssemblerApplication1\AssemblerApplication1\string.asm' included form here
000268 0081                      .db 0x81 ; 0xfd
                                 
                                 ; Question 3
                                 striviaQ3:
000269 6857
00026a 6369
00026b 2068
00026c 6162
00026d 646e
00026e 7720
00026f 6f72
000270 6574
C:\Users\renuka\Desktop\projet\MCU\AssemblerApplication1\AssemblerApplication1\string.asm(121): warning: .cseg .db misalignment - padding zero byte
C:\Users\renuka\Desktop\projet\MCU\AssemblerApplication1\AssemblerApplication1\mainbis.asm(102): 'C:\Users\renuka\Desktop\projet\MCU\AssemblerApplication1\AssemblerApplication1\string.asm' included form here
000271 0000                      .db "Which band wrote", 0
                                 striviaQ32:
000272 6827
000273 7965
000274 7920
000275 756f
000276 2027
000277 003f                      .db "'hey you' ?", 0
                                 strivia3A:
000278 2e41
000279 5020
00027a 414c
00027b 4259
00027c 494f
00027d 4320
00027e 5241
00027f 4954
C:\Users\renuka\Desktop\projet\MCU\AssemblerApplication1\AssemblerApplication1\string.asm(125): warning: .cseg .db misalignment - padding zero byte
C:\Users\renuka\Desktop\projet\MCU\AssemblerApplication1\AssemblerApplication1\mainbis.asm(102): 'C:\Users\renuka\Desktop\projet\MCU\AssemblerApplication1\AssemblerApplication1\string.asm' included form here
000280 0000                      .db "A. PLAYBOI CARTI", 0
                                 strivia3B:
000281 2e42
000282 4c20
000283 4445
000284 5a20
000285 5045
000286 4c50
000287 4e49
C:\Users\renuka\Desktop\projet\MCU\AssemblerApplication1\AssemblerApplication1\string.asm(127): warning: .cseg .db misalignment - padding zero byte
C:\Users\renuka\Desktop\projet\MCU\AssemblerApplication1\AssemblerApplication1\mainbis.asm(102): 'C:\Users\renuka\Desktop\projet\MCU\AssemblerApplication1\AssemblerApplication1\string.asm' included form here
000288 0000                      .db "B. LED ZEPPLIN", 0
                                 strivia3C:
000289 2e43
00028a 4a20
00028b 554f
00028c 4e52
00028d 5945
C:\Users\renuka\Desktop\projet\MCU\AssemblerApplication1\AssemblerApplication1\string.asm(129): warning: .cseg .db misalignment - padding zero byte
C:\Users\renuka\Desktop\projet\MCU\AssemblerApplication1\AssemblerApplication1\mainbis.asm(102): 'C:\Users\renuka\Desktop\projet\MCU\AssemblerApplication1\AssemblerApplication1\string.asm' included form here
00028e 0000                      .db "C. JOURNEY", 0
                                 strivia3D:
00028f 2e44
000290 5020
000291 4e49
000292 204b
000293 4c46
000294 594f
000295 0044                      .db "D. PINK FLOYD", 0
                                 answer3:
C:\Users\renuka\Desktop\projet\MCU\AssemblerApplication1\AssemblerApplication1\string.asm(133): warning: .cseg .db misalignment - padding zero byte
C:\Users\renuka\Desktop\projet\MCU\AssemblerApplication1\AssemblerApplication1\mainbis.asm(102): 'C:\Users\renuka\Desktop\projet\MCU\AssemblerApplication1\AssemblerApplication1\string.asm' included form here
000296 0088                      .db 0x88 ; 0xef
                                 
                                 ; Question 4
                                 striviaQ4:
000297 6857
000298 206f
000299 7277
00029a 746f
00029b 2065
00029c 4127
00029d 7269
C:\Users\renuka\Desktop\projet\MCU\AssemblerApplication1\AssemblerApplication1\string.asm(137): warning: .cseg .db misalignment - padding zero byte
C:\Users\renuka\Desktop\projet\MCU\AssemblerApplication1\AssemblerApplication1\mainbis.asm(102): 'C:\Users\renuka\Desktop\projet\MCU\AssemblerApplication1\AssemblerApplication1\string.asm' included form here
00029e 0000                      .db "Who wrote 'Air", 0
                                 striviaQ42:
00029f 6e6f
0002a0 4720
0002a1 7320
0002a2 7274
0002a3 6e69
0002a4 2767
0002a5 003f                      .db "on G string'?", 0
                                 strivia4A:
0002a6 2e41
0002a7 5020
0002a8 414c
0002a9 4259
0002aa 494f
0002ab 4320
0002ac 5241
0002ad 4954
C:\Users\renuka\Desktop\projet\MCU\AssemblerApplication1\AssemblerApplication1\string.asm(141): warning: .cseg .db misalignment - padding zero byte
C:\Users\renuka\Desktop\projet\MCU\AssemblerApplication1\AssemblerApplication1\mainbis.asm(102): 'C:\Users\renuka\Desktop\projet\MCU\AssemblerApplication1\AssemblerApplication1\string.asm' included form here
0002ae 0000                      .db "A. PLAYBOI CARTI", 0
                                 strivia4B:
0002af 2e42
0002b0 4220
0002b1 4545
0002b2 4854
0002b3 564f
0002b4 4e45
C:\Users\renuka\Desktop\projet\MCU\AssemblerApplication1\AssemblerApplication1\string.asm(143): warning: .cseg .db misalignment - padding zero byte
C:\Users\renuka\Desktop\projet\MCU\AssemblerApplication1\AssemblerApplication1\mainbis.asm(102): 'C:\Users\renuka\Desktop\projet\MCU\AssemblerApplication1\AssemblerApplication1\string.asm' included form here
0002b5 0000                      .db "B. BEETHOVEN", 0
                                 strivia4C:
0002b6 2e43
0002b7 5320
0002b8 4843
0002b9 4255
0002ba 5245
0002bb 0054                      .db "C. SCHUBERT", 0
                                 strivia4D:
0002bc 2e44
0002bd 4a20
0002be 532e
0002bf 202e
0002c0 4142
0002c1 4843
C:\Users\renuka\Desktop\projet\MCU\AssemblerApplication1\AssemblerApplication1\string.asm(147): warning: .cseg .db misalignment - padding zero byte
C:\Users\renuka\Desktop\projet\MCU\AssemblerApplication1\AssemblerApplication1\mainbis.asm(102): 'C:\Users\renuka\Desktop\projet\MCU\AssemblerApplication1\AssemblerApplication1\string.asm' included form here
0002c2 0000                      .db "D. J.S. BACH", 0
                                 answer4:
C:\Users\renuka\Desktop\projet\MCU\AssemblerApplication1\AssemblerApplication1\string.asm(149): warning: .cseg .db misalignment - padding zero byte
C:\Users\renuka\Desktop\projet\MCU\AssemblerApplication1\AssemblerApplication1\mainbis.asm(102): 'C:\Users\renuka\Desktop\projet\MCU\AssemblerApplication1\AssemblerApplication1\string.asm' included form here
0002c3 0088                      .db 0x88 ; 0xef
                                 
                                 ; Question 5
                                 striviaQ5:
0002c4 6857
0002c5 206f
0002c6 6574
0002c7 6361
0002c8 6568
0002c9 0073                      .db "Who teaches", 0
                                 striviaQ52:
0002ca 434d
0002cb 2055
0002cc 6562
0002cd 7473
0002ce 003f                      .db "MCU best?", 0
                                 strivia5A:
0002cf 2e41
0002d0 5020
0002d1 414c
0002d2 4259
0002d3 494f
0002d4 4320
0002d5 5241
0002d6 4954
C:\Users\renuka\Desktop\projet\MCU\AssemblerApplication1\AssemblerApplication1\string.asm(157): warning: .cseg .db misalignment - padding zero byte
C:\Users\renuka\Desktop\projet\MCU\AssemblerApplication1\AssemblerApplication1\mainbis.asm(102): 'C:\Users\renuka\Desktop\projet\MCU\AssemblerApplication1\AssemblerApplication1\string.asm' included form here
0002d7 0000                      .db "A. PLAYBOI CARTI", 0
                                 strivia5B:
0002d8 2e42
0002d9 4120
0002da 202e
0002db 4353
0002dc 4d48
0002dd 4449
C:\Users\renuka\Desktop\projet\MCU\AssemblerApplication1\AssemblerApplication1\string.asm(159): warning: .cseg .db misalignment - padding zero byte
C:\Users\renuka\Desktop\projet\MCU\AssemblerApplication1\AssemblerApplication1\mainbis.asm(102): 'C:\Users\renuka\Desktop\projet\MCU\AssemblerApplication1\AssemblerApplication1\string.asm' included form here
0002de 0000                      .db "B. A. SCHMID", 0
                                 strivia5C:
0002df 2e43
0002e0 4d20
0002e1 202e
0002e2 4c41
0002e3 0049                      .db "C. M. ALI", 0
                                 strivia5D:
0002e4 2e44
0002e5 4320
0002e6 2052
0002e7 0037                      .db "D. CR 7", 0
                                 answer5:
C:\Users\renuka\Desktop\projet\MCU\AssemblerApplication1\AssemblerApplication1\string.asm(165): warning: .cseg .db misalignment - padding zero byte
C:\Users\renuka\Desktop\projet\MCU\AssemblerApplication1\AssemblerApplication1\mainbis.asm(102): 'C:\Users\renuka\Desktop\projet\MCU\AssemblerApplication1\AssemblerApplication1\string.asm' included form here
0002e8 0082                      .db 0x82 ; 0xfb
                                 
                                 ; Question 6
                                 striviaQ6:
0002e9 6857
0002ea 206f
0002eb 6f77
0002ec 206e
0002ed 6874
0002ee 2065
0002ef 3032
0002f0 3232
C:\Users\renuka\Desktop\projet\MCU\AssemblerApplication1\AssemblerApplication1\string.asm(169): warning: .cseg .db misalignment - padding zero byte
C:\Users\renuka\Desktop\projet\MCU\AssemblerApplication1\AssemblerApplication1\mainbis.asm(102): 'C:\Users\renuka\Desktop\projet\MCU\AssemblerApplication1\AssemblerApplication1\string.asm' included form here
0002f1 0000                      .db "Who won the 2022", 0
                                 striviaQ62:
0002f2 4946
0002f3 4146
0002f4 5720
0002f5 726f
0002f6 646c
0002f7 4320
0002f8 7075
0002f9 003f                      .db "FIFA World Cup?", 0
                                 strivia6A:
0002fa 2e41
0002fb 5020
0002fc 414c
0002fd 4259
0002fe 494f
0002ff 4320
000300 5241
000301 4954
C:\Users\renuka\Desktop\projet\MCU\AssemblerApplication1\AssemblerApplication1\string.asm(173): warning: .cseg .db misalignment - padding zero byte
C:\Users\renuka\Desktop\projet\MCU\AssemblerApplication1\AssemblerApplication1\mainbis.asm(102): 'C:\Users\renuka\Desktop\projet\MCU\AssemblerApplication1\AssemblerApplication1\string.asm' included form here
000302 0000                      .db "A. PLAYBOI CARTI", 0
                                 strivia6B:
000303 2e42
000304 5320
000305 4957
000306 5a54
000307 5245
000308 414c
000309 444e
C:\Users\renuka\Desktop\projet\MCU\AssemblerApplication1\AssemblerApplication1\string.asm(175): warning: .cseg .db misalignment - padding zero byte
C:\Users\renuka\Desktop\projet\MCU\AssemblerApplication1\AssemblerApplication1\mainbis.asm(102): 'C:\Users\renuka\Desktop\projet\MCU\AssemblerApplication1\AssemblerApplication1\string.asm' included form here
00030a 0000                      .db "B. SWITZERLAND", 0
                                 strivia6C:
00030b 2e43
00030c 4120
00030d 4752
00030e 4e45
00030f 4954
000310 414e
C:\Users\renuka\Desktop\projet\MCU\AssemblerApplication1\AssemblerApplication1\string.asm(177): warning: .cseg .db misalignment - padding zero byte
C:\Users\renuka\Desktop\projet\MCU\AssemblerApplication1\AssemblerApplication1\mainbis.asm(102): 'C:\Users\renuka\Desktop\projet\MCU\AssemblerApplication1\AssemblerApplication1\string.asm' included form here
000311 0000                      .db "C. ARGENTINA", 0
                                 strivia6D:
000312 2e44
000313 4620
000314 4152
000315 434e
000316 0045                      .db "D. FRANCE", 0
                                 answer6:
C:\Users\renuka\Desktop\projet\MCU\AssemblerApplication1\AssemblerApplication1\string.asm(181): warning: .cseg .db misalignment - padding zero byte
C:\Users\renuka\Desktop\projet\MCU\AssemblerApplication1\AssemblerApplication1\mainbis.asm(102): 'C:\Users\renuka\Desktop\projet\MCU\AssemblerApplication1\AssemblerApplication1\string.asm' included form here
000317 0084                      .db 0x84 ; 0xf7
                                 
                                 ; Question 7
                                 striviaQ7:
000318 6857
000319 6369
00031a 2068
00031b 6964
00031c 6873
00031d 6920
00031e 0073                      .db "Which dish is", 0
                                 striviaQ72:
00031f 6f6e
000320 2074
000321 7773
000322 7369
000323 3f73
C:\Users\renuka\Desktop\projet\MCU\AssemblerApplication1\AssemblerApplication1\string.asm(187): warning: .cseg .db misalignment - padding zero byte
C:\Users\renuka\Desktop\projet\MCU\AssemblerApplication1\AssemblerApplication1\mainbis.asm(102): 'C:\Users\renuka\Desktop\projet\MCU\AssemblerApplication1\AssemblerApplication1\string.asm' included form here
000324 0000                      .db "not swiss?", 0
                                 strivia7A:
000325 2e41
000326 5020
000327 414c
000328 4259
000329 494f
00032a 4320
00032b 5241
00032c 4954
C:\Users\renuka\Desktop\projet\MCU\AssemblerApplication1\AssemblerApplication1\string.asm(189): warning: .cseg .db misalignment - padding zero byte
C:\Users\renuka\Desktop\projet\MCU\AssemblerApplication1\AssemblerApplication1\mainbis.asm(102): 'C:\Users\renuka\Desktop\projet\MCU\AssemblerApplication1\AssemblerApplication1\string.asm' included form here
00032d 0000                      .db "A. PLAYBOI CARTI", 0
                                 strivia7B:
00032e 2e42
00032f 5220
000330 4341
000331 454c
000332 5454
000333 0045                      .db "B. RACLETTE", 0
                                 strivia7C:
000334 2e43
000335 4620
000336 4e4f
000337 5544
000338 0045                      .db "C. FONDUE", 0
                                 strivia7D:
000339 2e44
00033a 5220
00033b 454f
00033c 5453
00033d 0049                      .db "D. ROESTI", 0
                                 answer7:
C:\Users\renuka\Desktop\projet\MCU\AssemblerApplication1\AssemblerApplication1\string.asm(197): warning: .cseg .db misalignment - padding zero byte
C:\Users\renuka\Desktop\projet\MCU\AssemblerApplication1\AssemblerApplication1\mainbis.asm(102): 'C:\Users\renuka\Desktop\projet\MCU\AssemblerApplication1\AssemblerApplication1\string.asm' included form here
00033e 0081                      .db 0x81 ; 0xfd
                                 
                                 ; Question 8
                                 striviaQ8:
00033f 6857
000340 7461
000341 7327
000342 7420
000343 6568
000344 6320
000345 7061
000346 2d69
C:\Users\renuka\Desktop\projet\MCU\AssemblerApplication1\AssemblerApplication1\string.asm(201): warning: .cseg .db misalignment - padding zero byte
C:\Users\renuka\Desktop\projet\MCU\AssemblerApplication1\AssemblerApplication1\mainbis.asm(102): 'C:\Users\renuka\Desktop\projet\MCU\AssemblerApplication1\AssemblerApplication1\string.asm' included form here
000347 0000                      .db "What's the capi-", 0
                                 striviaQ82:
000348 6174
000349 206c
00034a 666f
00034b 4c20
00034c 6f61
00034d 3f73
C:\Users\renuka\Desktop\projet\MCU\AssemblerApplication1\AssemblerApplication1\string.asm(203): warning: .cseg .db misalignment - padding zero byte
C:\Users\renuka\Desktop\projet\MCU\AssemblerApplication1\AssemblerApplication1\mainbis.asm(102): 'C:\Users\renuka\Desktop\projet\MCU\AssemblerApplication1\AssemblerApplication1\string.asm' included form here
00034e 0000                      .db "tal of Laos?", 0
                                 strivia8A:
00034f 2e41
000350 4c20
000351 4f41
000352 0053                      .db "A. LAOS", 0
                                 strivia8B:
000353 2e42
000354 5620
000355 4549
000356 544e
000357 4149
000358 454e
C:\Users\renuka\Desktop\projet\MCU\AssemblerApplication1\AssemblerApplication1\string.asm(207): warning: .cseg .db misalignment - padding zero byte
C:\Users\renuka\Desktop\projet\MCU\AssemblerApplication1\AssemblerApplication1\mainbis.asm(102): 'C:\Users\renuka\Desktop\projet\MCU\AssemblerApplication1\AssemblerApplication1\string.asm' included form here
000359 0000                      .db "B. VIENTIANE", 0
                                 strivia8C:
00035a 2e43
00035b 5620
00035c 4e45
00035d 4349
00035e 0045                      .db "C. VENICE", 0
                                 strivia8D:
00035f 2e44
000360 5020
000361 414c
000362 4259
000363 494f
000364 4320
000365 5241
000366 4954
C:\Users\renuka\Desktop\projet\MCU\AssemblerApplication1\AssemblerApplication1\string.asm(211): warning: .cseg .db misalignment - padding zero byte
C:\Users\renuka\Desktop\projet\MCU\AssemblerApplication1\AssemblerApplication1\mainbis.asm(102): 'C:\Users\renuka\Desktop\projet\MCU\AssemblerApplication1\AssemblerApplication1\string.asm' included form here
000367 0000                      .db "D. PLAYBOI CARTI", 0
                                 answer8:
C:\Users\renuka\Desktop\projet\MCU\AssemblerApplication1\AssemblerApplication1\string.asm(213): warning: .cseg .db misalignment - padding zero byte
C:\Users\renuka\Desktop\projet\MCU\AssemblerApplication1\AssemblerApplication1\mainbis.asm(102): 'C:\Users\renuka\Desktop\projet\MCU\AssemblerApplication1\AssemblerApplication1\string.asm' included form here
000368 0082                      .db 0x82 ; 0xfb
                                 
                                 ; Question 9
                                 striviaQ9:
000369 6857
00036a 7461
00036b 7327
00036c 7420
00036d 6568
00036e 6220
00036f 7365
000370 0074                      .db "What's the best", 0
                                 striviaQ92:
000371 6573
000372 7463
000373 6f69
000374 206e
000375 7461
000376 4520
000377 4650
000378 3f4c
C:\Users\renuka\Desktop\projet\MCU\AssemblerApplication1\AssemblerApplication1\string.asm(219): warning: .cseg .db misalignment - padding zero byte
C:\Users\renuka\Desktop\projet\MCU\AssemblerApplication1\AssemblerApplication1\mainbis.asm(102): 'C:\Users\renuka\Desktop\projet\MCU\AssemblerApplication1\AssemblerApplication1\string.asm' included form here
000379 0000                      .db "section at EPFL?", 0
                                 strivia9A:
00037a 2e41
00037b 4c20
00037c 4649
00037d 2045
00037e 4353
00037f 4549
000380 434e
000381 5345
C:\Users\renuka\Desktop\projet\MCU\AssemblerApplication1\AssemblerApplication1\string.asm(221): warning: .cseg .db misalignment - padding zero byte
C:\Users\renuka\Desktop\projet\MCU\AssemblerApplication1\AssemblerApplication1\mainbis.asm(102): 'C:\Users\renuka\Desktop\projet\MCU\AssemblerApplication1\AssemblerApplication1\string.asm' included form here
000382 0000                      .db "A. LIFE SCIENCES", 0
                                 strivia9B:
000383 2e42
000384 4d20
000385 4349
000386 4f52
000387 4554
000388 4843
C:\Users\renuka\Desktop\projet\MCU\AssemblerApplication1\AssemblerApplication1\string.asm(223): warning: .cseg .db misalignment - padding zero byte
C:\Users\renuka\Desktop\projet\MCU\AssemblerApplication1\AssemblerApplication1\mainbis.asm(102): 'C:\Users\renuka\Desktop\projet\MCU\AssemblerApplication1\AssemblerApplication1\string.asm' included form here
000389 0000                      .db "B. MICROTECH", 0
                                 strivia9C:
00038a 2e43
00038b 4520
00038c 454c
00038d 0043                      .db "C. ELEC", 0
                                 strivia9D:
00038e 2e44
00038f 5020
000390 414c
000391 4259
000392 494f
000393 4320
000394 5241
000395 4954
C:\Users\renuka\Desktop\projet\MCU\AssemblerApplication1\AssemblerApplication1\string.asm(227): warning: .cseg .db misalignment - padding zero byte
C:\Users\renuka\Desktop\projet\MCU\AssemblerApplication1\AssemblerApplication1\mainbis.asm(102): 'C:\Users\renuka\Desktop\projet\MCU\AssemblerApplication1\AssemblerApplication1\string.asm' included form here
000396 0000                      .db "D. PLAYBOI CARTI", 0
                                 answer9:
C:\Users\renuka\Desktop\projet\MCU\AssemblerApplication1\AssemblerApplication1\string.asm(229): warning: .cseg .db misalignment - padding zero byte
C:\Users\renuka\Desktop\projet\MCU\AssemblerApplication1\AssemblerApplication1\mainbis.asm(102): 'C:\Users\renuka\Desktop\projet\MCU\AssemblerApplication1\AssemblerApplication1\string.asm' included form here
000397 0084                      .db 0x84 ; 0xf7
                                 
                                 ; Question 10
                                 striviaQ10:
000398 6857
000399 206f
00039a 7277
00039b 746f
00039c 2065
00039d 6874
00039e 0065                      .db "Who wrote the", 0
                                 striviaQ102:
00039f 6f73
0003a0 676e
0003a1 2720
0003a2 6b73
0003a3 2779
0003a4 003f                      .db "song 'sky'?", 0
                                 strivia10A:
0003a5 2e41
0003a6 4b20
0003a7 4e41
0003a8 4559
0003a9 5720
0003aa 5345
0003ab 0054                      .db "A. KANYE WEST", 0
                                 strivia10B:
0003ac 2e42
0003ad 5020
0003ae 414c
0003af 4259
0003b0 494f
0003b1 4320
0003b2 5241
0003b3 4954
C:\Users\renuka\Desktop\projet\MCU\AssemblerApplication1\AssemblerApplication1\string.asm(239): warning: .cseg .db misalignment - padding zero byte
C:\Users\renuka\Desktop\projet\MCU\AssemblerApplication1\AssemblerApplication1\mainbis.asm(102): 'C:\Users\renuka\Desktop\projet\MCU\AssemblerApplication1\AssemblerApplication1\string.asm' included form here
0003b4 0000                      .db "B. PLAYBOI CARTI", 0
                                 strivia10C:
0003b5 2e43
0003b6 4120
0003b7 202e
0003b8 4353
0003b9 4d48
0003ba 4449
C:\Users\renuka\Desktop\projet\MCU\AssemblerApplication1\AssemblerApplication1\string.asm(241): warning: .cseg .db misalignment - padding zero byte
C:\Users\renuka\Desktop\projet\MCU\AssemblerApplication1\AssemblerApplication1\mainbis.asm(102): 'C:\Users\renuka\Desktop\projet\MCU\AssemblerApplication1\AssemblerApplication1\string.asm' included form here
0003bb 0000                      .db "C. A. SCHMID", 0
                                 strivia10D:
0003bc 2e44
0003bd 5420
0003be 5941
0003bf 4f4c
0003c0 2052
0003c1 5753
0003c2 4649
0003c3 0054                      .db "D. TAYLOR SWIFT", 0
                                 answer10:
                                 .include "subroutines.asm"
C:\Users\renuka\Desktop\projet\MCU\AssemblerApplication1\AssemblerApplication1\subroutines.asm(1): warning: .cseg .db misalignment - padding zero byte
C:\Users\renuka\Desktop\projet\MCU\AssemblerApplication1\AssemblerApplication1\mainbis.asm(103): 'C:\Users\renuka\Desktop\projet\MCU\AssemblerApplication1\AssemblerApplication1\subroutines.asm' included form here
0003c4 0082                      
                                  * subroutines.asm
                                  *
                                  *  Created: 30/04/2024 11:21:07
                                  *   Author: renuka
                                  */ 
                                 
                                 ; code from: tp05 puts02.asm
                                  LCD_putstring:
0003c5 95c8                      	lpm
0003c6 2000                      	tst		r0
0003c7 f021                      	breq	done
0003c8 2d20                      	mov		a0, r0
0003c9 dd54                      	rcall	LCD_putc
0003ca 9631                      	adiw	zl, 1
0003cb cff9                      	rjmp	LCD_putstring
0003cc 9508                      done:ret
                                 .include "printf.asm"
                                 
                                 ; purpose library, formatted output generation
                                 ; author (c) R.Holzer (adapted MICRO210/EE208 A.Schmid)
                                 
                                 ; === description ===
                                 ; 
                                 ; The program "printf" interprets and prints formatted strings.
                                 ; The special formatting characters regognized are:
                                 ;
                                 ; FDEC	decimal number
                                 ; FHEX	hexadecimal number
                                 ; FBIN	binary number
                                 ; FFRAC	fixed fraction number
                                 ; FCHAR	single ASCII character
                                 ; FSTR	zero-terminated ASCII string
                                 	
                                 ; The special formatting characters are distinguished from normal 
                                 ; ASCII characters by having bit7 set to 1.
                                 
                                 ; Signification of bit fields:
                                 ;
                                 ; b 	bytes		1..4 b bytes		2
                                 ; s 	sign		0(unsigned), 1(signed)	1
                                 ; i		integer digits	
                                 ; e 	base		2,,36			5
                                 ; dp 	dec. point	0..32			5
                                 ; $if	i=integer digits,  0=all digits,  1..15 digits 
                                 ;		f=fraction digits, 0=no fraction, 1..15 digits
                                 ;
                                 ; Formatting characters must be followed by an SRAM address (0..ff)
                                 ; FBIN,	sram
                                 ; FHEX,	sram
                                 ; FDEC,	sram
                                 ; FCHAR,sram
                                 ; FSTR,	sram
                                 ;
                                 ; The address 'sram' is a 1-byte constant. It addresses
                                 ; 	 0..1f	registers r0..r31, 
                                 ; 	20..3f	i/o ports, (need to be addressed with an offset of $20)
                                 ;	60..ff	SRAM registers (warning: extended i/o in AVR128)
                                 
                                 ; The FFRAC formatting character must be followed by 
                                 ;	ONE sram address and 
                                 ;	TWO more formatting characters
                                 ; FFRAC,sram,dp,$if
                                 
                                 ; dp	decimal point position, 0=right, 32=left
                                 ; $if	format i.f, i=integer digits, f=fraction digits
                                 
                                 ; The special formatting characters use the following coding
                                 ;
                                 ; FDEC	11bb'iiis	i=0 all digits, i=1-7 digits
                                 ; FBIN	101i'iiis	i=0 8 digits,	i=1-7 digits
                                 ; FHEX	1001'iiis	i=0 8 digits,	i=1-7 digits
                                 ; FFRAC	1000'1bbs
                                 ; FCHAR	1000'0100
                                 ; FSTR	1000'0101
                                 ; FREP	1000'0110
                                 ; FFUNC	1000'0111
                                 ;	1000'0010
                                 ;	1000'0011
                                 ; FESC	1000'0000
                                 
                                 ; examples
                                 ; formatting string			printing
                                 ; "a=",FDEC,a,0				1-byte variable a, unsigned decimal
                                 ; "a=",FDEC2,a,0			2-byte variable a (a1,a0), unsigend
                                 ; "a=",FDEC|FSIGN,a,0		1-byte variable 1, signed decimal
                                 ; "n=",FBIN,PIND+$20,0		i/o port, binary, notice offset of $20
                                 ; "f=",FFRAC4|FSIGN,a,16,$88,0	4-byte signed fixed-point fraction
                                 ;				dec.point at 16, 8 int.digits, 8 frac.digits	
                                 ; "f=",FFRAC2,a,16,$18,0		2-byte unsigned fixed-point fraction
                                 ;				dec.point at 16, 1 int.digits, 8 frac.digits	
                                 ; "a=",FDEC|FDIG5|FSIGN,a,0	1-byte variable, 5-digit, decimal, signed
                                 ; "a=",FDEC|FDIG5,a,0		1-byte variable, 5-digit, decimal, unsigned
                                 
                                 ; === registers modified ===
                                 ; e0,e1	used to transmit address of putc routine
                                 ; zh,zl	used as pointer to prog-memory
                                 
                                 ; === constants ==============================================
                                 
                                 .equ	FDEC	= 0b11000000	; 1-byte variable
                                 .equ	FDEC2	= 0b11010000	; 2-byte variable
                                 .equ	FDEC3	= 0b11100000	; 3-byte variable
                                 .equ	FDEC4	= 0b11110000	; 4-byte variable
                                 
                                 .equ	FBIN	= 0b10100000
                                 .equ	FHEX	= 0b10010100	; 1-byte variable
                                 .equ	FHEX2	= 0b10011000	; 2-byte variable
                                 .equ	FHEX3	= 0b10011100	; 3-byte variable
                                 .equ	FHEX4	= 0b10010000	; 4-byte variable
                                 
                                 .equ	FFRAC	= 0b10001000	; 1-byte variable
                                 .equ	FFRAC2	= 0b10001010	; 2-byte variable
                                 .equ	FFRAC3	= 0b10001100	; 3-byte variable
                                 .equ	FFRAC4	= 0b10001110	; 4-byte variable
                                 
                                 .equ	FCHAR	= 0b10000100
                                 .equ	FSTR	= 0b10000101
                                 
                                 .equ	FSIGN	= 0b00000001
                                 
                                 .equ	FDIG1	= 1<<1
                                 .equ	FDIG2	= 2<<1
                                 .equ	FDIG3	= 3<<1	
                                 .equ	FDIG4	= 4<<1
                                 .equ	FDIG5	= 5<<1
                                 .equ	FDIG6	= 6<<1
                                 .equ	FDIG7	= 7<<1
                                 
                                 ; ===macro ====================================================
                                 
                                 .macro	PRINTF			; putc function (UART, LCD...)
                                 	ldi	w, low(@0)		; address of "putc" in e1:d0
                                 	mov	e0,w
                                 	ldi	w,high(@0)
                                 	mov	e1,w
                                 	call	_printf
                                 	.endmacro
                                 
                                 ; mod	y,z
                                 
                                 
                                 ; === routines ================================================
                                 
                                 _printf:
0003cd 91ff
0003ce 91ef                      	POPZ			; z points to begin of "string"
0003cf 0fee
0003d0 1fff                      	MUL2Z			; multiply Z by two, (word ptr -> byte ptr)
0003d1 93af
0003d2 93bf                      	PUSHX
                                 		
                                 _printf_read:
0003d3 95c8                      	lpm				; places prog_mem(Z) into r0 (=c)
0003d4 9631                      	adiw	zl,1	; increment pointer Z
0003d5 2000                      	tst	r0			; test for ZERO (=end of string)
0003d6 f021                      	breq	_printf_end	; char=0 indicates end of ascii string
0003d7 f04a                      	brmi	_printf_formatted ; bit7=1 indicates formatting character
0003d8 2d00                      	mov	w,r0
0003d9 d013                      	rcall	_putw	; display the character
0003da cff8                      	rjmp	_printf_read	; read next character in the string
                                 	
                                 _printf_end:
0003db 9631                      	adiw	zl,1	; point to the next character
0003dc 95f6
0003dd 95e7                      	DIV2Z			; divide by 2 (byte ptr -> word ptr)
0003de 91bf
0003df 91af                      	POPX
0003e0 9409                      	ijmp			; return to instruction after "string"
                                 
                                 _printf_formatted:
                                 
                                 ; FDEC	11bb'iiis
                                 ; FBIN	101i'iiis
                                 ; FHEX	1001'iiis
                                 ; FFRAC	1000'1bbs
                                 ; FCHAR	1000'0100
                                 ; FSTR	1000'0101
                                 
0003e1 fa00                      	bst	r0,0		; store sign in T
0003e2 2d00                      	mov	w,r0		; store formatting character in w
                                 
0003e3 95c8                      	lpm	
0003e4 2da0                      	mov	xl,r0		; load x-pointer with SRAM address
0003e5 27bb                      	clr	xh			; clear high-byte
0003e6 9631                       	adiw	zl,1	; increment pointer Z
                                 
                                 ;	JB1	w,6,_putdec
                                 ;	JB1	w,5,_putbin
                                 ;	JB1	w,4,_puthex
                                 ;	JB1	w,3,_putfrac
0003e7 3804
0003e8 f079                      	JK	w,FCHAR,_putchar
0003e9 3805
0003ea f081                      	JK	w,FSTR ,_putstr
0003eb c015                      	rjmp	_putnum
                                 	
0003ec cfe6                      	rjmp	_printf_read	
                                 
                                 ; === putc (put character) ===============================
                                 ; in	w	character to put
                                 ;	e1,e0	address of output routine (UART, LCD putc)
                                 _putw:
0003ed 932f
0003ee 93ff
0003ef 93ef                      	PUSH3	a0,zh,zl
0003f0 2de4
0003f1 2df5
0003f2 2f20                      	MOV3	a0,zh,zl, w,e1,e0
0003f3 9509                      	icall			; indirect call to "putc"
0003f4 91ef
0003f5 91ff
0003f6 912f                      	POP3	a0,zh,zl
0003f7 9508                      	ret
                                 
                                 ; === putchar (put character) ============================
                                 ; in	x	pointer to character to put
                                 _putchar:
0003f8 910c                      	ld	w,x
0003f9 dff3                      	rcall	_putw
0003fa cfd8                      	rjmp	_printf_read
                                 	
                                 ; === putstr (put string) ================================
                                 ; in	x	pointer to ascii string
                                 ;	b3,b2	address of output routine (UART, LCD putc)
                                 _putstr:
0003fb 910d                      	ld	w,x+
0003fc 2300                      	tst	w
0003fd f409                      	brne	PC+2
0003fe cfd4                      	rjmp	_printf_read
0003ff dfed                      	rcall	_putw
000400 cffa                      	rjmp	_putstr
                                 
                                 ; === putnum (dec/bin/hex/frac) ===========================
                                 ; in	x	pointer to SRAM variable to print
                                 ; 	r0	formatting character
                                 	
                                 _putnum:
000401 935f
000402 934f
000403 933f
000404 932f                      	PUSH4	a3,a2,a1,a0	; safeguard a
000405 939f
000406 938f
000407 937f
000408 936f                      	PUSH4	b3,b2,b1,b0	; safeguard b	
000409 912d
00040a 913d
00040b 914d
00040c 915d                      	LDX4	a3,a2,a1,a0	; load operand to print into a
                                 
                                 ; FDEC	11bb'iiis
                                 ; FBIN	101i'iiis
                                 ; FHEX	1001'iiis
                                 ; FRACT	1000'1bbs
                                 
00040d fd06
00040e c006                      	JB1	w,6,_putdec
00040f fd05
000410 c00f                      	JB1	w,5,_putbin
000411 fd04
000412 c010                      	JB1	w,4,_puthex
000413 fd03
000414 c019                      	JB1	w,3,_putfrac
                                 
                                 ; FDEC	11bb'iiis
                                 _putdec:
000415 e06a                      	ldi	b0,10		; b0 = base (10)
                                 
000416 2f70                      	mov	b1,w
000417 9576                      	lsr	b1
000418 7077                      	andi	b1,0b111	
000419 9572                      	swap	b1		; b1 = format 0iii'0000 (integer digits)
00041a e080                      	ldi	b2,0		; b2 = dec. point position = 0 (right)
                                 	
00041b 2f90                      	mov	b3,w
00041c 9592                      	swap	b3
00041d 7093                      	andi	b3,0b11
00041e 9593                      	inc	b3			; b3 = number of bytes (1..4)
00041f c01a                      	rjmp	_getnum	; get number of digits (iii)
                                 
                                 ; FBIN	101i'iiis	addr
                                 _putbin:	
000420 e062                      	ldi	b0,2		; b0 = base (2)
000421 e094                      	ldi	b3,4		; b3 = number of bytes (4)	
000422 c003                      	rjmp	_getdig	; get number of digits (iii)
                                 
                                 ; FHEX	1001'iiis	addr
                                 _puthex:	
000423 e160                      	ldi	b0,16		; b0 = base (16)
000424 e094                      	ldi	b3,4		; b3 = number of bytes (4)
000425 c000                      	rjmp	_getdig
                                 
                                 _getdig:
000426 2f70                      	mov	b1,w
000427 9576                      	lsr	b1
000428 7077                      	andi	b1,0b111
000429 f409                      	brne	PC+2
00042a e078                      	ldi	b1,8		; if b1=0 then 8-digits
00042b 9572                      	swap	b1		; b1 = format 0iii'0000 (integer digits)
00042c e080                      	ldi	b2, 0		; b2 = dec. point position = 0 (right)
00042d c00c                      	rjmp	_getnum
                                 
                                 ; FFRAC	1000'1bbs	addr	 00dd'dddd, 	iiii'ffff
                                 	
                                 _putfrac:
00042e e06a                      	ldi	b0,10		; base=10	
00042f 95c8                      	lpm
000430 2d80                      	mov	b2,r0		; load dec.point position
000431 9631                      	adiw	zl,1	; increment char pointer
000432 95c8                      	lpm
000433 2d70                      	mov	b1,r0		; load ii.ff format
000434 9631                      	adiw	zl,1	; increment char pointer
                                 	
000435 2f90                      	mov	b3,w
000436 9595                      	asr	b3
000437 7093                      	andi	b3,0b11
000438 9593                      	inc	b3			; b3 = number of bytes (1..4)
                                 
000439 c000                      	rjmp	_getnum
                                 
                                 _getnum:
                                 ; in 	a	4-byte variable
                                 ; 	b3	number of bytes (1..4)
                                 ;	T	sign, 0=unsigned, 1=signed
                                 
00043a 3094
00043b f081                      	JK	b3,4,_printf_4b
00043c 3093
00043d f051                      	JK	b3,3,_printf_3b
00043e 3092
00043f f021                      	JK	b3,2,_printf_2b	
                                 	
                                 _printf_1b:			; sign extension
000440 2733                      	clr	a1
000441 f416                      	brtc	PC+3	; T=1 sign extension
000442 fd27                      	sbrc	a0,7
000443 ef3f                      	ldi	a1,0xff
                                 _printf_2b:
000444 2744                      	clr	a2
000445 f416                      	brtc	PC+3	; T=1 sign extension	
000446 fd37                      	sbrc	a1,7
000447 ef4f                      	ldi	a2,0xff
                                 _printf_3b:	
000448 2755                      	clr	a3
000449 f416                      	brtc	PC+3	; T=1 sign extension
00044a fd47                      	sbrc	a2,7
00044b ef5f                      	ldi	a3,0xff
                                 _printf_4b:
                                 
00044c d009                      	rcall	_ftoa		; float to ascii
00044d 916f
00044e 917f
00044f 918f
000450 919f                      	POP4	b3,b2,b1,b0	; restore b
000451 912f
000452 913f
000453 914f
000454 915f                      	POP4	a3,a2,a1,a0	; restore a
                                 	
000455 cf7d                      	rjmp	_printf_read
                                 
                                 ; ===============================================
                                 ; func	ftoa
                                 ; converts a fixed-point fractional number to an ascii string
                                 ; author (c) Raphael Holzer
                                 ;
                                 ; in	a3-a0	variable to print
                                 ;	b0	base, 2 to 36, but usually decimal (10)
                                 ;	b1	number of digits to print ii.ff
                                 ; 	b2	position of the decimal point (0=right, 32=left)
                                 ;	T	sign (T=0 unsiged, T=1 signed)
                                 
                                 _ftoa:
000456 92cf                      	push	d0
000457 92bf
000458 92af
000459 929f
00045a 928f                      	PUSH4	c3,c2,c1,c0	; c = fraction part, a = integer part
00045b 18bb
00045c 24aa
00045d 2499
00045e 2488                      	CLR4	c3,c2,c1,c0	; clear fraction part
                                 
00045f f486                      	brtc	_ftoa_plus	; if T=0 then unsigned
000460 94e8                      	clt
000461 2355                      	tst	a3				; if MSb(a)=1 then a=-a
000462 f46a                      	brpl	_ftoa_plus
000463 9468                      	set					; T=1 (minus)
000464 2377                      	tst	b1
000465 f009                      	breq	PC+2		; if b1=0 the print ALL digits
000466 5170                      	subi	b1,0x10		; decrease int digits
000467 9550
000468 9540
000469 9530
00046a 9520
00046b ef0f
00046c 1b20
00046d 0b30
00046e 0b40
00046f 0b50                      	NEG4	a3,a2,a1,a0	; negate a
                                 _ftoa_plus:	
000470 2388                      	tst	b2				; b0=0 (only integer part)
000471 f051                      	breq	_ftoa_int	
                                 _ftoa_shift:	
000472 9555
000473 9547
000474 9537
000475 9527                      	ASR4	a3,a2,a1,a0	; a = integer part	
000476 94b7
000477 94a7
000478 9497
000479 9487                      	ROR4	c3,c2,c1,c0	; c = fraction part
00047a 958a
00047b f7b1                      	DJNZ	b2,_ftoa_shift
                                 _ftoa_int:
00047c 937f                      	push	b1			; ii.ff (ii=int digits)
00047d 9572                      	swap	b1
00047e 707f                      	andi	b1,0x0f
                                 	
00047f e20e                      	ldi	w,'.'			; push decimal point
000480 930f                      	push	w
                                 _ftoa_int1:
000481 d045                      	rcall	_div41		; int=int/10
000482 2d0c                      	mov	w,d0			; d=reminder
000483 d030                      	rcall	_hex2asc
000484 930f                      	push	w			; push rem(int/10)
000485 2700
000486 1720
000487 0730
000488 0740
000489 0750                      	TST4	a3,a2,a1,a0	; (int/10)=?
00048a f029                      	breq	_ftoa_space	; (int/10)=0 then finished
00048b 2377                      	tst	b1
00048c f3a1                      	breq	_ftoa_int1	; if b1=0 then print ALL int-digits
00048d 957a
00048e f791                      	DJNZ	b1,_ftoa_int1
00048f c007                      	rjmp	_ftoa_sign
                                 _ftoa_space:
000490 2377                      	tst	b1				; if b1=0 then print ALL int-digits
000491 f029                      	breq	_ftoa_sign
000492 957a                      	dec	b1
000493 f019                      	breq	_ftoa_sign
000494 e200                      	ldi	w,' '			; write spaces
000495 df57                      	rcall	_putw	
000496 cff9                      	rjmp	_ftoa_space
                                 _ftoa_sign:
000497 f416                      	brtc	PC+3		; if T=1 then write 'minus'
000498 e20d                      	ldi	w,'-'
000499 df53                      	rcall	_putw
                                 _ftoa_int3:
00049a 910f                      	pop	w
00049b 320e                      	cpi	w,'.'
00049c f011                      	breq	PC+3
00049d df4f                      	rcall	_putw
00049e cffb                      	rjmp	_ftoa_int3
                                 
00049f 917f                      	pop	b1				; ii.ff (ff=frac digits)
0004a0 707f                      	andi	b1,0x0f
0004a1 2377                      	tst	b1
0004a2 f059                      	breq	_ftoa_end
                                 _ftoa_point:	
0004a3 df49                      	rcall	_putw		; write decimal point
0004a4 2d28
0004a5 2d39
0004a6 2d4a
0004a7 2d5b                      	MOV4	a3,a2,a1,a0, c3,c2,c1,c0		
                                 _ftoa_frac:
0004a8 d011                      	rcall	_mul41		; d.frac=10*frac
0004a9 2d0c                      	mov	w,d0
0004aa d009                      	rcall	_hex2asc
0004ab df41                      	rcall	_putw
0004ac 957a
0004ad f7d1                      	DJNZ	b1,_ftoa_frac
                                 _ftoa_end:
0004ae 908f
0004af 909f
0004b0 90af
0004b1 90bf                      	POP4	c3,c2,c1,c0
0004b2 90cf                      	pop	d0
0004b3 9508                      	ret
                                 
                                 ; === hexadecimal to ascii ===
                                 ; in	w
                                 _hex2asc:
0004b4 300a                      	cpi	w,10
0004b5 f410                      	brsh	PC+3
0004b6 5d00                      	addi	w,'0'
0004b7 9508                      	ret
0004b8 5a09                      	addi	w,('a'-10)
0004b9 9508                      	ret
                                 
                                 ; === multiply 4byte*1byte ===
                                 ; funct mul41
                                 ; multiplies a3-a0 (4-byte) by b0 (1-byte)
                                 ; author (c) Raphael Holzer, EPFL
                                 ; 
                                 ; in	a3..a0	multiplicand (argument to multiply)
                                 ;	b0	multiplier
                                 ; out	a3..a0	result
                                 ; 	d0	result MSB (byte 4)
                                 ;
0004ba 24cc                      _mul41:	clr	d0			; clear byte4 of result
0004bb e200                      	ldi	w,32			; load bit counter
0004bc 9488                      __m41:	clc				; clear carry
0004bd fd20                      	sbrc	a0,0		; skip addition if LSB=0
0004be 0ec6                      	add	d0,b0			; add b to MSB of a
0004bf 94c7
0004c0 9557
0004c1 9547
0004c2 9537
0004c3 9527                      	ROR5	d0,a3,a2,a1,a0	; shift-right c, LSB (of b) into carry
0004c4 950a
0004c5 f7b1                      	DJNZ	w,__m41		; Decrement and Jump if bit-count Not Zero
0004c6 9508                      	ret
                                 
                                 ; === divide 4byte/1byte ===
                                 ; func div41
                                 ; in	a0..a3 	divident (argument to divide)
                                 ;	b0 	divider
                                 ; out	a0..a3 	result 
                                 ;	d0	reminder
                                 ;
0004c7 24cc                      _div41:	clr	d0			; d will contain the remainder
0004c8 e200                      	ldi	w,32			; load bit counter
0004c9 1f22
0004ca 1f33
0004cb 1f44
0004cc 1f55
0004cd 1ccc                      __d41:	ROL5	d0,a3,a2,a1,a0	; shift carry into result c
0004ce 1ac6                      	sub	d0, b0			; subtract b from remainder
0004cf f408                      	brcc	PC+2	
0004d0 0ec6                      	add	d0, b0			; restore if remainder became negative
0004d1 950a
0004d2 f7b1                      	DJNZ	w,__d41		; Decrement and Jump if bit-count Not Zero
0004d3 1f22
0004d4 1f33
0004d5 1f44
0004d6 1f55                      	ROL4	a3,a2,a1,a0	; last shift (carry into result c)
0004d7 9550
0004d8 9540
0004d9 9530
0004da 9520                      	COM4	a3,a2,a1,a0	; complement result
0004db 9508                      	ret
                                 
                                 reset:
0004dc ef0f
0004dd bf0d
0004de e100
0004df bf0e                      	LDSP	RAMEND	
0004e0 dc5f                      	rcall LCD_init
0004e1 ef0f                      	ldi r16, 0xff
0004e2 bb07                      	out DDRB, r16
0004e3 e000                      	ldi r16, 0x00
0004e4 bb01                      	out DDRD, r16
0004e5 940c 04e7                 	jmp main
                                 
                                 main:
0004e7 dc42                      	rcall	LCD_clear
0004e8 940e 0140
0004ea ecee
0004eb e0f2
0004ec 940e 03c5
0004ee edea
0004ef e0f2
0004f0 e420
0004f1 940e 014c
0004f3 940e 03c5                 	DISPLAY2 str0, str1
0004f5 ed00
0004f6 2e30
0004f7 e008
0004f8 930f
0004f9 923f
0004fa e300
0004fb 2e30
0004fc e006
0004fd 943a
0004fe f7f1
0004ff 943a
000500 950a
000501 f7d9
000502 903f
000503 910f
000504 943a
000505 f791
000506 950a
000507 f781                      	WAIT_MS 2000
                                 
                                 main_loop:
000508 d00e                      	rcall start
000509 fd61
00050a 940e 0530                 	CB1 b0,1, safe
00050c fd60
00050d 940e 0538                 	CB1 b0,0, games
00050f fd60
000510 940e 0551                 	CB1 b0,0, trivia
000512 fd61
000513 940e 0b4c                 	CB1 b0,1, dance
000515 940c 0508                 	jmp main_loop
                                 
                                 start:
000517 940e 0140
000519 eee4
00051a e0f2
00051b 940e 03c5
00051d efe2
00051e e0f2
00051f e420
000520 940e 014c
000522 940e 03c5                 	DISPLAY2 str2, str3
000524 940e 00e1                 	call reset_kpd
000526 940e 0b90                 	call check_reset
000528 2f62                      	mov b0, a0
000529 3861                      	cpi b0, 0x81
00052a f011                      	breq PC+3
00052b 3862                      	cpi b0, 0x82
00052c f409                      	brne PC+2
00052d 9508                      	ret
00052e 940c 0517                 	jmp start
                                 
                                 safe:
000530 940e 0140
000532 ebe8
000533 e0f3
000534 940e 03c5                 	DISPLAY1 str6
000536 940c 0b6e                 	jmp end
                                 
                                 games:
000538 940e 0140
00053a e9e8
00053b e0f3
00053c 940e 03c5
00053e eae8
00053f e0f3
000540 e420
000541 940e 014c
000543 940e 03c5                 	DISPLAY2 str4, str5
000545 940e 00e1                 	call reset_kpd
000547 940e 0b90                 	call check_reset
000549 2f62                      	mov b0, a0
00054a 3861                      	cpi b0, 0x81
00054b f011                      	breq PC+3
00054c 3862                      	cpi b0, 0x82
00054d f409                      	brne PC+2
00054e 9508                      	ret
00054f 940c 0538                 	jmp games
                                 
                                 
                                 trivia:
000551 940e 0140
000553 e0e0
000554 e0f3
000555 940e 03c5
000557 e0ec
000558 e0f3
000559 e420
00055a 940e 014c
00055c 940e 03c5                 	DISPLAY2 strwelcome, strivia
00055e ed00
00055f 2e30
000560 e008
000561 930f
000562 923f
000563 e300
000564 2e30
000565 e006
000566 943a
000567 f7f1
000568 943a
000569 950a
00056a f7d9
00056b 903f
00056c 910f
00056d 943a
00056e f791
00056f 950a
000570 f781                      	WAIT_MS 2000
000571 940e 0140
000573 e3e6
000574 e0f3
000575 940e 03c5
000577 e4e6
000578 e0f3
000579 e420
00057a 940e 014c
00057c 940e 03c5                 	DISPLAY2 strivia2, strivia3
00057e ed00
00057f 2e30
000580 e008
000581 930f
000582 923f
000583 e300
000584 2e30
000585 e006
000586 943a
000587 f7f1
000588 943a
000589 950a
00058a f7d9
00058b 903f
00058c 910f
00058d 943a
00058e f791
00058f 950a
000590 f781                      	WAIT_MS 2000
000591 e000
000592 2e90                      	_LDI c1, 0x00
000593 940e 0140
000595 e1ea
000596 e0f4
000597 940e 03c5
000599 e2e8
00059a e0f4
00059b e420
00059c 940e 014c
00059e 940e 03c5
0005a0 940e 00e1
0005a2 940e 0b90
0005a4 2f62
0005a5 7820
0005a6 f009
0005a7 940c 05dd
0005a9 3468
0005aa f741
0005ab 940e 0140
0005ad e3ea
0005ae e0f4
0005af 940e 03c5
0005b1 e4ec
0005b2 e0f4
0005b3 e420
0005b4 940e 014c
0005b6 940e 03c5
0005b8 940e 00e1
0005ba 940e 0b90
0005bc 2f62
0005bd 7820
0005be f009
0005bf 940c 05dd
0005c1 3468
0005c2 f741
0005c3 940e 0140
0005c5 e5ee
0005c6 e0f4
0005c7 940e 03c5
0005c9 e6ec
0005ca e0f4
0005cb e420
0005cc 940e 014c
0005ce 940e 03c5
0005d0 940e 00e1
0005d2 940e 0b90
0005d4 2f62
0005d5 7820
0005d6 f009
0005d7 940c 05dd
0005d9 3468
0005da f741
0005db 940c 0593                 	QUESTION striviaQ1, striviaQ12, strivia1A, strivia1B, strivia1C, strivia1D
0005dd e7ea
0005de e0f4
0005df 95c8
0005e0 1560
0005e1 f409
0005e2 9468                      	COMPARE answer1
0005e3 f40e                      	brtc PC+2
0005e4 9493                      	inc c1
0005e5 940e 012a
0005e7 f00e
0005e8 940c 05f2
0005ea 940e 0140
0005ec e2e4
0005ed e0f3
0005ee 940e 03c5
0005f0 940c 05f8
0005f2 940e 0140
0005f4 e2ee
0005f5 e0f3
0005f6 940e 03c5
0005f8 1b55
0005f9 2744
0005fa 2733
0005fb 2722
0005fc 2d29
0005fd e10e
0005fe 2e40
0005ff e001
000600 2e50
000601 940e 03cd
000603 6353
000604 726f
000605 3a65
000606 12c0
C:\Users\renuka\Desktop\projet\MCU\AssemblerApplication1\AssemblerApplication1\macros.asm(122): warning: .cseg .db misalignment - padding zero byte
C:\Users\renuka\Desktop\projet\MCU\AssemblerApplication1\AssemblerApplication1\mainbis.asm(167): macro 'PRINT_SCORE' called here
000607 0000                      	PRINT_SCORE c1
000608 ed00
000609 2e30
00060a e008
00060b 930f
00060c 923f
00060d e300
00060e 2e30
00060f e006
000610 943a
000611 f7f1
000612 943a
000613 950a
000614 f7d9
000615 903f
000616 910f
000617 943a
000618 f791
000619 950a
00061a f781                      	WAIT_MS 2000
00061b 940e 0140
00061d e7ec
00061e e0f4
00061f 940e 03c5
000621 e8e6
000622 e0f4
000623 e420
000624 940e 014c
000626 940e 03c5
000628 940e 00e1
00062a 940e 0b90
00062c 2f62
00062d 7820
00062e f009
00062f 940c 0665
000631 3468
000632 f741
000633 940e 0140
000635 e9e0
000636 e0f4
000637 940e 03c5
000639 eae0
00063a e0f4
00063b e420
00063c 940e 014c
00063e 940e 03c5
000640 940e 00e1
000642 940e 0b90
000644 2f62
000645 7820
000646 f009
000647 940c 0665
000649 3468
00064a f741
00064b 940e 0140
00064d eaee
00064e e0f4
00064f 940e 03c5
000651 ece0
000652 e0f4
000653 e420
000654 940e 014c
000656 940e 03c5
000658 940e 00e1
00065a 940e 0b90
00065c 2f62
00065d 7820
00065e f009
00065f 940c 0665
000661 3468
000662 f741
000663 940c 061b                 	QUESTION striviaQ2, striviaQ22, strivia2A, strivia2B, strivia2C, strivia2D
000665 ede0
000666 e0f4
000667 95c8
000668 1560
000669 f409
00066a 9468                      	COMPARE answer2
00066b f40e                      	brtc PC+2
00066c 9493                      	inc c1
00066d 940e 012a
00066f f00e
000670 940c 067a
000672 940e 0140
000674 e2e4
000675 e0f3
000676 940e 03c5
000678 940c 0680
00067a 940e 0140
00067c e2ee
00067d e0f3
00067e 940e 03c5
000680 1b55
000681 2744
000682 2733
000683 2722
000684 2d29
000685 e10e
000686 2e40
000687 e001
000688 2e50
000689 940e 03cd
00068b 6353
00068c 726f
00068d 3a65
00068e 12c0
C:\Users\renuka\Desktop\projet\MCU\AssemblerApplication1\AssemblerApplication1\macros.asm(122): warning: .cseg .db misalignment - padding zero byte
C:\Users\renuka\Desktop\projet\MCU\AssemblerApplication1\AssemblerApplication1\mainbis.asm(173): macro 'PRINT_SCORE' called here
00068f 0000                      	PRINT_SCORE c1
000690 ed00
000691 2e30
000692 e008
000693 930f
000694 923f
000695 e300
000696 2e30
000697 e006
000698 943a
000699 f7f1
00069a 943a
00069b 950a
00069c f7d9
00069d 903f
00069e 910f
00069f 943a
0006a0 f791
0006a1 950a
0006a2 f781                      	WAIT_MS 2000
0006a3 940e 0140
0006a5 ede2
0006a6 e0f4
0006a7 940e 03c5
0006a9 eee4
0006aa e0f4
0006ab e420
0006ac 940e 014c
0006ae 940e 03c5
0006b0 940e 00e1
0006b2 940e 0b90
0006b4 2f62
0006b5 7820
0006b6 f009
0006b7 940c 06ed
0006b9 3468
0006ba f741
0006bb 940e 0140
0006bd efe0
0006be e0f4
0006bf 940e 03c5
0006c1 e0e2
0006c2 e0f5
0006c3 e420
0006c4 940e 014c
0006c6 940e 03c5
0006c8 940e 00e1
0006ca 940e 0b90
0006cc 2f62
0006cd 7820
0006ce f009
0006cf 940c 06ed
0006d1 3468
0006d2 f741
0006d3 940e 0140
0006d5 e1e2
0006d6 e0f5
0006d7 940e 03c5
0006d9 e1ee
0006da e0f5
0006db e420
0006dc 940e 014c
0006de 940e 03c5
0006e0 940e 00e1
0006e2 940e 0b90
0006e4 2f62
0006e5 7820
0006e6 f009
0006e7 940c 06ed
0006e9 3468
0006ea f741
0006eb 940c 06a3                 	QUESTION striviaQ3, striviaQ32, strivia3A, strivia3B, strivia3C, strivia3D
0006ed e2ec
0006ee e0f5
0006ef 95c8
0006f0 1560
0006f1 f409
0006f2 9468                      	COMPARE answer3
0006f3 f40e                      	brtc PC+2
0006f4 9493                      	inc c1
0006f5 940e 012a
0006f7 f00e
0006f8 940c 0702
0006fa 940e 0140
0006fc e2e4
0006fd e0f3
0006fe 940e 03c5
000700 940c 0708
000702 940e 0140
000704 e2ee
000705 e0f3
000706 940e 03c5
000708 1b55
000709 2744
00070a 2733
00070b 2722
00070c 2d29
00070d e10e
00070e 2e40
00070f e001
000710 2e50
000711 940e 03cd
000713 6353
000714 726f
000715 3a65
000716 12c0
C:\Users\renuka\Desktop\projet\MCU\AssemblerApplication1\AssemblerApplication1\macros.asm(122): warning: .cseg .db misalignment - padding zero byte
C:\Users\renuka\Desktop\projet\MCU\AssemblerApplication1\AssemblerApplication1\mainbis.asm(179): macro 'PRINT_SCORE' called here
000717 0000                      	PRINT_SCORE c1
000718 ed00
000719 2e30
00071a e008
00071b 930f
00071c 923f
00071d e300
00071e 2e30
00071f e006
000720 943a
000721 f7f1
000722 943a
000723 950a
000724 f7d9
000725 903f
000726 910f
000727 943a
000728 f791
000729 950a
00072a f781                      	WAIT_MS 2000
00072b 940e 0140
00072d e2ee
00072e e0f5
00072f 940e 03c5
000731 e3ee
000732 e0f5
000733 e420
000734 940e 014c
000736 940e 03c5
000738 940e 00e1
00073a 940e 0b90
00073c 2f62
00073d 7820
00073e f009
00073f 940c 0775
000741 3468
000742 f741
000743 940e 0140
000745 e4ec
000746 e0f5
000747 940e 03c5
000749 e5ee
00074a e0f5
00074b e420
00074c 940e 014c
00074e 940e 03c5
000750 940e 00e1
000752 940e 0b90
000754 2f62
000755 7820
000756 f009
000757 940c 0775
000759 3468
00075a f741
00075b 940e 0140
00075d e6ec
00075e e0f5
00075f 940e 03c5
000761 e7e8
000762 e0f5
000763 e420
000764 940e 014c
000766 940e 03c5
000768 940e 00e1
00076a 940e 0b90
00076c 2f62
00076d 7820
00076e f009
00076f 940c 0775
000771 3468
000772 f741
000773 940c 072b                 	QUESTION striviaQ4, striviaQ42, strivia4A, strivia4B, strivia4C, strivia4D
000775 e8e6
000776 e0f5
000777 95c8
000778 1560
000779 f409
00077a 9468                      	COMPARE answer4
00077b f40e                      	brtc PC+2
00077c 9493                      	inc c1
00077d 940e 012a
00077f f00e
000780 940c 078a
000782 940e 0140
000784 e2e4
000785 e0f3
000786 940e 03c5
000788 940c 0790
00078a 940e 0140
00078c e2ee
00078d e0f3
00078e 940e 03c5
000790 1b55
000791 2744
000792 2733
000793 2722
000794 2d29
000795 e10e
000796 2e40
000797 e001
000798 2e50
000799 940e 03cd
00079b 6353
00079c 726f
00079d 3a65
00079e 12c0
C:\Users\renuka\Desktop\projet\MCU\AssemblerApplication1\AssemblerApplication1\macros.asm(122): warning: .cseg .db misalignment - padding zero byte
C:\Users\renuka\Desktop\projet\MCU\AssemblerApplication1\AssemblerApplication1\mainbis.asm(185): macro 'PRINT_SCORE' called here
00079f 0000                      	PRINT_SCORE c1
0007a0 ed00
0007a1 2e30
0007a2 e008
0007a3 930f
0007a4 923f
0007a5 e300
0007a6 2e30
0007a7 e006
0007a8 943a
0007a9 f7f1
0007aa 943a
0007ab 950a
0007ac f7d9
0007ad 903f
0007ae 910f
0007af 943a
0007b0 f791
0007b1 950a
0007b2 f781                      	WAIT_MS 2000
0007b3 940e 0140
0007b5 e8e8
0007b6 e0f5
0007b7 940e 03c5
0007b9 e9e4
0007ba e0f5
0007bb e420
0007bc 940e 014c
0007be 940e 03c5
0007c0 940e 00e1
0007c2 940e 0b90
0007c4 2f62
0007c5 7820
0007c6 f009
0007c7 940c 07fd
0007c9 3468
0007ca f741
0007cb 940e 0140
0007cd e9ee
0007ce e0f5
0007cf 940e 03c5
0007d1 ebe0
0007d2 e0f5
0007d3 e420
0007d4 940e 014c
0007d6 940e 03c5
0007d8 940e 00e1
0007da 940e 0b90
0007dc 2f62
0007dd 7820
0007de f009
0007df 940c 07fd
0007e1 3468
0007e2 f741
0007e3 940e 0140
0007e5 ebee
0007e6 e0f5
0007e7 940e 03c5
0007e9 ece8
0007ea e0f5
0007eb e420
0007ec 940e 014c
0007ee 940e 03c5
0007f0 940e 00e1
0007f2 940e 0b90
0007f4 2f62
0007f5 7820
0007f6 f009
0007f7 940c 07fd
0007f9 3468
0007fa f741
0007fb 940c 07b3                 	QUESTION striviaQ5, striviaQ52, strivia5A, strivia5B, strivia5C, strivia5D
0007fd ede0
0007fe e0f5
0007ff 95c8
000800 1560
000801 f409
000802 9468                      	COMPARE answer5
000803 f40e                      	brtc PC+2
000804 9493                      	inc c1
000805 940e 012a
000807 f00e
000808 940c 0812
00080a 940e 0140
00080c e2e4
00080d e0f3
00080e 940e 03c5
000810 940c 0818
000812 940e 0140
000814 e2ee
000815 e0f3
000816 940e 03c5
000818 1b55
000819 2744
00081a 2733
00081b 2722
00081c 2d29
00081d e10e
00081e 2e40
00081f e001
000820 2e50
000821 940e 03cd
000823 6353
000824 726f
000825 3a65
000826 12c0
C:\Users\renuka\Desktop\projet\MCU\AssemblerApplication1\AssemblerApplication1\macros.asm(122): warning: .cseg .db misalignment - padding zero byte
C:\Users\renuka\Desktop\projet\MCU\AssemblerApplication1\AssemblerApplication1\mainbis.asm(191): macro 'PRINT_SCORE' called here
000827 0000                      	PRINT_SCORE c1
000828 ed00
000829 2e30
00082a e008
00082b 930f
00082c 923f
00082d e300
00082e 2e30
00082f e006
000830 943a
000831 f7f1
000832 943a
000833 950a
000834 f7d9
000835 903f
000836 910f
000837 943a
000838 f791
000839 950a
00083a f781                      	WAIT_MS 2000
00083b 940e 0140
00083d ede2
00083e e0f5
00083f 940e 03c5
000841 eee4
000842 e0f5
000843 e420
000844 940e 014c
000846 940e 03c5
000848 940e 00e1
00084a 940e 0b90
00084c 2f62
00084d 7820
00084e f009
00084f 940c 0885
000851 3468
000852 f741
000853 940e 0140
000855 efe4
000856 e0f5
000857 940e 03c5
000859 e0e6
00085a e0f6
00085b e420
00085c 940e 014c
00085e 940e 03c5
000860 940e 00e1
000862 940e 0b90
000864 2f62
000865 7820
000866 f009
000867 940c 0885
000869 3468
00086a f741
00086b 940e 0140
00086d e1e6
00086e e0f6
00086f 940e 03c5
000871 e2e4
000872 e0f6
000873 e420
000874 940e 014c
000876 940e 03c5
000878 940e 00e1
00087a 940e 0b90
00087c 2f62
00087d 7820
00087e f009
00087f 940c 0885
000881 3468
000882 f741
000883 940c 083b                 	QUESTION striviaQ6, striviaQ62, strivia6A, strivia6B, strivia6C, strivia6D
000885 e2ee
000886 e0f6
000887 95c8
000888 1560
000889 f409
00088a 9468                      	COMPARE answer6
00088b f40e                      	brtc PC+2
00088c 9493                      	inc c1
00088d 940e 012a
00088f f00e
000890 940c 089a
000892 940e 0140
000894 e2e4
000895 e0f3
000896 940e 03c5
000898 940c 08a0
00089a 940e 0140
00089c e2ee
00089d e0f3
00089e 940e 03c5
0008a0 1b55
0008a1 2744
0008a2 2733
0008a3 2722
0008a4 2d29
0008a5 e10e
0008a6 2e40
0008a7 e001
0008a8 2e50
0008a9 940e 03cd
0008ab 6353
0008ac 726f
0008ad 3a65
0008ae 12c0
C:\Users\renuka\Desktop\projet\MCU\AssemblerApplication1\AssemblerApplication1\macros.asm(122): warning: .cseg .db misalignment - padding zero byte
C:\Users\renuka\Desktop\projet\MCU\AssemblerApplication1\AssemblerApplication1\mainbis.asm(197): macro 'PRINT_SCORE' called here
0008af 0000                      	PRINT_SCORE c1
0008b0 ed00
0008b1 2e30
0008b2 e008
0008b3 930f
0008b4 923f
0008b5 e300
0008b6 2e30
0008b7 e006
0008b8 943a
0008b9 f7f1
0008ba 943a
0008bb 950a
0008bc f7d9
0008bd 903f
0008be 910f
0008bf 943a
0008c0 f791
0008c1 950a
0008c2 f781                      	WAIT_MS 2000
0008c3 940e 0140
0008c5 e3e0
0008c6 e0f6
0008c7 940e 03c5
0008c9 e3ee
0008ca e0f6
0008cb e420
0008cc 940e 014c
0008ce 940e 03c5
0008d0 940e 00e1
0008d2 940e 0b90
0008d4 2f62
0008d5 7820
0008d6 f009
0008d7 940c 090d
0008d9 3468
0008da f741
0008db 940e 0140
0008dd e4ea
0008de e0f6
0008df 940e 03c5
0008e1 e5ec
0008e2 e0f6
0008e3 e420
0008e4 940e 014c
0008e6 940e 03c5
0008e8 940e 00e1
0008ea 940e 0b90
0008ec 2f62
0008ed 7820
0008ee f009
0008ef 940c 090d
0008f1 3468
0008f2 f741
0008f3 940e 0140
0008f5 e6e8
0008f6 e0f6
0008f7 940e 03c5
0008f9 e7e2
0008fa e0f6
0008fb e420
0008fc 940e 014c
0008fe 940e 03c5
000900 940e 00e1
000902 940e 0b90
000904 2f62
000905 7820
000906 f009
000907 940c 090d
000909 3468
00090a f741
00090b 940c 08c3                 	QUESTION striviaQ7, striviaQ72, strivia7A, strivia7B, strivia7C, strivia7D
00090d e7ec
00090e e0f6
00090f 95c8
000910 1560
000911 f409
000912 9468                      	COMPARE answer7
000913 f40e                      	brtc PC+2
000914 9493                      	inc c1
000915 940e 012a
000917 f00e
000918 940c 0922
00091a 940e 0140
00091c e2e4
00091d e0f3
00091e 940e 03c5
000920 940c 0928
000922 940e 0140
000924 e2ee
000925 e0f3
000926 940e 03c5
000928 1b55
000929 2744
00092a 2733
00092b 2722
00092c 2d29
00092d e10e
00092e 2e40
00092f e001
000930 2e50
000931 940e 03cd
000933 6353
000934 726f
000935 3a65
000936 12c0
C:\Users\renuka\Desktop\projet\MCU\AssemblerApplication1\AssemblerApplication1\macros.asm(122): warning: .cseg .db misalignment - padding zero byte
C:\Users\renuka\Desktop\projet\MCU\AssemblerApplication1\AssemblerApplication1\mainbis.asm(203): macro 'PRINT_SCORE' called here
000937 0000                      	PRINT_SCORE c1
000938 ed00
000939 2e30
00093a e008
00093b 930f
00093c 923f
00093d e300
00093e 2e30
00093f e006
000940 943a
000941 f7f1
000942 943a
000943 950a
000944 f7d9
000945 903f
000946 910f
000947 943a
000948 f791
000949 950a
00094a f781                      	WAIT_MS 2000
00094b 940e 0140
00094d e7ee
00094e e0f6
00094f 940e 03c5
000951 e9e0
000952 e0f6
000953 e420
000954 940e 014c
000956 940e 03c5
000958 940e 00e1
00095a 940e 0b90
00095c 2f62
00095d 7820
00095e f009
00095f 940c 0995
000961 3468
000962 f741
000963 940e 0140
000965 e9ee
000966 e0f6
000967 940e 03c5
000969 eae6
00096a e0f6
00096b e420
00096c 940e 014c
00096e 940e 03c5
000970 940e 00e1
000972 940e 0b90
000974 2f62
000975 7820
000976 f009
000977 940c 0995
000979 3468
00097a f741
00097b 940e 0140
00097d ebe4
00097e e0f6
00097f 940e 03c5
000981 ebee
000982 e0f6
000983 e420
000984 940e 014c
000986 940e 03c5
000988 940e 00e1
00098a 940e 0b90
00098c 2f62
00098d 7820
00098e f009
00098f 940c 0995
000991 3468
000992 f741
000993 940c 094b                 	QUESTION striviaQ8, striviaQ82, strivia8A, strivia8B, strivia8C, strivia8D
000995 ede0
000996 e0f6
000997 95c8
000998 1560
000999 f409
00099a 9468                      	COMPARE answer8
00099b f40e                      	brtc PC+2
00099c 9493                      	inc c1
00099d 940e 012a
00099f f00e
0009a0 940c 09aa
0009a2 940e 0140
0009a4 e2e4
0009a5 e0f3
0009a6 940e 03c5
0009a8 940c 09b0
0009aa 940e 0140
0009ac e2ee
0009ad e0f3
0009ae 940e 03c5
0009b0 1b55
0009b1 2744
0009b2 2733
0009b3 2722
0009b4 2d29
0009b5 e10e
0009b6 2e40
0009b7 e001
0009b8 2e50
0009b9 940e 03cd
0009bb 6353
0009bc 726f
0009bd 3a65
0009be 12c0
C:\Users\renuka\Desktop\projet\MCU\AssemblerApplication1\AssemblerApplication1\macros.asm(122): warning: .cseg .db misalignment - padding zero byte
C:\Users\renuka\Desktop\projet\MCU\AssemblerApplication1\AssemblerApplication1\mainbis.asm(209): macro 'PRINT_SCORE' called here
0009bf 0000                      	PRINT_SCORE c1
0009c0 ed00
0009c1 2e30
0009c2 e008
0009c3 930f
0009c4 923f
0009c5 e300
0009c6 2e30
0009c7 e006
0009c8 943a
0009c9 f7f1
0009ca 943a
0009cb 950a
0009cc f7d9
0009cd 903f
0009ce 910f
0009cf 943a
0009d0 f791
0009d1 950a
0009d2 f781                      	WAIT_MS 2000
0009d3 940e 0140
0009d5 ede2
0009d6 e0f6
0009d7 940e 03c5
0009d9 eee2
0009da e0f6
0009db e420
0009dc 940e 014c
0009de 940e 03c5
0009e0 940e 00e1
0009e2 940e 0b90
0009e4 2f62
0009e5 7820
0009e6 f009
0009e7 940c 0a1d
0009e9 3468
0009ea f741
0009eb 940e 0140
0009ed efe4
0009ee e0f6
0009ef 940e 03c5
0009f1 e0e6
0009f2 e0f7
0009f3 e420
0009f4 940e 014c
0009f6 940e 03c5
0009f8 940e 00e1
0009fa 940e 0b90
0009fc 2f62
0009fd 7820
0009fe f009
0009ff 940c 0a1d
000a01 3468
000a02 f741
000a03 940e 0140
000a05 e1e4
000a06 e0f7
000a07 940e 03c5
000a09 e1ec
000a0a e0f7
000a0b e420
000a0c 940e 014c
000a0e 940e 03c5
000a10 940e 00e1
000a12 940e 0b90
000a14 2f62
000a15 7820
000a16 f009
000a17 940c 0a1d
000a19 3468
000a1a f741
000a1b 940c 09d3                 	QUESTION striviaQ9, striviaQ92, strivia9A, strivia9B, strivia9C, strivia9D
000a1d e2ee
000a1e e0f7
000a1f 95c8
000a20 1560
000a21 f409
000a22 9468                      	COMPARE answer9
000a23 f40e                      	brtc PC+2
000a24 9493                      	inc c1
000a25 940e 012a
000a27 f00e
000a28 940c 0a32
000a2a 940e 0140
000a2c e2e4
000a2d e0f3
000a2e 940e 03c5
000a30 940c 0a38
000a32 940e 0140
000a34 e2ee
000a35 e0f3
000a36 940e 03c5
000a38 1b55
000a39 2744
000a3a 2733
000a3b 2722
000a3c 2d29
000a3d e10e
000a3e 2e40
000a3f e001
000a40 2e50
000a41 940e 03cd
000a43 6353
000a44 726f
000a45 3a65
000a46 12c0
C:\Users\renuka\Desktop\projet\MCU\AssemblerApplication1\AssemblerApplication1\macros.asm(122): warning: .cseg .db misalignment - padding zero byte
C:\Users\renuka\Desktop\projet\MCU\AssemblerApplication1\AssemblerApplication1\mainbis.asm(215): macro 'PRINT_SCORE' called here
000a47 0000                      	PRINT_SCORE c1
000a48 ed00
000a49 2e30
000a4a e008
000a4b 930f
000a4c 923f
000a4d e300
000a4e 2e30
000a4f e006
000a50 943a
000a51 f7f1
000a52 943a
000a53 950a
000a54 f7d9
000a55 903f
000a56 910f
000a57 943a
000a58 f791
000a59 950a
000a5a f781                      	WAIT_MS 2000
000a5b 940e 0140
000a5d e3e0
000a5e e0f7
000a5f 940e 03c5
000a61 e3ee
000a62 e0f7
000a63 e420
000a64 940e 014c
000a66 940e 03c5
000a68 940e 00e1
000a6a 940e 0b90
000a6c 2f62
000a6d 7820
000a6e f009
000a6f 940c 0aa5
000a71 3468
000a72 f741
000a73 940e 0140
000a75 e4ea
000a76 e0f7
000a77 940e 03c5
000a79 e5e8
000a7a e0f7
000a7b e420
000a7c 940e 014c
000a7e 940e 03c5
000a80 940e 00e1
000a82 940e 0b90
000a84 2f62
000a85 7820
000a86 f009
000a87 940c 0aa5
000a89 3468
000a8a f741
000a8b 940e 0140
000a8d e6ea
000a8e e0f7
000a8f 940e 03c5
000a91 e7e8
000a92 e0f7
000a93 e420
000a94 940e 014c
000a96 940e 03c5
000a98 940e 00e1
000a9a 940e 0b90
000a9c 2f62
000a9d 7820
000a9e f009
000a9f 940c 0aa5
000aa1 3468
000aa2 f741
000aa3 940c 0a5b                 	QUESTION striviaQ10, striviaQ102, strivia10A, strivia10B, strivia10C, strivia10D
000aa5 e8e8
000aa6 e0f7
000aa7 95c8
000aa8 1560
000aa9 f409
000aaa 9468                      	COMPARE answer10
000aab f40e                      	brtc PC+2
000aac 9493                      	inc c1
000aad 940e 012a
000aaf f00e
000ab0 940c 0aba
000ab2 940e 0140
000ab4 e2e4
000ab5 e0f3
000ab6 940e 03c5
000ab8 940c 0ac0
000aba 940e 0140
000abc e2ee
000abd e0f3
000abe 940e 03c5
000ac0 1b55
000ac1 2744
000ac2 2733
000ac3 2722
000ac4 2d29
000ac5 e10e
000ac6 2e40
000ac7 e001
000ac8 2e50
000ac9 940e 03cd
000acb 6353
000acc 726f
000acd 3a65
000ace 12c0
C:\Users\renuka\Desktop\projet\MCU\AssemblerApplication1\AssemblerApplication1\macros.asm(122): warning: .cseg .db misalignment - padding zero byte
C:\Users\renuka\Desktop\projet\MCU\AssemblerApplication1\AssemblerApplication1\mainbis.asm(221): macro 'PRINT_SCORE' called here
000acf 0000                      	PRINT_SCORE c1
000ad0 ed00
000ad1 2e30
000ad2 e008
000ad3 930f
000ad4 923f
000ad5 e300
000ad6 2e30
000ad7 e006
000ad8 943a
000ad9 f7f1
000ada 943a
000adb 950a
000adc f7d9
000add 903f
000ade 910f
000adf 943a
000ae0 f791
000ae1 950a
000ae2 f781                      	WAIT_MS 2000
000ae3 e005                      	ldi w, 0x05
000ae4 1690                      	cp c1, w
000ae5 f410                      	brsh trivia_won
000ae6 940c 0b2a                 	jmp trivia_lost
                                 trivia_won:
000ae8 940e 0140
000aea e6ec
000aeb e0f3
000aec 940e 03c5
000aee e7ec
000aef e0f3
000af0 e420
000af1 940e 014c
000af3 940e 03c5                     DISPLAY2 strwin1, strwin2
000af5 ed00
000af6 2e30
000af7 e008
000af8 930f
000af9 923f
000afa e300
000afb 2e30
000afc e006
000afd 943a
000afe f7f1
000aff 943a
000b00 950a
000b01 f7d9
000b02 903f
000b03 910f
000b04 943a
000b05 f791
000b06 950a
000b07 f781                      	WAIT_MS 2000
000b08 940e 0140
000b0a e5e6
000b0b e0f3
000b0c 940e 03c5
000b0e e6e0
000b0f e0f3
000b10 e420
000b11 940e 014c
000b13 940e 03c5                 	DISPLAY2 strclue1a, strclue1b
000b15 ea00
000b16 2e30
000b17 e100
000b18 930f
000b19 923f
000b1a e300
000b1b 2e30
000b1c e006
000b1d 943a
000b1e f7f1
000b1f 943a
000b20 950a
000b21 f7d9
000b22 903f
000b23 910f
000b24 943a
000b25 f791
000b26 950a
000b27 f781                      	WAIT_MS 4000
000b28 940c 0508                 	jmp main_loop
                                 trivia_lost:
000b2a 940e 0140
000b2c e8e4
000b2d e0f3
000b2e 940e 03c5
000b30 e8ee
000b31 e0f3
000b32 e420
000b33 940e 014c
000b35 940e 03c5                 	DISPLAY2 strlose1, strlose2
000b37 ed00
000b38 2e30
000b39 e008
000b3a 930f
000b3b 923f
000b3c e300
000b3d 2e30
000b3e e006
000b3f 943a
000b40 f7f1
000b41 943a
000b42 950a
000b43 f7d9
000b44 903f
000b45 910f
000b46 943a
000b47 f791
000b48 950a
000b49 f781                      	WAIT_MS 2000
000b4a 940c 0508                 	jmp main_loop
                                 
                                 dance:
000b4c 940e 0140
000b4e e0e0
000b4f e0f3
000b50 940e 03c5
000b52 e1e6
000b53 e0f3
000b54 e420
000b55 940e 014c
000b57 940e 03c5                 	DISPLAY2 strwelcome, strbutton
000b59 ed00
000b5a 2e30
000b5b e008
000b5c 930f
000b5d 923f
000b5e e300
000b5f 2e30
000b60 e006
000b61 943a
000b62 f7f1
000b63 943a
000b64 950a
000b65 f7d9
000b66 903f
000b67 910f
000b68 943a
000b69 f791
000b6a 950a
000b6b f781                      	WAIT_MS 2000
000b6c 940c 0508                 	jmp main_loop
                                 
                                 
                                 end:
000b6e 940e 0140
000b70 e0e2
000b71 e0f4
000b72 940e 03c5
000b74 e0ee
000b75 e0f4
000b76 e420
000b77 940e 014c
000b79 940e 03c5                 	DISPLAY2 str10, str11
000b7b ed00
000b7c 2e30
000b7d e008
000b7e 930f
000b7f 923f
000b80 e300
000b81 2e30
000b82 e006
000b83 943a
000b84 f7f1
000b85 943a
000b86 950a
000b87 f7d9
000b88 903f
000b89 910f
000b8a 943a
000b8b f791
000b8c 950a
000b8d f781                      	WAIT_MS 2000
000b8e 940c 04dc                 	jmp reset
                                 
                                 check_reset:
000b90 e108
000b91 1680                      	_CPI c0, 0x18 ; check if * key pressed
000b92 f409                      	brne PC+2
000b93 940c 04dc                 	jmp reset


RESOURCE USE INFORMATION
------------------------

Notice:
The register and instruction counts are symbol table hit counts,
and hence implicitly used resources are not counted, eg, the
'lpm' instruction without operands implicitly uses r0 and z,
none of which are counted.

x,y,z are separate entities in the symbol table and are
counted separately from r26..r31 here.

.dseg memory usage only counts static data declared with .byte

"ATmega128" register use summary:
x  :   6 y  :   0 z  :   0 r0 :  20 r1 :   6 r2 :   6 r3 : 184 r4 :  11 
r5 :  11 r6 :   0 r7 :   0 r8 :   7 r9 :  27 r10:   5 r11:   6 r12:  11 
r13:   0 r14:   8 r15:   4 r16: 444 r17:   1 r18: 157 r19:  26 r20:  26 
r21:  36 r22:  98 r23:  26 r24:   8 r25:  16 r26:   3 r27:   3 r28:   0 
r29:   0 r30: 125 r31: 119 
Registers used: 28 out of 35 (80.0%)

"ATmega128" instruction use summary:
.lds  :   0 .sts  :   0 adc   :   0 add   :   4 adiw  :   6 and   :   4 
andi  :  37 asr   :   2 bclr  :   0 bld   :   0 brbc  :   0 brbs  :   0 
brcc  :   1 brcs  :   0 break :   0 breq  :  50 brge  :   0 brhc  :   0 
brhs  :   0 brid  :   0 brie  :   0 brlo  :   0 brlt  :   0 brmi  :   1 
brne  : 158 brpl  :   1 brsh  :   2 brtc  :  15 brts  :  10 brvc  :   0 
brvs  :   0 bset  :   0 bst   :   1 call  : 290 cbi   :   0 cbr   :   0 
clc   :   1 clh   :   0 cli   :   0 cln   :   0 clr   :  53 cls   :   0 
clt   :   1 clv   :   0 clz   :   0 com   :   8 cp    :  13 cpc   :   3 
cpi   :  43 cpse  :   0 dec   : 136 elpm  :   0 eor   :   0 fmul  :   0 
fmuls :   0 fmulsu:   0 icall :   1 ijmp  :   1 in    :   5 inc   :  12 
jmp   :  77 ld    :   6 ldd   :   0 ldi   : 452 lds   :   3 lpm   :  48 
lsl   :   1 lsr   :   3 mov   : 151 movw  :   0 mul   :   0 muls  :   0 
mulsu :   0 neg   :   0 nop   :   1 or    :   0 ori   :   2 out   :  16 
pop   :  75 push  :  74 rcall :  26 ret   :  17 reti  :   1 rjmp  :  42 
rol   :  10 ror   :  13 sbc   :   3 sbci  :   1 sbi   :   1 sbic  :   0 
sbis  :   0 sbiw  :   0 sbr   :   1 sbrc  :  21 sbrs  :   0 sec   :   0 
seh   :   0 sei   :   1 sen   :   0 ser   :   0 ses   :   0 set   :  11 
sev   :   0 sez   :   0 sleep :   0 spm   :   0 st    :   0 std   :   0 
sts   :   3 sub   :  13 subi  :  10 swap  :   4 tst   :  14 wdr   :   0 

Instructions used: 58 out of 114 (50.9%)

"ATmega128" memory use summary [bytes]:
Segment   Begin    End      Code   Data   Used    Size   Use%
---------------------------------------------------------------
[.cseg] 0x000000 0x00172c   4602   1330   5932  131072   4.5%
[.dseg] 0x000100 0x000100      0      0      0    4096   0.0%
[.eseg] 0x000000 0x000000      0      0      0    4096   0.0%

Assembly complete, 0 errors, 69 warnings
